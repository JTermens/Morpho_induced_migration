/*

*/
func mesh oneCutSmooth(
  int bndDensity, real cut, real r0, real rArch, real symmAxis, int labelBnd, 
  real lengthScale, real Nmax
){
  /*
  [mesh] oneCutSmooth returns a mesh with a boundary defined by circle with a
  strigth cut of angular length cut, perpendicular to a ray in the symmAxis 
  direction. The vertices of the cut are smoothed by tangential arches of 
  radius rArch.

  Parameters:
  - real bndDensity: boundary density, num. of points per unit lenght at the 
  boundary.
  - real cut: angluar length of the straight cut line.
  - real r0: radius of the circumference (Front) arch.
  - real rArch: radius of the tangential arches that smooth the cut vertices. 
  - real symmAxis: orientation of the shape. Defines the mid-line of the cut.
  - int labelBnd: free boundary label.
  - real lengthScale: length scale to adimensionalize the mesh (x, y /= L).
  - real Nmax: Maximum number of points per border piece.

  * Return type: mesh
  */

  real cutAxis = symmAxis+pi;
  real t1 = acos((cos(cut/2.)-(rArch/r0))/(1-(rArch/r0)));

  real OxRight = (r0-rArch)*cos(cutAxis+t1);
  real OyRight = (r0-rArch)*sin(cutAxis+t1);
  real OxLeft = (r0-rArch)*cos(cutAxis-t1);
  real OyLeft = (r0-rArch)*sin(cutAxis-t1);
  real lenCut = sqrt((OxRight-OxLeft)*(OxRight-OxLeft) + (OyRight-OyLeft)*(OyRight-OyLeft));

  border GammaArchLeft(t=0,1){
    x = OxLeft+rArch*cos(cutAxis-t1*(1-t)); 
    y = OyLeft+rArch*sin(cutAxis-t1*(1-t)); 
    label = labelBnd;
  };

  border GammaCut(t=0,1){
    x = ((OxLeft+rArch*cos(cutAxis))+(OxRight-OxLeft)*t);
    y = ((OyLeft+rArch*sin(cutAxis))+(OyRight-OyLeft)*t);
    label = labelBnd;
  };

  border GammaArchRight(t=0,1){
    x = OxRight+rArch*cos(cutAxis+t1*t); 
    y = OyRight+rArch*sin(cutAxis+t1*t);
    label = labelBnd;
  };

  border GammaArchFront(t=0,1){
    x = r0*cos(cutAxis+t1+2*(pi-t1)*t);
    y = r0*sin(cutAxis+t1+2*(pi-t1)*t);
    label = labelBnd;
  };

  mesh Th=/*buildmesh*/emptymesh(
    GammaArchLeft(bndDensity*rArch*t1)
    + GammaCut(bndDensity*lenCut)
    + GammaArchRight(bndDensity*rArch*t1)
    + GammaArchFront(bndDensity*r0*2*(pi-t1))
  );

  return Th;
}
