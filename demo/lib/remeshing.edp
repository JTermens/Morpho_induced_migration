/*

*/


func mesh closedRemesh(
  real[int,int] bnd, real lBnd, int nBnd,real bndLayerLentgh, int obd, 
  int ibd, int labelBnd, real smoothCoef, bool keepPoints, bool bndLayer
){

  int[int] be(1); // To save begin and ends of the curve
  int minPoints = 20;

  // It is not convenient to define a border inside an If
  // So 1st define all the borders and then apply the If to the mesh generation

  border OuterKeepPoints(t=0,1){ P=Curve(bnd,bnd(2,round(t*(nBnd)))/lBnd);label=labelBnd;}
  
  // Remesh the outr boundary using an Akima spline
  gslspline splineX(gslinterpakima, bnd(2,:), bnd(0,:));
  gslspline splineY(gslinterpakima, bnd(2,:), bnd(1,:));

  border OuterSpline(t=0,1){x=splineX(t*lBnd); y=splineY(t*lBnd); label=labelBnd;}
  
  int nOut = keepPoints? nBnd : round(obd*lBnd);

  mesh Th0;
  if (keepPoints) {
    Th0 = buildmesh(OuterKeepPoints(nOut));
  } else {
    Th0 = buildmesh(OuterSpline(nOut));
  }

  if (!bndLayer) {
    return Th0;
  }

  // FEM Spaces
  fespace Dh(Th0, P1); // For distance function (remeshing scheme) and data exports

  // Distance function (d is the minimal distance to the boundary)
  varf vong(B, d)= on(labelBnd,B=1);
  real[int] ong=vong(0,Dh);
  Dh B =1, d;
  B[] = ong ? 0 : B[];
  distance(Th0,B,d[]);

  // Get the new inner boundary vertices (ISO is the contour d==bndLayerLentgh) with multiple loops
  real[int,int] ISO(3,1); int nc=isoline(Th0,d,iso=bndLayerLentgh,close=0,ISO,beginend=be,smoothing=bndLayerLentgh*smoothCoef,ratio=1.e-0);
  int nInnerLoops = be.n/2;
  // cout << be << endl;

  int[int] nInner(nInnerLoops); // numer of points per loop
  int nCorrectLoops = 0; // number of loops with more than minPoints
  real[int] s0(nInnerLoops); // initial archlenght of the loop

  // find number of points and count > minPoints
  // Also, filter for errors in the archlength
  for (int i=0;  i < nInnerLoops; i++){
    real lInner=ISO(2,be(i*2+1)-1);
    s0[i] = ISO(2,be(i*2));
    nInner[i] = round(ibd*lInner);
    if((nInner[i] > minPoints) && (s0[i] == 0)){nCorrectLoops++;}
  }

  // if the number of points is less than minPoints, filter the border for safety
  int[int] nInnerFilter(nCorrectLoops);
  int[int] beFilter(2*nCorrectLoops);

  int j = 0;
  for (int i=0;  i < nInnerLoops; i++){
    if((nInner[i] > minPoints) && (s0[i] == 0)){
      nInnerFilter[j] = nInner[i];
      beFilter[2*j] = be[i*2];
      beFilter[2*j+1] = be[i*2+1];
      j++;
    }
  }
  
  border Inner(t=0,1;i) {P=Curve(ISO,beFilter(i*2),beFilter(i*2+1)-1,t); label=(labelBnd+1);} // Inner boundary multi-border

  mesh Th;
  if (keepPoints) {
    Th = buildmesh(OuterKeepPoints(nOut)+Inner(nInnerFilter));
  } else {
    Th = buildmesh(OuterSpline(nOut)+Inner(nInnerFilter));
  }
  Th = change(Th, rmInternalEdges=1);
  return Th;
}
