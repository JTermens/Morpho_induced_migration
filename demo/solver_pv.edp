//
//

// Packages for advanced remeshing scheme
load "Curvature"
load "distance"
load "isoline"
load "gsl"
// include <iostream>; // If needed

// Include the modules containing the mesh-generation and remeshing functions.
include "lib/mesh-generation.edp";
include "lib/remeshing.edp";

verbosity = 0;                    // Verbosity level.
bool debug = 1;                   // if true, gives extra plots and console logs.
bool err = 0;                     // Whether the simulations ends with an error or not. 

string rootDir = ".";                 // Folder to save the results, . indicates pwd.
string simulName = "semicircle_test"; // Name of the sample simulation

// Simulation parameters --------------------------------------------------------------------------

// Physical parameters of the problem
real Lc = 40;            // Nematic length, sqrt(K/a), [μm].
real eta = 2.5e4;        // Monolayer viscosity, [kPa·s].
real xi = 0.1;           // Friction coef, [kPa·s/μm²].
real zeta = -25;         // -Contractility coef, [kPa]. < 0 to generate contractile stress.
real zi = 0.1;           // Traction coef, [kPa/μm]. Initial traction at the CM.

// Domain parameters
real cut = pi;           // Angular length of the cutted circle chord, [rad].
real R0 = 200;           // Initial radius of the monolayer, [μm].
real symmAxis = pi/2.;   // Angle of the symmetry axis of each assymetric shape. [rad]
real fracRarc = 0.1;     // Percent of r0 to smooth the domain vertices.

// Numerical parameters of the simulations
int labelBnd = 1;        // Mesh identifiers
int obd = 45;            // Outer boundary mesh density, obd points for adim. unit length.
int ibd = 15;            // Inner boundary mesh density.
real dt = 5e-4;          // Adim. time step, real time step = dt * eta/(zi*Lc).
int NiterTime = 2000;    // Number of iterations, Max time = NiteTime * dt * eta/(zi0*Lc).
real rateMaxArea = 8;    // Stop the simulation when Area = rateMaxArea * (Initial Area).
real rateMinArea = 1/8.; // Stop the simulation when Area = rateMinArea * (Initial Area).
bool keepPoints = 0;     // Keep the number of boundary points upon remeshing.

// Save parameters
bool bsave = 1;          // To save the solutions or not, handy for debugging.
int dsave = 20;          // Save frame gap. Usually we do not need that many solutions to 
                         // represent an evolution and also it will save memory and loading time.

// Problem length & timescales
real lambda = sqrt(eta/xi);      // hydrodynamic sceening length
real La = zeta/zi;               // active length; < 0 (> 0) for contractile (extensile) stress
real tscale = eta/(zi*Lc);       // Problem timescale
// ------------------------------------------------------------------------------------------------

// Compute the lengthScale and define the adim. parameters ----------------------------------------
real lengthScale;
{
  real Nmax = 100; // Avoid very big meshes.
  mesh Th = oneCutSmooth(obd, cut, R0, fracRarc*R0, symmAxis, labelBnd, 1, Nmax);
  lengthScale = sqrt(Th.measure/pi);
}

// Problem adim. Parameters
real a = La/Lc;                       // Active length, zeta/zi, and lengthScale ratio
real b = lengthScale/lambda;          // lengthScale and hydrodynamic length, sqrt(eta/xi), ratio
real c = lengthScale/Lc;              // lengthScale and nematic length ratio
real bLayerThickness = max(1/c,0.15); // Adim. width of the boundary layer (finer mesh), >= Lc/R0.
// ------------------------------------------------------------------------------------------------


// Construct the adim. mesh -----------------------------------------------------------------------
mesh Th;
{
  real Nmax = 1e5; // Safety value, avoid triggering the Nmax mechanism.
  Th = oneCutSmooth(obd, cut, R0, fracRarc*R0, symmAxis, labelBnd, lengthScale, Nmax);

  // Extract outer boundary
  // extractborder gives bOut(3,Th.nbe) with 1st point == last point
  // for k in (0,Th.nbe-1): 
  //    bOut(0,k) == x coord kth vertex
  //    bOut(1,k) == y coord kth vertex
  //    bOut(2,k) == arch length at the kth vertex
  real[int,int] bMesh(3,1); real lMesh = extractborder(Th, labelBnd, bMesh);

  // Create and adaptive mesh.
  Th = closedRemesh(bMesh,lMesh,bMesh.m-1,bLayerThickness,obd,ibd,labelBnd,.5,0,1);
}

// Initial variables for shape characterization
real Area0 = Th.measure; // Inital Area of the Fluid Domain
real Xcm0 = int2d(Th)(x)/Area0; //Initial x_cm
real Ycm0 = int2d(Th)(y)/Area0; //Initial y_cm
if (debug) {
  plot(Th, value = true, fill = false, nbiso=64, wait=true, 
     cmm = "adaptive mesh;  A0="+Area0+",  (xcm0,ycm0)=("+Xcm0+","+Ycm0+")"
  );
}
// -------------------------------------------------------------------------------------------------


// Create folder structure, parameters' file & header of the global solutions' file ---------------
if (bsave){
  string simulHomeDir = rootDir+"/"+simulName;
  string fileNameParams = "/params.csv";
  string fileNameGlobalSol = "/global_sol.csv";

  exec("mkdir "+simulHomeDir);              // Make a home directory for the simulation
  exec("mkdir "+simulHomeDir+"/msh");        // Make and save the meshes in a separeted folder
  exec("mkdir "+simulHomeDir+"/local_sol");  // Make and save the local solutions in a sep. folder 

  {ofstream fileParams (simulHomeDir+fileNameParams); // Save the parameters in separate file

    fileParams.fixed;
    fileParams << "domain,cut,R0,lengthScale,fracRarc,obd,ibd,Lc,lambda,La,eta,xi,zi,zeta,tscale,"
               << "dt,dsave" <<  endl;
    fileParams << "string,rad,um,um,adim,adim,adim,um,um,um,kPa*s,kPa*s/um^2,kPa/um,kPa,s,"
               <<"adim,adim" << endl;
    fileParams << "oneCutSmooth" << "," << cut  << "," << R0     << "," << lengthScale << "," 
               << fracRarc       << "," << obd  << "," << ibd    << "," << Lc          << ","
              << lambda          << "," << La   << "," << eta    << "," << xi          << "," 
              << zi              << "," << zeta << "," << tscale << "," << dt          << "," 
              << dsave           << endl;//  
  }
  // Generate a separate file for the global variables (integrated ones)
  {ofstream fileGlobalSol (simulHomeDir+fileNameGlobalSol);  
    fileGlobalSol  << "Time,Area,Xcm,Ycm,avgDivV,Vxcm,Vycm,Vxavg,Vyavg,Axcm,Aycm,Txavg,Tyavg,"
                   << "divXcm,divYcm,divXavgcm,duvYavgcm,divTermsX,divtermsY,MxxT,MxyT,MyyT,MxxF,"
                   << "MxyF,MyyF,MxxxT,MxxyT,MxyxT,MxyyT,MyyxT,MyyyT,MxxxF,MxxyF,MxyxF,MxyyF,"
                   << "MyyxF,MyyyF,Ix,Iy" << endl;
  }
} 
// ------------------------------------------------------------------------------------------------

// Console Log
cout << "Running " << simulName << ", saving = " << bsave << "..." << endl;
if (debug) {
  cout << "*  domain = " << "oneCutSmooth" << " (cut = " << cut <<", R0 = " << R0 << ")" << ",\n"
       << "*  a (La/Lc) = "              << a << "\n"
       << "*  b (lengthScale/lambda) = " << b << "\n"
       << "*  c (lengthScale/Lc) = "     << c << "\n"
       << "*  tscale = " << tscale << " s"<< endl;  
}

// Define the macros ------------------------------------------------------------------------------
macro pD [pDx, pDy] //                   // P2 extension for Dirichlet data
macro p [px, py] //                      // Polarity vector field
macro q [qx, qy] //                      // Polarity test functions
macro v [vx, vy] //                      // Velocity vector field
macro u [ux, uy] //                      // Velocity test functions
macro normal [nx, ny] //                 // Normal vectors at the boundary (null outside of it)

macro dp [dpxx,dpxy,dpyx,dpyy] //        // Gradient of the polarity field
macro dq [dqxx,dqxy,dqyx,dqyy] //        // Gradient of the polarity test functions
macro dv [dvxx,dvxy,dvyx,dvyy] //        // Gradient of the velocity field
macro du [duxx,duxy,duyx,duyy] //        // Gradient of the velocity test functions
macro d2px [dpxxx,dpxxy,dpxyx,dpxyy] //  // Hessian of the x-polarity
macro d2py [dpyxx,dpyxy,dpyyx,dpyyy] //  // Hessian of the y-polarity
macro d2qx [dqxxx,dqxxy,dqxyx,dqxyy] //  // Hessian of the x-polarity test function
macro d2qy [dqyxx,dqyxy,dqyyx,dqyyy] //  // Hessian of the y-polarity test 
      
macro grad(u) [dx(u),dy(u)] //                      // Gradient of a sclar
macro Grad(ux,uy) [dx(ux),dy(ux),dx(uy),dy(uy)] //  // Gradient of a vector
macro GradT(ux,uy) [dx(ux),dx(uy),dy(ux),dy(uy)] // // Grad vector transpose
macro Hessian(u) [dxx(u),dxy(u),dyx(u),dyy(u)] //   // Hessian of a scalar
macro pp(px,py) [px*px,px*py,py*px,py*py] //        // Active stress tensor

macro Norm(u) dist(u#x,u#y) + 1.e-12 //  // Vector norm + offset to avoid 0-length vectors
// ------------------------------------------------------------------------------------------------


//FEM spaces --------------------------------------------------------------------------------------
fespace Pol(Th, [P2, P2]);          // For polarity vector
fespace Pola(Th, P2 );              // For |p| (not essential, just visualization)
fespace dPol(Th,[P2,P2,P2,P2]);     // For the gradient of the polarity vector

fespace Vel(Th, [P1b, P1b]);        // For velocity vector
fespace dVel(Th,[P1b,P1b,P1b,P1b]); // For the gradient of the velocity vector

fespace Nh(Th,[P1,P1]);             // For the corrected normal vector at the boundary
// ------------------------------------------------------------------------------------------------


// Correction of the normal vectors at the boundary -----------------------------------------------
// Extract the new boundary
real[int,int] bOut(3,1); real lOut = extractborder(Th, labelBnd, bOut);
int nBnd = bOut.m; // instead of Th.nbe to avoid problems with mesh labels

// Retrieve the indices of the verices of bOut with the same ordering
int[int] bndIndices(nBnd);

int iTri;
for (int k=0; k<nBnd; k++){
  // Find the trinagle index of the kth bnd point
  iTri = Th(bOut(0,k),bOut(1,k)).nuTriangle;

  // Find index of the kth bnd point from its triangle index
  for (int jTri=0; jTri<3; jTri++) {
    if( abs(Th[iTri][jTri].x-bOut(0,k))<1e-12 && abs(Th[iTri][jTri].y-bOut(1,k))<1e-12){
      bndIndices(k) = Th[iTri][jTri];
    }
  }
}

bndIndices(nBnd-1) = bndIndices(0);

// Build the corrected normal vectors
Nh normal = [0,0]; // here the Dof of nx,ny are scramble.

real[int] nprev(2), npost(2), nmean(2);
int iBndElem; // index of the boundary element
real lenprev, lenpost;
nprev = [(bOut(1,0)-bOut(1,nBnd-2)),-(bOut(0,0)-bOut(0,nBnd-2))];
lenprev = sqrt(pow(nprev[0],2)+pow(nprev[1],2));

for (int k = 0; k < nBnd-1; k++){
  npost = [(bOut(1,k+1)-bOut(1,k)),-(bOut(0,k+1)-bOut(0,k))];
  lenpost = sqrt(pow(npost[0],2)+pow(npost[1],2));
  
  nmean = nprev*(lenpost/(lenpost+lenprev)) + npost*(lenprev/(lenprev+lenpost));
  nmean /= sqrt(pow(nmean[0],2)+pow(nmean[1],2));

  nx[](2*bndIndices(k))= nmean[0]; ny[](2*bndIndices(k)+1) = nmean[1];
  nprev = npost; lenprev = lenpost;
}

if (debug) {
  plot(Th, normal, value = true, fill = false, nbiso = 64, wait = true, cmm = "(nx,ny);");
}
// ------------------------------------------------------------------------------------------------


// Define & solve the polarity equations ----------------------------------------------------------
// P2 extension of polarity Dirichlet data
varf bndDirichlet(pD, q) = on(labelBnd, pDx = nx) + on(labelBnd, pDy = ny);
Pol pD=[0,0];
pDx[] = bndDirichlet(0, Pol, tgv = 1.0);

// Bilinear and linear variational forms P (Modified Homogeneous Drirchlet problem for p-pD)
varf ap(p, q) = int2d(Th)(
    (grad(px)'*grad(qx) + grad(py)'*grad(qy))
    + c*c*(p'*q)
  ) + on(labelBnd, px = 0.0) + on(labelBnd, py = 0.0);

varf lp(p, q) = int2d(Th)(
    - (grad(pDx)'*grad(qx) + grad(pDy)'*grad(qy))
    - c*c*(pD'*q)
  ) + on(labelBnd, px = 0.0) + on(labelBnd, py = 0.0);

// Assembly p
matrix Ap = ap(Pol, Pol, tgv = -2); // LHS matrix
real[int] bp = lp(0, Pol); // RHS

// p solution with vanishing Dirichlet data
real[int] solP(Pol.ndof);
solP=Ap^-1*bp;
Pol p=[0,0];
px[]=solP(0:Pol.ndof-1);

// P solution
p = p + pD;

if (debug) {
  plot(p, value = true, fill = true, nbiso = 64, wait = true, cmm = "(px,py)");
  Pola pABS = sqrt(px(x,y)^2 + py(x,y)^2); // Abs(P)
  plot(pABS, value = true, fill = true, nbiso = 64, wait = true, cmm = "|p|");
}
// ------------------------------------------------------------------------------------------------


// Define & solve the velocity equation -----------------------------------------------------------
// Bilinear and linear variational forms V
varf av(v, u) = int2d(Th)(
    ((Grad(vx,vy)+GradT(vx,vy))'*Grad(ux,uy)) 
    + pow(b,2)*(v'*u)
  ); // -viscosity -friction

varf lv(v, u) = int2d(Th)(
    + a*(pp(px,py)'*Grad(ux,uy)) 
    + c*(p'*u)
  ); //contractility +active traction

// Assembly V
matrix Av = av(Vel, Vel);
real[int] bv = lv(0, Vel);

// V solution
real[int] solV(Vel.ndof);
solV=Av^-1*bv;
Vel v=[0,0];
vx[]=solV(0:Vel.ndof-1);

if (debug) {
  plot(v, value = true, fill = true, nbiso = 64, wait = true, cmm = "(vx,vy)");
  Pola vABS = sqrt(vx(x,y)^2 + vy(x,y)^2); // Abs(P)
  plot(vABS, value = true, fill = true, nbiso = 64, wait = true, cmm = "|v|");
}
// ------------------------------------------------------------------------------------------------


// Compute the gradients and hessian of the problem fields ----------------------------------------
// Gradient of p
varf aGradP(dp, dq) = int2d(Th)(dp'*dq);
varf lGradP(dp, dq) = int2d(Th)(Grad(px,py)'*dq);

matrix AGradP = aGradP(dPol, dPol); // LHS matrix
real[int] bGradP = lGradP(0, dPol); // RHS vector

real[int] solGradP(dPol.ndof);
solGradP=AGradP^-1*bGradP;
dPol dp=[0,0,0,0];
dpxx[]=solGradP(0:dPol.ndof-1);

// Gradient of v
varf aGradV(dv, du) = int2d(Th)(dv'*du);
varf lGradV(dv, du) = int2d(Th)(Grad(vx,vy)'*du);

matrix AGradV = aGradV(dVel, dVel); // LHS matrix
real[int] bGradV = lGradV(0, dVel); // RHS vector

real[int] solGradV(dVel.ndof);
solGradV=AGradV^-1*bGradV;
dVel dv=[0,0,0,0];
dvxx[]=solGradV(0:dVel.ndof-1);

// Hessian of px
varf aHessPx(d2px,d2qx) = int2d(Th)(d2px'*d2qx);
varf lHessPx(d2px,d2qx) = int2d(Th)(Hessian(px)'*d2qx);

matrix AHessPx = aHessPx(dPol, dPol);  // LHS matrix
real[int] bHessPx = lHessPx(0, dPol);  // RHS vector

real[int] solHessPx(dPol.ndof);
solHessPx=AHessPx^-1*bHessPx;
dPol d2px=[0,0,0,0];
dpxxx[]=solHessPx(0:dPol.ndof-1);

// Hessian of py
varf aHessPy(d2py,d2qy) = int2d(Th)(d2py'*d2qy);
varf lHessPy(d2py,d2qy) = int2d(Th)(Hessian(py)'*d2qy);

matrix AHessPy = aHessPy(dPol, dPol);  // LHS matrix
real[int] bHessPy = lHessPy(0, dPol);  // RHS vector

real[int] solHessPy(dPol.ndof);
solHessPy=AHessPy^-1*bHessPy;
dPol d2py=[0,0,0,0];
dpyxx[]=solHessPy(0:dPol.ndof-1);
// ------------------------------------------------------------------------------------------------

// Compute the intial values of the global variables ----------------------------------------------
real Time = 0;                              // Time (adim)
real Areai = Th.measure;                    // Current area.
real Xcm = int2d(Th)(x)/Areai;              // Current Xcm.
real Ycm = int2d(Th)(y)/Areai;              // Current Ycm.
real avgDivV = int2d(Th)(dvxx+dvyy)/Areai;  // Average div of the velocity.

// Previous positions of the center of mass (-dt & -2*dt).
real[int] XcmPrev = [Xcm, Xcm];
real[int] YcmPrev = [Ycm, Ycm];

// Center of mass velocity (backward).
real Vxcm = (Xcm-XcmPrev[0])/dt; 
real Vycm = (Ycm-YcmPrev[0])/dt; 

// Current average velocity.
real Vxavg = int2d(Th)(vx)/Areai;
real Vyavg = int2d(Th)(vy)/Areai;

// Center of mass acceleration (2nd order backward).
real Axcm = (Xcm-2.*XcmPrev[0]+XcmPrev[1])/pow(dt,2);
real Aycm = (Ycm-2.*YcmPrev[0]+YcmPrev[1])/pow(dt,2);

// Average traction (adim).
real Txavg = int2d(Th)(c*px)/Areai;
real Tyavg = int2d(Th)(c*py)/Areai;

// Center of mass of the divergence of the velocity.
real divXcm = int2d(Th)(x*(dvxx+dvyy))/Areai;
real divYcm = int2d(Th)(y*(dvxx+dvyy))/Areai;

// Average divergence of the center of mass velocity.
real divXavgcm = Xcm*avgDivV;
real divYavgcm = Ycm*avgDivV;

// Divergence terms of the center of mass velocity (Spreading integral).
real divTermsX = int2d(Th)((x-Xcm)*(dvxx+dvyy))/Areai;
real divTermsY = int2d(Th)((y-Ycm)*(dvxx+dvyy))/Areai;

// Traction Dipole (adim & symmetric).
real MxxT = int2d(Th)((x-Xcm)*c*px);
real MxyT = int2d(Th)((x-Xcm)*c*py);
real MyyT = int2d(Th)((y-Ycm)*c*py);

// Friction Dipole (adim & symmetric).
real MxxF = int2d(Th)((x-Xcm)*pow(b,2)*vx);
real MxyF = int2d(Th)((x-Xcm)*pow(b,2)*vy);
real MyyF = int2d(Th)((y-Ycm)*pow(b,2)*vy);

// Traction Quadrupole (adim & symmetric).
real MxxxT = int2d(Th)(pow((x-Xcm),2)*c*px);
real MxxyT = int2d(Th)(pow((x-Xcm),2)*c*py);
real MxyxT = int2d(Th)((x-Xcm)*(y-Ycm)*c*px);
real MxyyT = int2d(Th)((x-Xcm)*(y-Ycm)*c*py);
real MyyxT = int2d(Th)(pow((y-Ycm),2)*c*px);
real MyyyT = int2d(Th)(pow((y-Ycm),2)*c*py);

// Friction Quadrupole (adim & symmetric).
real MxxxF = int2d(Th)(pow((x-Xcm),2)*pow(b,2)*vx);
real MxxyF = int2d(Th)(pow((x-Xcm),2)*pow(b,2)*vy);
real MxyxF = int2d(Th)((x-Xcm)*(y-Ycm)*pow(b,2)*vx);
real MxyyF = int2d(Th)((x-Xcm)*(y-Ycm)*pow(b,2)*vy);
real MyyxF = int2d(Th)(pow((y-Ycm),2)*pow(b,2)*vx);
real MyyyF = int2d(Th)(pow((y-Ycm),2)*pow(b,2)*vy);

// Moments of inertia with respect to the x & y axes at the CM
real Ix = int2d(Th)(pow(y-Ycm,2));
real Iy = int2d(Th)(pow(x-Xcm,2));
// ------------------------------------------------------------------------------------------------


// Time iteration ---------------------------------------------------------------------------------
for (int iterTime=0 ; iterTime<NiterTime ; iterTime++) {
  if (debug && iterTime % 100 == 0 && iterTime > 0) {
    // Console log every 100 iterations
    cout << iterTime << " out of " << NiterTime << " iterations completed" << endl;
  }


  // Correction of the normal vectors at the boundary ---------------------------------------------
  // Extract the new boundary
  lOut = extractborder(Th, labelBnd, bOut);
  nBnd = bOut.m; // instead of Th.nbe to avoid problems with mesh labels

  // Retrieve the indices of the verices of bOut with the same ordering
  int[int] bndIndices(nBnd);

  int iTri;
  for (int k=0; k<nBnd; k++){
    // Find the trinagle index of the kth bnd point
    iTri = Th(bOut(0,k),bOut(1,k)).nuTriangle;

    // Find index of the kth bnd point from its triangle index
    for (int jTri=0; jTri<3; jTri++) {
      if( abs(Th[iTri][jTri].x-bOut(0,k))<1e-12 && abs(Th[iTri][jTri].y-bOut(1,k))<1e-12){
        bndIndices(k) = Th[iTri][jTri];
      }
    }
  }
  bndIndices(nBnd-1) = bndIndices(0);
  
  // Build the corrected normal vectors
  Nh normal = [0,0]; // here the Dof of nx,ny are scramble.

  real[int] nprev(2), npost(2), nmean(2);
  int iBndElem; // index of the boundary element
  real lenprev, lenpost;
  nprev = [(bOut(1,0)-bOut(1,nBnd-2)),-(bOut(0,0)-bOut(0,nBnd-2))];
  lenprev = sqrt(pow(nprev[0],2)+pow(nprev[1],2));

  for (int k = 0; k < nBnd-1; k++){
    npost = [(bOut(1,k+1)-bOut(1,k)),-(bOut(0,k+1)-bOut(0,k))];
    lenpost = sqrt(pow(npost[0],2)+pow(npost[1],2));
    
    nmean = nprev*(lenpost/(lenpost+lenprev)) + npost*(lenprev/(lenprev+lenpost));
    nmean /= sqrt(pow(nmean[0],2)+pow(nmean[1],2));

    nx[](2*bndIndices(k))= nmean[0]; ny[](2*bndIndices(k)+1) = nmean[1];
    nprev = npost; lenprev = lenpost;
  }
  // ----------------------------------------------------------------------------------------------


  // Solve the polarity equation ------------------------------------------------------------------
  // P2 extension of polarity Dirichlet data
  varf bndDirichlet(pD, q) = on(labelBnd, pDx = nx) + on(labelBnd, pDy = ny);
  Pol pD=[0,0];
  pDx[] = bndDirichlet(0, Pol, tgv = 1.0);

  // Assembly P
  varf lp(p, q) = int2d(Th)(
      - (grad(pDx)'*grad(qx) + grad(pDy)'*grad(qy)) 
      - c*c*(pD'*q)
    ) + on(labelBnd, px = 0.0) + on(labelBnd, py=0.0);

  matrix Ap = ap(Pol, Pol, tgv = -2); // LHS matrix
  real[int] bp = lp(0, Pol);          // RHS

  // P solution with vanishing Dirichlet data
  real[int] sol(Pol.ndof);
  sol=Ap^-1*bp;
  Pol p=[0,0];
  px[]=sol(0:Pol.ndof-1);

  // P solution
  p = p + pD;
  // ----------------------------------------------------------------------------------------------


  // Solve the velocity equation ------------------------------------------------------------------
  // Assembly V
  varf lv(v, u) = int2d(Th)(
      + a*(pp(px,py)'*Grad(ux,uy))
      + c*(p'*u)
    ); //contractility + active traction

  matrix Av = av(Vel, Vel);  // LHS matrix
  real[int] bv = lv(0, Vel); // RHS

  // V solution
  real[int] solV(Vel.ndof);
  solV=Av^-1*bv;
  Vel v=[0,0];
  vx[]=solV(0:Vel.ndof-1);
  // ----------------------------------------------------------------------------------------------


  // Compute the gradients and hessian of the problem fields --------------------------------------
  // Gradient of p
  varf aGradP(dp, dq) = int2d(Th)(dp'*dq);
  varf lGradP(dp, dq) = int2d(Th)(Grad(px,py)'*dq);

  matrix AGradP = aGradP(dPol, dPol);  // LHS matrix
  real[int] bGradP = lGradP(0, dPol);  // RHS vector

  real[int] solGradP(dPol.ndof);
  solGradP=AGradP^-1*bGradP;
  dPol dp=[0,0,0,0];
  dpxx[]=solGradP(0:dPol.ndof-1);
 
  // Gradient of v
  varf aGradV(dv, du) = int2d(Th)(dv'*du);
  varf lGradV(dv, du) = int2d(Th)(Grad(vx,vy)'*du);

  matrix AGradV = aGradV(dVel, dVel);  // LHS matrix
  real[int] bGradV = lGradV(0, dVel);  // RHS vector

  real[int] solGradV(dVel.ndof);
  solGradV=AGradV^-1*bGradV;
  dVel dv=[0,0,0,0];
  dvxx[]=solGradV(0:dVel.ndof-1);

  // Hessian of px
  varf aHessPx(d2px,d2qx) = int2d(Th)(d2px'*d2qx);
  varf lHessPx(d2px,d2qx) = int2d(Th)(Hessian(px)'*d2qx);

  matrix AHessPx = aHessPx(dPol, dPol);  // LHS matrix
  real[int] bHessPx = lHessPx(0, dPol);  // RHS vector

  real[int] solHessPx(dPol.ndof);
  solHessPx=AHessPx^-1*bHessPx;
  dPol d2px=[0,0,0,0];
  dpxxx[]=solHessPx(0:dPol.ndof-1);

  // Compute the Hessian of py
  varf aHessPy(d2py,d2qy) = int2d(Th)(d2py'*d2qy);
  varf lHessPy(d2py,d2qy) = int2d(Th)(Hessian(py)'*d2qy);

  matrix AHessPy = aHessPy(dPol, dPol);  // LHS matrix
  real[int] bHessPy = lHessPy(0, dPol);  // RHS vector

  real[int] solHessPy(dPol.ndof);
  solHessPy=AHessPy^-1*bHessPy;
  dPol d2py=[0,0,0,0];
  dpyxx[]=solHessPy(0:dPol.ndof-1);
  // ----------------------------------------------------------------------------------------------


  // Compute the intial values of the global variables --------------------------------------------
  Time = iterTime*dt;                              // Time (adim)
  Areai = Th.measure;                    // Current area.
  Xcm = int2d(Th)(x)/Areai;              // Current Xcm.
  Ycm = int2d(Th)(y)/Areai;              // Current Ycm.
  avgDivV = int2d(Th)(dvxx+dvyy)/Areai;  // Average div of the velocity.

  // Center of mass velocity (backward).
  Vxcm = (Xcm-XcmPrev[0])/dt; 
  Vycm = (Ycm-YcmPrev[0])/dt; 

  // Current average velocity.
  Vxavg = int2d(Th)(vx)/Areai;
  Vyavg = int2d(Th)(vy)/Areai;

  // Center of mass acceleration (2nd order backward).
  Axcm = (Xcm-2.*XcmPrev[0]+XcmPrev[1])/pow(dt,2);
  Aycm = (Ycm-2.*YcmPrev[0]+YcmPrev[1])/pow(dt,2);

  // Average traction (adim).
  Txavg = int2d(Th)(c*px)/Areai;
  Tyavg = int2d(Th)(c*py)/Areai;

  // Center of mass of the divergence of the velocity.
  divXcm = int2d(Th)(x*(dvxx+dvyy))/Areai;
  divYcm = int2d(Th)(y*(dvxx+dvyy))/Areai;

  // Average divergence of the center of mass velocity.
  divXavgcm = Xcm*avgDivV;
  divYavgcm = Ycm*avgDivV;

  // Divergence terms of the center of mass velocity (Spreading integral).
  divTermsX = int2d(Th)((x-Xcm)*(dvxx+dvyy))/Areai;
  divTermsY = int2d(Th)((y-Ycm)*(dvxx+dvyy))/Areai;

  // Traction Dipole (adim & symmetric).
  MxxT = int2d(Th)((x-Xcm)*c*px);
  MxyT = int2d(Th)((x-Xcm)*c*py);
  MyyT = int2d(Th)((y-Ycm)*c*py);

  // Friction Dipole (adim & symmetric).
  MxxF = int2d(Th)((x-Xcm)*pow(b,2)*vx);
  MxyF = int2d(Th)((x-Xcm)*pow(b,2)*vy);
  MyyF = int2d(Th)((y-Ycm)*pow(b,2)*vy);

  // Traction Quadrupole (adim & symmetric).
  MxxxT = int2d(Th)(pow((x-Xcm),2)*c*px);
  MxxyT = int2d(Th)(pow((x-Xcm),2)*c*py);
  MxyxT = int2d(Th)((x-Xcm)*(y-Ycm)*c*px);
  MxyyT = int2d(Th)((x-Xcm)*(y-Ycm)*c*py);
  MyyxT = int2d(Th)(pow((y-Ycm),2)*c*px);
  MyyyT = int2d(Th)(pow((y-Ycm),2)*c*py);

  // Friction Quadrupole (adim & symmetric).
  MxxxF = int2d(Th)(pow((x-Xcm),2)*pow(b,2)*vx);
  MxxyF = int2d(Th)(pow((x-Xcm),2)*pow(b,2)*vy);
  MxyxF = int2d(Th)((x-Xcm)*(y-Ycm)*pow(b,2)*vx);
  MxyyF = int2d(Th)((x-Xcm)*(y-Ycm)*pow(b,2)*vy);
  MyyxF = int2d(Th)(pow((y-Ycm),2)*pow(b,2)*vx);
  MyyyF = int2d(Th)(pow((y-Ycm),2)*pow(b,2)*vy);

  // Moments of inertia with respect to the x & y axes at the CM
  Ix = int2d(Th)(pow(y-Ycm,2));
  Iy = int2d(Th)(pow(x-Xcm,2));
  // ---------------------------------------------------------------------------------------------


  // Export data ----------------------------------------------------------------------------------
  if(iterTime % dsave == 0 && bsave==1){

    string simulHomeDir = rootDir+"/"+simulName;
    string fileNameGlobalSol = "/global_sol.csv";
    string fileNameLocalSol = "/local_sol/sol_"+(1000000+iterTime)+".txt";
    string fileNameMsh = "/msh/mesh_"+(1000000+iterTime)+".msh";

    // Save {px, py, vx, vy, dpxdx, dpxdy, dpydx, dpydy, dvxdx, dvxdy, dvydx, dvydy, 
    // dpxdxx, dpxdxy, dpxdyx, dpxdyy, dpydxx, dpydxy, dpydyx, dpydyy} on each vertex:
    // Memory efficient method, but needs connectivity data to reconstruct the mesh
    {ofstream fileLocalSols (simulHomeDir+fileNameLocalSol);
      
      fileLocalSols.fixed;
      int NbVertices = Th.nv;
      fileLocalSols << "# LocalSolutions" << endl
                    << "# NumFields: " << 20 << "  NumberVertices: " << NbVertices << " a: " << a 
                    << " b: " << b << " c: " << c << endl
                    << "# px  py  vx  vy  dpxx  dpxy  dpyx  dpyy  dvxx  dvxy  dvyx  dvyy  dpxxx  "
                    << "dpxxy  dpxyx  dpxyy  dpyxx  dpyxy  dpyyx  dpyyy" << endl;
      for (int i = 0; i < NbVertices; i++){
        fileLocalSols << px(Th(i).x,Th(i).y) << "  " << py(Th(i).x,Th(i).y)     << "  "  // {px,py}
            << vx(Th(i).x,Th(i).y)     << "  " << vy(Th(i).x,Th(i).y)     << "  "  // {vx,vy}
            << dpxx(Th(i).x,Th(i).y)  << "  " << dpxy(Th(i).x,Th(i).y)  << "  "  // {dpxdx,dpxdy}
            << dpyx(Th(i).x,Th(i).y)  << "  " << dpyy(Th(i).x,Th(i).y)  << "  "  // {dpydx,dpydy}
            << dvxx(Th(i).x,Th(i).y)  << "  " << dvxy(Th(i).x,Th(i).y)  << "  "  // {dvxdx,dvxdy}
            << dvyx(Th(i).x,Th(i).y)  << "  " << dvyy(Th(i).x,Th(i).y)  << "  "  // {dvydx,dvydy}
            << dpxxx(Th(i).x,Th(i).y) << "  " << dpxxy(Th(i).x,Th(i).y) << "  "  // {dpxdxx,dpxdxy}
            << dpxyx(Th(i).x,Th(i).y) << "  " << dpyyy(Th(i).x,Th(i).y) << "  "  // {dpxdyx,dpxdyy}
            << dpyxx(Th(i).x,Th(i).y) << "  " << dpyxy(Th(i).x,Th(i).y) << "  "  // {dpydxx,dpydxy}
            << dpyyx(Th(i).x,Th(i).y) << "  " << dpyyy(Th(i).x,Th(i).y) << endl; // {dpydyx,dpydyy}
      }
    }

    // Save Global Data (variables integratet over the domain)
    {ofstream fileGlobalSol (simulHomeDir+fileNameGlobalSol, append);
      
      fileGlobalSol.fixed;
      fileGlobalSol << Time      << "," << Areai     << "," << Xcm       << "," << Ycm       << "," 
                    << avgDivV   << "," << Vxcm      << "," << Vycm      << "," << Vxavg     << ","
                    << Vyavg     << "," << Axcm      << "," << Aycm      << "," << Txavg     << ","
                    << Tyavg     << "," << divXcm    << "," << divYcm    << "," << divXavgcm << ","
                    << divYavgcm << "," << divTermsX << "," << divTermsY << "," << MxxT      << ","
                    << MxyT      << "," << MyyT      << "," << MxxF      << "," << MxyF      << ","
                    << MyyF      << "," << MxxxT     << "," << MxxyT     << "," << MxyxT     << ","
                    << MxyyT     << "," << MyyxT     << "," << MyyyT     << "," << MxxxF     << ","
                    << MxxyF     << "," << MxyxF     << "," << MxyyF     << "," << MyyxF     << ","
                    << MyyyF     << "," << Ix        << "," << Iy        << endl;
    }

    // save the last mesh
    savemesh(Th,simulHomeDir+fileNameMsh);
  }
  // ----------------------------------------------------------------------------------------------


  // Plot v ---------------------------------------------------------------------------------------
  if (debug) {
    Pola vABS = sqrt(vx(x,y)^2 + vy(x,y)^2);
    plot(vABS, 
      value = true, 
      fill = true, 
      nbiso = 64, 
      wait = false, 
      bb=[[-2,-2],[2,2]],
      cmm = "iTime="+(iterTime)+"; "
        +"t="+(dt*iterTime)+"; "
        +"Area/Area0="+(Areai/Area0)+"; "
        +"Rcm(t)-Rcm(0)=("+(Xcm-Xcm0)+","+(Ycm-Ycm0)+"); "
        +"Vcm(t)=("+Vxcm+","+Vycm+"); "
        +"c*Pcm(t)=("+Txavg+","+Tyavg+");"
    );
  }
  // ----------------------------------------------------------------------------------------------


  // Update previous global variables -------------------------------------------------------------

  XcmPrev[1] = XcmPrev[0]; XcmPrev[0] = Xcm; // Previous x_cms (-dt & -2*dt)
  YcmPrev[1] = YcmPrev[0]; YcmPrev[0] = Ycm; // Previous y_cms (-dt & -2*dt)
  // ----------------------------------------------------------------------------------------------


  // Remeshing ------------------------------------------------------------------------------------
  try{
    // Move mesh
    //real minT0 = checkmovemesh(Th, [x, y]); // to check for flipped triangles
    // real minT = checkmovemesh(Th, [x+dt*vx,y+dt*vy]);
    // cout << "Min triangle area before: "+minT0+" & after: "+minT<<endl;
    Th = movemesh(Th,[x+dt*vx,y+dt*vy]);
    lOut = extractborder(Th, labelBnd, bOut); // Extract border

    Th = closedRemesh(bOut,lOut,bOut.m-1,bLayerThickness,obd,ibd,labelBnd,.5, keepPoints,1);
  }
  catch(...) {
    cout << "ERROR: Simulation " << simulName << " stopped after " << iterTime
         << " iterations due to a remeshing error" << endl;
    err = 1;
    break;
  }
  // ----------------------------------------------------------------------------------------------

  // Stop simulations for big or small enough areas -----------------------------------------------
  if((Areai > rateMaxArea*Area0) || (Areai < rateMinArea*Area0)){
    cout << "WARNING: Simulation " << simulName << " stopped after " << iterTime 
         << " iterations due to too big/small area" << endl;
    err = 1;
    break;
  }
  // -----------------------------------------------------------------------------------------------
}
