// PACKAGES FOR ADVANCED REMESHING SCHEME
load "Curvature"
load "distance"
load "isoline"
load "gsl"

//include <iostream>;
verbosity=0;

string rootDir = /*"/home/joan/Documents/Simul_runs/sinusoidal_perturbations";*/
"/home/joan/Documents/Tesi_doct/Spontaneous_tissue_motility/Simul_runs/sinusoidal_perturbations/";
string pathDir;


// Physiscal Parameters
// Values from the estimation done by Ricard.
real Lc;										// Nematic length, sqrt(K/a)
real nu=1./4.;							// Adimensionalized Lc, set to 1/8 as 25/200 = 1/8 (Ricard's estimation)
real lambda = 707.; 		    // Hydodynamic length, sqrt(eta/xi)
real La = 200; 							// Active length, |zeta|/zi
real Rc;										// Critical radius Rc = (3Lc+La)/2
real R0;										// Initial radius, lengthscale of the problem
real tau = 2.e4;						// Timescale corresponding to the advance of a flat front, eta/(zi*Lc)

// Numerical Parameters
real ThickOutMesh =  nu;		// Thickness of the outer mesh
real obd = 60.;  						// Outer boundary mesh density
real ibd = 15.;	 						// Inner boundary mesh density
real dt = 0.01;	 					  // Time step
int Niter = 500; 					// Number of iterations
int nSimul = 1;

// Save parameters
bool bsave = 1;   					// To save or not
int dsave = 2;   					  // Save frame gap
string SimulName;
string[int] SimulNames = [/*"sin_perturb_mode=3_Amp=1E-4_comp",
                          "sin_perturb_mode=3_Amp=1E-3_comp",
                          "sin_perturb_mode=3_Amp=5E-2_comp",
                          "sin_perturb_mode=3_Amp=1E-2_comp",
                          "sin_perturb_mode=3_Amp=1E-1_comp",*/
                          "sin_perturb_mode=3_Amp=25E-2_comp"];

// Domain parameters
// real cut = pi/6.;							    // Angular length of the cutted portion of the circle
// real[int] AxisCut = [3.*pi/2.]; 	// Angles of the symmetry axis of each cut
// real fracRarc = 0.1;							// adimensionalized radius used to smooth the domain vertices
int nMode = 3;
real[int] perturbAmp = [/*1E-4,1E-3,5E-2,1E-2,1E-1,*/0.25];

for (int i=0; i<nSimul; i++){
  SimulName = SimulNames[i];

  // PARAMETER SETTING AT THE WET LIMIT
  // To start the simulations close to the wetting transition we impose that the domain's area is the
  // same to the one of a circle with critial radius Rc. The shape_factor gives the domain radius so
  // that its area is the same to the one of a unit circle.
  // real shapefactor = 1;//sqrt(2*pi/(2*pi - cut + sin(cut))); // Shape factor

  // Then, the initial radius, R0, would be R0 = shapefactor*Rc +- d, but Rc=Rc(Lc,La), so to
  // control Lc as a fraction of the radius, Lc=nu*R0, we need to solve R0 = shape_factor*Rc(R0) +- d,
  // which gives:
  // R0 = .5*shapefactor*La/(1-1.5*shapefactor*nu);

  // then add +- d to perturb the radius and ensure closeness to the wetting transition
  // R0 += -15.;

  // Finally, compute Lc and, in turn, Rc
  // Lc = nu*R0;
  // Rc = 0.5*(3*Lc+La);
  Rc = La/(2-3*nu); // from Lc = nu*Rc & Rc = (3*Lc+La)/2
  R0 = Rc; // dewetting
  Lc = nu*R0;

  // Problem Parameters
  real a = La/Lc; 	    			// Active and Nematic length ratio
  real b = pow(R0/lambda,2);	// R0 and hydrodynamic length ratio
  real c = R0/Lc; //1/nu; 		 		 		  // R0 and nematic length ratio

  cout << "Simul: " << SimulName << ", R0 = " << R0 << ", Rc = " << Rc
  << ", lambda = " << lambda << ", Lc = " << Lc
  << ", saving = " << bsave << endl;

  /*// Sinusoidal perturbations of the domain
  mesh Th,Thb;
   real Amp = perturbAmp[i];
   // real nMode = 2;
   real phase = -pi/2.;

   border Gamma(t=0,2*pi){x=(1+Amp*sin(nMode*t+phase))*cos(t);
                          y=(1+Amp*sin(nMode*t+phase))*sin(t); label=1;}
   Th=buildmesh(Gamma(obd*2*pi));

   // Transform a dense mesh into an adaptive one
   fespace Dini(Th, P1);	// Distance function to define the contour region of the mesh

   varf vong(B, d)= on(1,B=1);
   real[int] ong=vong(0,Dini);
   Dini B =1, d;
   B[] = ong ? 0 : B[];
   distance(Th,B,d[]);
   // Get the new inner boundaperturbry vertices (ISO is the contaur d==nu)
   real[int,int] ISO(3,1); int nc=isoline(Th,d,iso=ThickOutMesh,close=1,ISO,smoothing=ThickOutMesh/2.,ratio=1.e-0);
   real l2=ISO(2,ISO.m-1); // l2 is the perimeter of ISO
   border Inner(t=0,1){ P=Curve(ISO,t);label=0;}
   int nI = round(ibd*l2); 						// new number of elements (prescribed density ibd)
   // C. BUILD NEW MESH
   Th=buildmesh(Gamma(obd*2*pi)+Inner(nI),fixedborder=1);
   Th=change(Th,rmInternalEdges=true);
   Thb=emptymesh(Th);*/

  // Perturbations of the circular domain with 1 cut, smoth with 1/f = 0
  mesh Th,Thb;
    real Rarc = fracRarc;
    real t1 = asin((sin(cut/2.)-Rarc)/(1-Rarc));

  	real[int] OxPlus = [(1-Rarc)*cos(AxisCut[0]+t1)];
  	real[int] OyPlus = [(1-Rarc)*sin(AxisCut[0]+t1)];
  	real[int] OxMin = [(1-Rarc)*cos(AxisCut[0]-t1)];
  	real[int] OyMin = [(1-Rarc)*sin(AxisCut[0]-t1)];
  	real LenCut = sqrt((OxPlus[0]-OxMin[0])*(OxPlus[0]-OxMin[0]) + (OyPlus[0]-OyMin[0])*(OyPlus[0]-OyMin[0]));

    border GammaArchMin0(t=0,1){x=OxMin[0]+Rarc*cos(AxisCut[0]-t1*(1-t)); y=OyMin[0]+Rarc*sin(AxisCut[0]-t1*(1-t)); label=1;}
  	border GammaCut0(t=0,1){x=((OxMin[0]+Rarc*cos(AxisCut[0]))+(OxPlus[0]-OxMin[0])*t);
  													y=((OyMin[0]+Rarc*sin(AxisCut[0]))+(OyPlus[0]-OyMin[0])*t);label=1;}
  	border GammaArchPlus0(t=0,1){x=OxPlus[0]+Rarc*cos(AxisCut[0]+t1*t); y=OyPlus[0]+Rarc*sin(AxisCut[0]+t1*t); label=1;}
  	border GammaArch0(t=0,1){x=cos(AxisCut[0]+t1+2*(pi-t1)*t);
  													 y=sin(AxisCut[0]+t1+2*(pi-t1)*t);label=1;}


  	Th=buildmesh(GammaArchMin0(obd*Rarc*t1)
  							+GammaCut0(obd*LenCut)
  							+GammaArchPlus0(obd*Rarc*t1)
  							+GammaArch0(obd*2*(pi-t1))
  							);

    // Smooth the outer boundary pieces
    real[int,int] b1(3,1); real l1=extractborder(Th,1,b1); // l1 is the permiter of b1
    gslspline splineX(gslinterpakima, b1(2, :), b1(0, :)); 	// x(s) akima spline
    gslspline splineY(gslinterpakima, b1(2, :), b1(1, :)); 	// y(s) akima spline
    border Outer(t=0,l1){x=splineX(t);y=splineY(t);label=1;}
    int nO = round(obd*l1);

  	// Transform the dense mesh & into an adaptive one
  	fespace Dini(Th, P1);	// Distance function to define the contour region of the mesh

  	varf vong(B, d)= on(1,B=1);
  	real[int] ong=vong(0,Dini);
  	Dini B =1, d;
  	B[] = ong ? 0 : B[];
  	distance(Th,B,d[]);

  	// Get the new inner boundary vertices (ISO is the contour d==nu)
  	real[int,int] ISO(3,1); int nc=isoline(Th,d,iso=ThickOutMesh,close=1,ISO,smoothing=ThickOutMesh/2.,ratio=1.e-0);
    real l2=ISO(2,ISO.m-1); // l2 is the perimeter of ISO
  	border Inner(t=0,1){ P=Curve(ISO,t);label=2;}
  	int nI = round(ibd*l2); 						// new number of elements (prescribed density ibd)

  	// C. BUILD NEW MESH
  	Th=buildmesh(Outer(nO)+Inner(nI),fixedborder=1);
  	Th=change(Th,rmInternalEdges=1);
  	Thb=emptymesh(Th);

  /*// Rotating fan domain
  mesh Th,Thb;
    real maxWidth = 1.;
  	real Rsmall = fracRarc;
    real Rbig = maxWidth-Rsmall;

  	real AxisIni = 0.;

  	real[int] OxBig = [(maxWidth/2.-Rsmall)*cos(AxisIni+pi/2.),(maxWidth/2.-Rsmall)*cos(AxisIni+3*pi/2.)];
  	real[int] OyBig = [(maxWidth/2.-Rsmall)*sin(AxisIni+pi/2.),(maxWidth/2.-Rsmall)*sin(AxisIni+3*pi/2.)];

    real[int] OxSmall = [OxBig[0]+(Rbig-Rsmall)*cos(AxisIni+pi),OxBig[1]+(Rbig-Rsmall)*cos(AxisIni+2*pi)];
  	real[int] OySmall = [OyBig[0]+(Rbig-Rsmall)*sin(AxisIni+pi),OyBig[1]+(Rbig-Rsmall)*sin(AxisIni+2*pi)];

    border GammaSide0(t=0,1){x=(maxWidth/2.)*cos(AxisIni+pi/2.)+(OxSmall[0]-OxBig[0])*t; y=(maxWidth/2.)*sin(AxisIni+pi/2.)+(OySmall[0]-OyBig[0])*t; label=1;}
    border GammaSmallArch0(t=0,1){x=OxSmall[0]+Rsmall*cos(AxisIni+(pi/2.)*(t+1)); y=OySmall[0]+Rsmall*sin(AxisIni+(pi/2.)*(t+1)); label=1;}
    border GammaBigArch0(t=0,1){x=OxBig[0]+Rbig*cos(AxisIni+(pi/2.)*(t+2)); y=OyBig[0]+Rbig*sin(AxisIni+(pi/2.)*(t+2)); label=1;}

    border GammaSide1(t=0,1){x=(maxWidth/2.)*cos(AxisIni+3*pi/2.)+(OxSmall[1]-OxBig[1])*t; y=(maxWidth/2.)*sin(AxisIni+3*pi/2.)+(OySmall[1]-OyBig[1])*t; label=1;}
    border GammaSmallArch1(t=0,1){x=OxSmall[1]+Rsmall*cos(AxisIni+(pi/2.)*(t+3)); y=OySmall[1]+Rsmall*sin(AxisIni+(pi/2.)*(t+3)); label=1;}
    border GammaBigArch1(t=0,1){x=OxBig[1]+Rbig*cos(AxisIni+(pi/2.)*(t+4)); y=OyBig[1]+Rbig*sin(AxisIni+(pi/2.)*(t+4)); label=1;}

  	Th=buildmesh(GammaSide0(obd*(Rbig-Rsmall))
                +GammaSmallArch0(obd*Rsmall*pi/2.)
                +GammaBigArch0(obd*Rbig*pi/2.)
                +GammaSide1(obd*(Rbig-Rsmall))
                +GammaSmallArch1(obd*Rsmall*pi/2.)
                +GammaBigArch1(obd*Rbig*pi/2.)
  							);

    // Smooth the outer boundary pieces
    real[int,int] b1(3,1); real l1=extractborder(Th,1,b1); // l1 is the permiter of b1
    gslspline splineX(gslinterpakima, b1(2, :), b1(0, :)); 	// x(s) akima spline
    gslspline splineY(gslinterpakima, b1(2, :), b1(1, :)); 	// y(s) akima spline
    border Outer(t=0,l1){x=splineX(t);y=splineY(t);label=1;}
    int nO = round(obd*l1);

  	// Transform a dense mesh into an adaptive one
  	fespace Dini(Th, P1);	// Distance function to define the contour region of the mesh

  	varf vong(B, d)= on(1,B=1);
  	real[int] ong=vong(0,Dini);
  	Dini B =1, d;
  	B[] = ong ? 0 : B[];
  	distance(Th,B,d[]);
  	// Get the new inner boundary vertices (ISO is the contaur d==nu)
  	real[int,int] ISO(3,1); int nc=isoline(Th,d,iso=ThickOutMesh,close=1,ISO,smoothing=ThickOutMesh/2.,ratio=1.e-0);
  	real l2=ISO(2,ISO.m-1); // l2 is the perimeter of ISO
  	border Inner(t=0,1){ P=Curve(ISO,t);label=2;}
  	int nI = round(ibd*l2); 						// new number of elements (prescribed density ibd)
  	// C. BUILD NEW MESH
  	Th=buildmesh(Outer(nO)+Inner(nI),fixedborder=1);
  	Th=change(Th,rmInternalEdges=1);
  	Thb=emptymesh(Th);*/

  /*// Ellipse
  mesh Th,Thb;
   real foci = 1;    // Foci distance, focus are located at (x,y)=(+-c,0)

   border Gamma(t=0,2*pi){x=sqrt(1+pow(foci,2))*cos(t);
                          y=sin(t); label=1;}
   Th=buildmesh(Gamma(obd*2*pi));

   // Transform a dense mesh into an adaptive one
   fespace Dini(Th, P1);	// Distance function to define the contour region of the mesh

   varf vong(B, d)= on(1,B=1);
   real[int] ong=vong(0,Dini);
   Dini B =1, d;
   B[] = ong ? 0 : B[];
   distance(Th,B,d[]);
   // Get the new inner boundary vertices (ISO is the contaur d==nu)
   real[int,int] ISO(3,1); int nc=isoline(Th,d,iso=ThickOutMesh,close=1,ISO,smoothing=ThickOutMesh/2.,ratio=1.e-0);
   real l2=ISO(2,ISO.m-1); // l2 is the perimeter of ISO
   border Inner(t=0,1){ P=Curve(ISO,t);label=0;}
   int nI = round(ibd*l2); 						// new number of elements (prescribed density ibd)
   // C. BUILD NEW MESH
   Th=buildmesh(Gamma(obd*2*pi)+Inner(nI),fixedborder=1);
   Th=change(Th,rmInternalEdges=true);
   Thb=emptymesh(Th);*/


  real Area0=Th.measure; // Inital Area of the Fluid Domain
  real Area=Area0;
  real Xcm0=int2d(Th)(x)/Area; //Initial x_cm
  real Ycm0=int2d(Th)(y)/Area; //Initial y_cm
  real XcmP=Xcm0;
  real YcmP=Ycm0;
  real Xcm=Xcm0;
  real Ycm=Ycm0;

  if (verbosity) {
  	plot(Th,value = true, fill = false,boundary=true, nbiso=64, wait=true, cmm = "adaptive mesh;  A0="+Area0+",  (xcm0,yxm0)=("+Xcm0+","+Ycm0+")");
  }

  //FEM spaces
  fespace Pol(Th, [P2, P2]);					// For polarity vector
  fespace Pola(Th, P2 );							// For |p| (not essential, just visualization)
  fespace Vel(Th, [P1b, P1b]);				// For velocity vector
  fespace Dh(Th, P1);								  // For distance function (remeshing scheme) and data exports
  fespace Vor(Th,P1b);								// To compute the vorticity & divergence
  fespace Nh(Th,[P1,P1]);						  // For the corrected normal vector at the boundary

  //Macros
  macro Theta [Theta1, Theta2]											// (Ycm-y, x-Xcm); normal to r-Rcm
  macro pD [pD1, pD2]																// P2 extension for Dirichlet data
  macro p [p1, p2] 																	// Polarity vector field
  macro q [q1, q2] 																	// Polarity test functions
  macro V [V1, V2] 																	// Velocity field
  macro U [U1, U2] 																	// Velocity test functions
  macro NDerP[NDerP1,NDerP2]												// Normal derivative of p at the boundary
  macro grad(u) [dx(u),dy(u)]												// Gradient of a sclar
  macro Grad(u1,u2) [dx(u1),dy(u1),dx(u2),dy(u2)] 	// Gradient of a vector
  macro GradT(u1,u2) [dx(u1),dx(u2),dy(u1),dy(u2)] 	// Grad vector transpose
  macro pp(p1,p2) [p1*p1,p1*p2,p2*p1,p2*p2] 				// Active stress tensor
  // Directional Derivative of vector u following vector v
  // macro Dv(u1,u2,v1,v2) [dx(u1)*v1+dy(u1)*v2,dx(u2)*v1+dy(u2)*v2]

  // Correction of the normal vectors at the boundary
  int NbBoundaryElements = Th.nbe;
  int[int] bcon(NbBoundaryElements);
  real[int] xx(NbBoundaryElements+1),yy(NbBoundaryElements+1);
  for (int k = 0; k < NbBoundaryElements; k++){
           bcon[k] = Th.be(k)[0];
  	 xx[k]=Th(Th.be(k)[0]).x; yy[k]=Th(Th.be(k)[0]).y;
  }
  xx[NbBoundaryElements]=xx[0]; yy[NbBoundaryElements]=yy[0];

  Nh [nx,ny]; // here the Dof of nx,ny are scramble .
  nx[]=0;ny[]=0;

  real[int] nprev(2), npost(2), nmean(2);
  real lenprev, lenpost;
  nprev = [(yy[0]-yy[NbBoundaryElements-1]),-(xx[0]-xx[NbBoundaryElements-1])];
  lenprev = sqrt(pow(nprev[0],2)+pow(nprev[1],2));

  for (int k = 0; k < NbBoundaryElements; k++){
    npost = [(yy[k+1]-yy[k]),-(xx[k+1]-xx[k])];
    lenpost = sqrt(pow(npost[0],2)+pow(npost[1],2));

    nmean = nprev/(1+lenprev/lenpost) + npost/(1+lenpost/lenprev);
    nmean /= sqrt(pow(nmean[0],2)+pow(nmean[1],2));

  	nx[](2*bcon(k))= nmean[0]; ny[](2*bcon(k)+1) = nmean[1];
  	nprev = npost; lenprev = lenpost;
  }

  // P2 extension of polarity Dirichlet data
  varf bndDirichlet(pD, q) = on(1, pD1 = nx) + on(1, pD2 = ny);// + on(2, p1 = N.x) + on(2, p2 = N.y);
  Pol pD=[0,0];
  pD1[] = bndDirichlet(0, Pol, tgv = 1.0);

  // fespace Nha(Th,[P0edge,P0edge]);
  // varf vn1([nxa,nya],[mx,my]) = on(1, nxa=N.x,nya=N.y);
  // // remember the BC is take the value of DF on bord * tgv
  // Nha [nxa,nya]; // here the Dof of nx,ny are scramble .
  // nxa[]=vn1(0.,Nh);// set [nx,ny]  DoF.

  if (verbosity) {
  	plot(pD1, value = true, fill = true, nbiso=64, wait=true, cmm = "pDx");
  	plot(pD2, value = true, fill = true, nbiso=64, wait=true, cmm = "pDy");
  	//plot(Th,[nx,ny], value = true, fill = false, nbiso=64, wait=true, cmm = "[nx,ny]");
  	//plot(Th,[nxa,nya], value = true, fill = false, nbiso=64, wait=true, cmm = "[nxa,nya]");
  }
  // Bilinear and linear variational forms P (Modified Homogeneous Drirchlet problem for p-pD)
  varf ap(p, q) = int2d(Th)(  grad(p1)'*grad(q1) + grad(p2)'*grad(q2) )  + int2d(Th)(c*c*(p'*q)) + on(1, p1 = 0.0) + on(1, p2=0.0);//+ on(2, p1=0.0) + on(2, p2=0.0);
  varf lp(p, q) = -int2d(Th)( grad(pD1)'*grad(q1) + grad(pD2)'*grad(q2) ) - int2d(Th)(c*c*(pD'*q))  + on(1, p1 = 0.0) + on(1, p2=0.0);//+ on(2, p1=0.0) + on(2, p2=0.0);

  // Assembly P
  matrix Ap = ap(Pol, Pol, tgv = -2); // LHS matrix
  real[int] bp = lp(0, Pol); // RHS

  // P solution with vanishing Dirichlet data
  real[int] solP(Pol.ndof);
  //set(Ap,solver=sparsesolver);
  solP=Ap^-1*bp;
  Pol p=[0,0];
  p1[]=solP(0:Pol.ndof-1);

  if (verbosity) {
  	plot(Th,p1, value = true, fill = true, nbiso=64, wait=true, cmm = "dpx = px-pDx");
  	plot(Th,p2, value = true, fill = true, nbiso=64, wait=true, cmm = "dpy = py-pDy");
  }

  // P solution
  p = p + pD;

  // Compute the divergence, curl and normal derivative of the polarity for the posterior analysis
  // Divergence
  varf aDivP(DivP, g) = int2d(Th)(DivP*g);
  varf lDivP(DivP, g) = int2d(Th)((dx(p1)+dy(p2))*g);

  matrix ADivP = aDivP(Vor, Vor);		// LHS matrix
  real[int] bDivP = lDivP(0, Vor);	// RHS vector

  real[int] solDivP(Vor.ndof);
  solDivP=ADivP^-1*bDivP;
  Vor DivP=solDivP(0:Vor.ndof-1);

  // Curl (Vorticity)
  varf aCurlP(CurlP, g) = int2d(Th)(CurlP*g);
  varf lCurlP(CurlP, g) = int2d(Th)((dx(p2)-dy(p1))*g);

  matrix ACurlP = aCurlP(Vor, Vor);		// LHS matrix
  real[int] bCurlP = lCurlP(0, Vor);	// RHS vector

  real[int] solCurlP(Vor.ndof);
  solCurlP=ACurlP^-1*bCurlP;
  Vor CurlP=solCurlP(0:Vor.ndof-1);

  // Normal Derivative of p (at the boundary)
  // varf aNDerP(NDerP,q) = int2d(Th)(NDerP'*q);
  // varf lNDerP(NDerP,q) = int2d(Th)(Dv(p1,p2,pD1,pD2)'*q);
  //
  // matrix ANDerP = aNDerP(Nh,Nh);		// LHS matrix
  // real[int] bNDerP = lNDerP(0,Nh);	// RHS vectors
  //
  // real[int] solNDerP(Nh.ndof);
  // solNDerP=ANDerP^-1*bNDerP;
  // Nh NDerP = [0,0];
  // NDerP1[]=solNDerP(0:Nh.ndof-1);

  if (verbosity) {
  	plot(Th,p1, value = true, fill = true, nbiso = 64, wait = true, cmm = "px");
  	plot(Th,p2, value = true, fill = true, nbiso = 64, wait = true, cmm = "py");
  	plot(Th,p, value = true, fill = true, nbiso = 64, wait = true, cmm = "(px,py)");
  	// Abs(P)
  	Pola pABS = sqrt(p1(x,y)^2 + p2(x,y)^2);
  	plot(Th,pABS, value = true, fill = true, nbiso = 64, wait = true, cmm = "|p|");
  	plot(Th,DivP, value = true, fill = true, nbiso = 64, wait = true, cmm = "Div(P)");
  	plot(Th,CurlP, value = true, fill = true, nbiso = 64, wait = true, cmm = "Curl(P)");
  	// plot([NDerP1,NDerP2], value = true, fill = true, nbiso = 64, wait = true, cmm = "Dn(P)");
  }

  // Bilinear and linear variational forms V
  varf av(V, U) = int2d(Th)( ((Grad(V1,V2)+GradT(V1,V2))'*Grad(U1,U2)) )  + int2d(Th)( b*(V'*U) ); // -viscosity -friction
  varf lv(V, U) = int2d(Th)( -a*(pp(p1,p2)'*Grad(U1,U2)) ) + int2d(Th)( c*(p'*U) ); //contractility +active traction

  // Assembly V
  matrix Av = av(Vel, Vel);
  real[int] bv = lv(0, Vel);

  // V solution
  real[int] solV(Vel.ndof);
  //set(Av,solver=sparsesolver);
  solV=Av^-1*bv;
  Vel V=[0,0];
  V1[]=solV(0:Vel.ndof-1);

  // Compute divergence and curl of the velocity for the posterior analysis
  // Divergence
  varf aDivV(DivV, g) = int2d(Th)(DivV*g);
  varf lDivV(DivV, g) = int2d(Th)((dx(V1)+dy(V2))*g);

  matrix ADivV = aDivV(Vor, Vor);		// LHS matrix
  real[int] bDivV = lDivV(0, Vor);	// RHS vector

  real[int] solDivV(Vor.ndof);
  solDivV=ADivV^-1*bDivV;
  Vor DivV=solDivV(0:Vor.ndof-1);

  // Curl (Vorticity)
  varf aCurlV(CurlV, g) = int2d(Th)(CurlV*g);
  varf lCurlV(CurlV, g) = int2d(Th)((dx(V2)-dy(V1))*g);

  matrix ACurlV = aCurlV(Vor, Vor);		// LHS matrix
  real[int] bCurlV = lCurlV(0, Vor);	// RHS vector

  real[int] solCurlV(Vor.ndof);
  solCurlV=ACurlV^-1*bCurlV;
  Vor CurlV=solCurlV(0:Vor.ndof-1);

  if (verbosity) {
  	plot(Th,V1, value = true, fill = true, nbiso = 64, wait = true, cmm = "vx");
  	plot(Th,V2, value = true, fill = true, nbiso = 64, wait = true, cmm = "vy");
  	plot(Th,V, value = true, fill = true, nbiso = 64, wait = true, cmm = "(vx,vy)");
  	// Abs(P)
  	Pola vABS = sqrt(V1(x,y)^2 + V2(x,y)^2);
  	plot(Th,vABS, value = true, fill = true, nbiso = 64, wait = true, cmm = "|V|");
  	plot(Th,DivV, value = true, fill = true, nbiso = 64, wait = true, cmm = "Div(V)");
  	plot(Th,CurlV, value = true, fill = true, nbiso = 64, wait = true, cmm = "Curl(V)");
  }

  if(bsave){
  	// the results folder
  	pathDir = rootDir+"/"+SimulName;
  	exec("mkdir "+pathDir);
  	exec("mkdir "+pathDir+"/LocalData"); // Make and save the local data in a separeted folder
  	exec("mkdir "+pathDir+"/ConnectivityData"); // Make and save the connectivity data in a separeted folder
  	{ ofstream fileParam (pathDir+"/Params.csv");
  		 fileParam.fixed;
       fileParam << "L_c,L_a,lambda,R0,mode,Amp,tau,dt,dsave" << endl ;
  		 fileParam << Lc<<","<<La<<","<<lambda<<","<<R0<<","<<nMode<<","<<Amp*R0<<","<<tau<<","<<dt<<","<<dsave<< endl ;
  		 /*fileParam << "L_c,L_a,lambda,R0,cut,tau,dt,dsave" << endl ;
  		 fileParam << Lc<<","<<La<<","<<lambda<<","<<R0<<","<<cut<<","<<tau<<","<<dt<<","<<dsave<< endl ;*/
  	}
  	{ ofstream fileGlobalData (pathDir+"/TimeSeries.csv");
  			fileGlobalData	<< "Time,Area,Xcm,Ycm,Vxcm,Vycm,Pxcm,Pycm,DivTermsX,DivTermsY"<<endl;
  	}

  }

  // Iterate time
  for (int iter=0 ; iter<Niter ; iter++) {

  	if (iter % 100 == 0 && iter > 0) {
  		cout << iter << " out of " << Niter << " iterations completed" << endl;
  	}

  	// Correction of the normal vectors at the boundary
  	int NbBoundaryElements = Th.nbe;
  	int[int] bcon(NbBoundaryElements);
  	real[int] xx(NbBoundaryElements+1),yy(NbBoundaryElements+1);
  	for (int k = 0; k < NbBoundaryElements; k++){
  	         bcon[k] = Th.be(k)[0];
  		 xx[k]=Th(Th.be(k)[0]).x; yy[k]=Th(Th.be(k)[0]).y;
  	}
  	xx[NbBoundaryElements]=xx[0]; yy[NbBoundaryElements]=yy[0];

  	Nh [nx,ny]; // here the Dof of nx,ny are scramble .
  	nx[]=0;ny[]=0;
  	int i=0;
  	for (int k = 0; k < NbBoundaryElements; k++){
  	  real[int] nprev(2), npost(2), nmean(2);
  	  real lenprev, lenpost;
  	  int kprev = k-1;

  	  if (k==0) {kprev=NbBoundaryElements-1;}

  	  nprev = [(yy[k]-yy[kprev]),-(xx[k]-xx[kprev])];
  	  lenprev = sqrt(pow(nprev[0],2)+pow(nprev[1],2));
  	  npost = [(yy[k+1]-yy[k]),-(xx[k+1]-xx[k])];
  	  lenpost = sqrt(pow(npost[0],2)+pow(npost[1],2));

  	  nmean = nprev/(1+lenprev/lenpost) + npost/(1+lenpost/lenprev);
  	  nmean /= sqrt(pow(nmean[0],2)+pow(nmean[1],2));

  		i=bcon(k);
  		nx[](2*i)= nmean[0]; ny[](2*i+1) = nmean[1];
  	}

  	// P2 extension of polarity Dirichlet data
  	varf bndDirichlet(pD, q) = on(1, pD1 = nx) + on(1, pD2 = ny);// + on(2, p1 = N.x) + on(2, p2 = N.y);
  	Pol pD=[0,0];
  	pD1[] = bndDirichlet(0, Pol, tgv = 1.0);

  	// Assembly P
  	varf lp(p, q) = -int2d(Th)( grad(pD1)'*grad(q1) + grad(pD2)'*grad(q2) ) - int2d(Th)(c*c*(pD'*q))  + on(1, p1 = 0.0) + on(1, p2=0.0);
  	matrix Ap = ap(Pol, Pol, tgv = -2); 	// LHS matrix
  	real[int] bp = lp(0, Pol); 			// RHS

  	// P solution with vanishing Dirichlet data
  	real[int] sol(Pol.ndof);
  	//set(Ap,solver=sparsesolvenetr);
  	sol=Ap^-1*bp;
  	Pol p=[0,0];
  	p1[]=sol(0:Pol.ndof-1);

  	// P solution
  	p = p + pD;

  	// Compute the divergence and curl of the velocity for the posterior analysis
  	// Divergence
  	varf aDivP(DivP, g) = int2d(Th)(DivP*g);
  	varf lDivP(DivP, g) = int2d(Th)((dx(p1)+dy(p2))*g);

  	matrix ADivP = aDivP(Vor, Vor);		// LHS matrix
  	real[int] bDivP = lDivP(0, Vor);	// RHS vector

  	real[int] solDivP(Vor.ndof);
  	solDivP=ADivP^-1*bDivP;
  	Vor DivP=solDivP(0:Vor.ndof-1);

  	// Curl (Vorticity)
  	varf aCurlP(CurlP, g) = int2d(Th)(CurlP*g);
  	varf lCurlP(CurlP, g) = int2d(Th)((dx(p2)-dy(p1))*g);

  	matrix ACurlP = aCurlP(Vor, Vor);		// LHS matrix
  	real[int] bCurlP = lCurlP(0, Vor);	// RHS vector

  	real[int] solCurlP(Vor.ndof);
  	solCurlP=ACurlP^-1*bCurlP;
  	Vor CurlVP=solCurlP(0:Vor.ndof-1);

    // Normal Derivative of p (at the boundary)
    // varf aNDerP(NDerP,q) = int2d(Th)(NDerP'*q);
    // varf lNDerP(NDerP,q) = int2d(Th)(Dv(p1,p2,pD1,pD2)'*q);
    //
    // matrix ANDerP = aNDerP(Nh,Nh);		// LHS matrix
    // real[int] bNDerP = lNDerP(0,Nh);	// RHS vectors
    //
    // real[int] solNDerP(Nh.ndof);
    // solNDerP=ANDerP^-1*bNDerP;
    // Nh NDerP = [0,0];
    // NDerP1[]=solNDerP(0:Nh.ndof-1);

  	// Assembly V
  	varf lv(V, U) = int2d(Th)( -a*(pp(p1,p2)'*Grad(U1,U2)) ) + int2d(Th)( c*(p'*U) );
  	matrix Av = av(Vel, Vel);  			// LHS matrix
  	real[int] bv = lv(0, Vel);			// RHS

  	// V solution
  	real[int] solV(Vel.ndof);
  	//set(Av,solver=sparsesolver);
  	solV=Av^-1*bv;
  	Vel V=[0,0];
  	V1[]=solV(0:Vel.ndof-1);

  	// Compute the divergence and curl of the velocity for the posterior analysis
  	// Divergence
  	varf aDivV(DivV, g) = int2d(Th)(DivV*g);
  	varf lDivV(DivV, g) = int2d(Th)((dx(V1)+dy(V2))*g);

  	matrix ADivV = aDivV(Vor, Vor);		// LHS matrix
  	real[int] bDivV = lDivV(0, Vor);	// RHS vector

  	real[int] solDivV(Vor.ndof);
  	solDivV=ADivV^-1*bDivV;
  	Vor DivVV=solDivV(0:Vor.ndof-1);

  	// Curl (Vorticity)
  	varf aCurlV(CurlV, g) = int2d(Th)(CurlV*g);
  	varf lCurlV(CurlV, g) = int2d(Th)((dx(V2)-dy(V1))*g);

  	matrix ACurlV = aCurlV(Vor, Vor);		// LHS matrix
  	real[int] bCurlV = lCurlV(0, Vor);	// RHS vector

  	real[int] solCurlV(Vor.ndof);
  	solCurlV=ACurlV^-1*bCurlV;
  	Vor CurlV=solCurlV(0:Vor.ndof-1);

  	real Area = Th.measure;					// Current Area
  	real Xcm = int2d(Th)(x)/Area;		// Current Xcm
  	real Ycm = int2d(Th)(y)/Area;		// Current Ycm
  	real Pxcm = int2d(Th)(p1)/Area;	// Current P_x cm
  	real Pycm = int2d(Th)(p2)/Area;	// Current P_y cm
  	real Vxcm = (Xcm-XcmP)/dt;			// Current V_x cm
  	real Vycm = (Ycm-YcmP)/dt;			// Current V_y cm
  	real DivTermsX = (int2d(Th)(x*DivV)-int2d(Th)(DivV)*Xcm)/Area;	// Current value of the Div terms of V_x cm
  	real DivTermsY = (int2d(Th)(y*DivV)-int2d(Th)(DivV)*Ycm)/Area;	// Current value of the Div terms of V_y cm

  	// Plot V
  	//if (verbosity) { // Show it always, regardless of the verbosity
  	Pola vABS = sqrt(V1(x,y)^2 + V2(x,y)^2);
  		plot(/*Th,[NDerP1,NDerP2],/*CurlV*/vABS, value = true, fill = true, nbiso = 64, wait = false, bb=[[-2,-2],[2,2]],
  				cmm = "t="+(dt*iter)+";  A/A0="+(Area/Area0)+", (xcm,yxm)-(xcm0,yxm0)=("+(Xcm-Xcm0)+","+(Ycm-Ycm0)
  											+"), (vx,vy)=("+Vxcm+","+Vycm+")"
  											+"), A^-1(c/b)int p=("+(c/b)*Pxcm+","+(c/b)*Pycm+")");
  	//}

  	// Export data
  	if(iter % dsave == 0 && bsave==1){
  		savemesh(Th,pathDir+"/LastMesh.msh"); 					// To load and restart the simualtion from the last configuration

  		// Save {x, y, p1, p2, V1, V2, DivV, CurlV, DivP, CurlP} on each vertex:
  		// Memory efficient method, but needs connectivity data to reconstruct the mesh
  		{	ofstream fileLocalData (pathDir+"/LocalData/Rend"+(1000000+iter)+".txt");
  			fileLocalData.fixed;
  			int NbVertices = Th.nv;
  			fileLocalData << "# Positional Data" << endl
  										<< "# NumFields: " << 10 << "\tNumberVertices: " << NbVertices
  										<< "\titer: " << iter << "\ttime: " << dt*iter << endl
  										<< "# x\ty\tpx\tpy\tvx\tvy\tdiv(v)\tcurl(v)\tdiv(p)\tcurl(p)" << endl;
  			for (int i = 0; i < NbVertices; i++){
  				fileLocalData << Th(i).x                 <<" "<< Th(i).y                 <<" "
  											<< p1(Th(i).x,Th(i).y)     <<" "<< p2(Th(i).x,Th(i).y)     <<" "
  											<< V1(Th(i).x,Th(i).y)     <<" "<< V2(Th(i).x,Th(i).y)     <<" "
  											/*<< NDerP1(Th(i).x,Th(i).y) <<" "<< NDerP2(Th(i).x,Th(i).y) <<" "*/
  											<< DivV(Th(i).x,Th(i).y)   <<" "<< CurlV(Th(i).x,Th(i).y)  <<" "
  											<< DivP(Th(i).x,Th(i).y)   <<" "<< CurlP(Th(i).x,Th(i).y)  <<endl ;//
  			}

  			ofstream fileConnData (pathDir+"/ConnectivityData/ConnRend"+(1000000+iter)+".txt");
  			fileConnData.fixed;
  			int NbTriangles = Th.nt;
  			fileConnData << "# Mesh Connectivity" << endl
  									 << "# NumberTriangles: " << NbTriangles<< "\titer: " << iter << "\ttime: " << dt*iter << endl;
  	    for (int i = 0; i < NbTriangles; i++){
  	      fileConnData << int(Th[i][0])+1 <<" "<< int(Th[i][1])+1 <<" "<< int(Th[i][2])+1 << endl;
  			}
  		}

  		{ ofstream fileGlobalData (pathDir+"/TimeSeries.csv", append);
  				fileGlobalData	<< dt*iter   <<","<< Area      <<","<< Xcm  <<","<< Ycm  <<","
  											 	<< Vxcm      <<","<< Vycm      <<","<< Pxcm <<","<< Pycm <<","
  												<< DivTermsX <<","<< DivTermsY <<"\n";
  		}
  	}

  	// Move mesh
  	// real minT0 = checkmovemesh(Th, [x, y]); // to check for flipped triangles
  	// real minT = checkmovemesh(Th, [x+dt*V1,y+dt*V2]);
  	// cout << "Min triangle area before: "+minT0+" & after: "+minT<<endl;
  	Th = movemesh(Th,[x+dt*V1,y+dt*V2]);

  	// REMESHING - OPTIONAL (choose between A.1(a)-(c) for outer and between B.3(a)-(c) for inner)
  	// A.1. GET OUTER BOUNDARY VERTICES (b1)
  	real[int,int] b1(3,1); real l1=extractborder(Th,1,b1); // l1 is the permiter of b1
  	// A.2(a). LINEAR INTERPOLATION OF b1 (simple and robust, but bad for preserving shape integrity)
  	/* border Outer(t=0,1){ P=Curve(b1,t);label=1;}
  	int nO = round(obd*l1);  */						// new number of elements (prescribed density obd)
  	// A.2(b). VERTEX PRESERVING INTERPOLATION OF b1 (no remesh of outer boundary, probably best)
  	/*border Outer(t=0,1){ P=Curve(b1,b1(2,round(t*(b1.m-1)))/l1);label=1;}
  	int nO = b1.m-1; 				*/				// keep number of elements
  	// A.2(c). SPLINE INTERPOLATION OF b1 (for remeshing outer boundary smoothly)
  	gslspline splineX(gslinterpakima, b1(2, :), b1(0, :)); 	// x(s) akima spline
  	gslspline splineY(gslinterpakima, b1(2, :), b1(1, :)); 	// y(s) akima spline
  	border Outer(t=0,l1){x=splineX(t);y=splineY(t);label=1;}
  	int nO = round(obd*l1);  						// new number of elements (prescribed density obd)
  	// B.1. DISTANCE FUNCTION (d is the minimal distance to the boundary)
  	varf vong(B, d)= on(1,B=1);
  	real[int] ong=vong(0,Dh);
  	Dh B =1, d;
  	B[] = ong ? 0 : B[];
  	distance(Th,B,d[]);
  	// B.2. GET NEW INNER BOUNDARY VERTICES (ISO is the contour d==Lc)
  	real[int,int] ISO(3,1); int nc=isoline(Th,d,iso=ThickOutMesh,close=1,ISO,smoothing=ThickOutMesh/2.,ratio=1.e-0);
  	real l2=ISO(2,ISO.m-1); // l2 is the perimeter of ISO
  	// B.3(a). LINEAR INTERPOLATION OF ISO (simple and robust)
  	border Inner(t=0,1){ P=Curve(ISO,t);label=0;}
  	int nI = round(ibd*l2); 						// new number of elements (prescribed density ibd)
  	// B.3(b). VERTEX PRESERVING INTERPOLATION OF ISO (not ideal for this purpose, as we wish to impose uniform internal density)
  	/* border Inner(t=0,1){ P=Curve(ISO,ISO(2,round(t*(ISO.m-1)))/l2);label=2;}
  	int nI = ISO.m-1;  */ 							// keep number of elements
  	// B.3(c). SPLINE INTERPOLATION OF ISO (for remeshing inner boundary smoothly, probably overkill for this purpose)
  	/* gslspline splineXISO(gslinterpakima, ISO(2, :), ISO(0, :)); 	// x(s) akima spline
  	gslspline splineYISO(gslinterpakima, ISO(2, :), ISO(1, :)); 	// y(s) akima spline
  	border Inner(t=0,l2){x=splineXISO(t);y=splineYISO(t);label=2;}
  	int nI = round(ibd*l2);  */						// new number of elements (prescribed density ibd)
  	// C. BUILD NEW MESH
  	Th=buildmesh(Outer(nO)+Inner(nI),fixedborder=1);
  	Th=change(Th,rmInternalEdges=true);

  	XcmP=Xcm; // PREVIOUS Xcm
  	YcmP=Ycm; // PREVIOUS Ycm

    if(Area > 2*Area0){
      break;
    }
  }
}
