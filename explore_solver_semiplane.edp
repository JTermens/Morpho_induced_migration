// PACKAGES FOR ADVANCED REMESHING SCHEME
load "Curvature"
load "distance"
load "isoline"
load "gsl"

// Manage command-line arguments
include "getARGV.idp"

// include <iostream>; // If needed

int iRun = getARGV("-i", 1);
bool debug = getARGV("-d", 1);
bool err = 0;

//include <iostream>;
include "parameters_sets/params_exploration_semiplane_test.edp";
include "lib/meshes.edp"; // load the mesh generation & remeshing functions

string simulHomeDir = rootDir+"/"+simulName;
string fileNameParams = "/params.csv";
string fileNameParamsMhs = "/params_msh.csv";
string fileNameGlobalSols = "/global_sols.csv";

// Lengths of each parameter list
int nAmp = AmpList.n;
int nLc = LcList.n;
int nZeta = ZetaList.n;
int nLambda = LambdaList.n;

real aVisor = 1.5;

if (iRun == 0){
  exec("mkdir "+simulHomeDir);                // Make a home directory for the simulation
  exec("mkdir "+simulHomeDir+"/msh");         // Make and save the meshes in a separeted directory
  exec("mkdir "+simulHomeDir+"/local_sols");  // Make and save the local solutions in a separeted directory
  exec("mkdir "+simulHomeDir+"/free_bnd");    // Make and save the boundaries in a separeted directory

  {ofstream fileParams (simulHomeDir+fileNameParams); // Save the exploration parameters in separate file

      fileParams.fixed;

      fileParams << "pathGlobalSols" << "," << fileNameGlobalSols << endl;
      fileParams << "pathParamsMsh" << "," << fileNameParamsMhs << endl;
      // fileParams << "maxStress" << "," << maxStress << endl;
      fileParams << "zi" << "," << zi << endl;
      // fileParams << "refCst" << refCst << endl;

      fileParams << "Amp"; // Save the list of amplitudes
      for [j, jAmp:AmpList]{fileParams << "," << jAmp;}
      fileParams << endl;

      fileParams << "Lc"; // Save the list of Lc
      for [j, jLc:LcList]{fileParams << "," << jLc;}
      fileParams << endl;

      fileParams << "Zeta"; // Save the list of contractilities
      for [j, jZeta:ZetaList]{fileParams << "," << jZeta;}
      fileParams << endl;

      fileParams << "Lambda"; // Save the list of Lambdas
      for [j, jLambda:LambdaList]{fileParams << "," << jLambda;}
      fileParams << endl;
    }

  {ofstream fileParamsMhs (simulHomeDir+fileNameParamsMhs); // Generate a separate file for the mesh parameters

    //fileParamsMhs.fixed;
    fileParamsMhs << "Mesh_Parameters" << endl
            << "amp,nFinguers,lx,lFree,obd,ibd,bLayerWidth,Area0,pathMesh" << endl;
  }

  {ofstream fileGlobalSols (simulHomeDir+fileNameGlobalSols); // Generate a separate file for the global variables (integrates ones)

    //fileGlobalSol.fixed;
    fileGlobalSols << "Global_Solutions" << endl
            << "Amp.i," << "Lc.i," << "Zeta.i," << "Lambda.i,"
            << "avgDivV,xMin,yMin,xMax,yMax,vxMin,vxMax,dVx,"
            << "pathMsh,pathLocalSol,pathFreeBnd" << endl
            << "adim,"  << "adim," << "adim,"   << "adim,"
            << "1/tscale,R,R,R,R,R/tscale,R/tscale,R/tscale,"
            <<"path,path,path" << endl;
  }
}

//Macros
macro pD [pDx, pDy] //                              // P2 extension for Dirichlet data
macro p [px, py] //                                 // Polarity vector field
macro q [qx, qy] //                                 // Polarity test functions
macro v [vx, vy] //                                 // Velocity vector field
macro u [ux, uy] //                                 // Velocity test functions
macro normal [nx, ny] //                            // Normal vectors on the non-periodic space
macro normalPerio [nxPerio, nyPerio] //             // Normal vectors on the periodic space

macro dp [dpxdx,dpxdy,dpydx,dpydy] //               // Gradient of the polarity field
macro dq [dqxdx,dqxdy,dqydx,dqydy] //               // Gradient of the polarity test functions
macro dv [dvxdx,dvxdy,dvydx,dvydy] //               // Gradient of the velocity field
macro du [duxdx,duxdy,duydx,duydy] //               // Gradient of the velocity test functions
macro d2px [dpxdxx,dpxdxy,dpxdyx,dpxdyy] //			    // Hessian of the x-polarity
macro d2py [dpydxx,dpydxy,dpydyx,dpydyy] //			    // Hessian of the y-polarity
macro d2qx [dqxdxx,dqxdxy,dqxdyx,dqxdyy] //			    // Hessian of the x-polarity test function
macro d2qy [dqydxx,dqydxy,dqydyx,dqydyy] //			    // Hessian of the y-polarity test function
      
macro grad(u) [dx(u),dy(u)] //                      // Gradient of a sclar
macro Grad(ux,uy) [dx(ux),dy(ux),dx(uy),dy(uy)] //  // Gradient of a vector
macro GradT(ux,uy) [dx(ux),dx(uy),dy(ux),dy(uy)] // // Grad vector transpose
macro Hessian(u) [dxx(u),dxy(u),dyx(u),dyy(u)] //	  // Hessian of a scalar
macro pp(px,py) [px*px,px*py,py*px,py*py] //        // Active stress tensor

macro Norm(u) dist(u#x,u#y) + 1.e-12 //             // Vector norm + offset to avoid 0-length vectors

for (int iAmp = i0Amp[iRun]; iAmp<=ifAmp[iRun]; iAmp++){

  string fileNameMsh = "/msh/mesh_"+(iAmp+1)+"Amp.msh";

  // Mesh parameters
  real[string] meshParameters;
  meshParameters["amp"] = AmpList[iAmp];
  meshParameters["lx"] = lx;
  meshParameters["lFree"] = l0;
  meshParameters["nFingers"] = nFinguers;

  // Mesh labels
  int[int] periodic = [1,3];
  int[int] free = [2];
  int[int] fixed = [4];

  real eps = 1e-12; // numerical tolerance

  func perio=[[periodic[0],x],[periodic[1],x]]; // Periodicity

  // Generate the initial mesh
  mesh Th = sinusoidalSemiplane(obd, meshParameters, free, fixed, periodic, l0, 1e12);

  // Custom mesh adaptation
  Th = periodicRemesh1FreeBnd(
    Th,obd,ibd,bLayerWidth,free,fixed, periodic,.5
  );

  // Initial variables for shape characterization
  real Area0 = Th.measure; // Inital Area of the Fluid Domain
  {ofstream fileParamsMhs (simulHomeDir+fileNameParamsMhs, append);

    fileParamsMhs.fixed;
    fileParamsMhs << meshParameters["amp"] <<","<< meshParameters["nFinguers"] <<","
                  << meshParameters["lx"]  <<","<< meshParameters["lFree"]     <<","
                  << obd                   <<","<< ibd                         <<","
                  << bLayerWidth           <<","<< Area0                       <<","
                  << fileNameMsh           << endl;
    }

  if (debug) {
    plot(
      Th, value = true, fill = false, nbiso=64, wait=true, 
      cmm = "adaptive mesh;  A0="+Area0
    );
  }

  // Save initial mesh
  if (saveLocalSols){
    savemesh(Th,simulHomeDir+fileNameMsh);
  }
  
  // FEM spaces ---------------------------------------------------------------
  fespace Pol(Th, [P2, P2],periodic=perio);          // For polarity vector
  fespace Pola(Th, P2,periodic=perio);               // For |p| (not essential, just visualization)
  fespace dPol(Th,[P2,P2,P2,P2],periodic=perio);     // For the gradient of the polarity vector

  fespace Vel(Th, [P1b, P1b],periodic=perio);        // For velocity vector
  fespace dVel(Th,[P1b,P1b,P1b,P1b],periodic=perio); // For the gradient of the velocity vector
  fespace prodVel(Th, P1b,periodic=perio);

  //fespace Vor(Th,P1b);                               // To compute the vorticity & divergence
  fespace Nh(Th,[P1,P1]);                              // For the corrected normal vector at the boundary & non-periodic geometry
  fespace NhPerio(Th,[P1,P1],periodic=perio);          // For the corrected normal vector at the boundary & periodic geometry
  //---------------------------------------------------------------------------

  // Extract the new boundary for future computations and compute its orientation
  real[int,int] bFree(3,1); real sFree = extractborder(Th, free[0], bFree);
  int nFree = bFree.m; // instead of Th.nbe to avoid problems with mesh labels

  // Retrieve the indices of the verices of bFree with the same ordering ------
  int[int] indicesFree(nFree);

  int iTri;
  for (int k=0; k<nFree; k++){
    // Find the triangle index of the kth bnd point
    iTri = Th(bFree(0,k),bFree(1,k)).nuTriangle;

    // Find index of the kth bnd point from its triangle index
    for (int jTri=0; jTri<3; jTri++) {
      if( abs(Th[iTri][jTri].x-bFree(0,k))<eps && abs(Th[iTri][jTri].y-bFree(1,k))<eps){
        indicesFree(k) = Th[iTri][jTri];
      }
    }
  }

  // Correction of the normal vectors at the boundary -------------------------

  Nh normal = [0,0]; // here the Dof of nx,ny are scramble.
  NhPerio normalPerio = [0,0];

  real[int] nprev(2), npost(2), nmean(2);
  int iBndElem; // index of the boundary element
  real lenprev, lenpost;
  nprev = [(bFree(1,nFree-1)-bFree(1,nFree-2)),-(bFree(0,nFree-1)-bFree(0,nFree-2))];
  lenprev = sqrt(pow(nprev[0],2)+pow(nprev[1],2));

  for (int k = 0; k < nFree-1; k++){
    npost = [(bFree(1,k+1)-bFree(1,k)),-(bFree(0,k+1)-bFree(0,k))];
    lenpost = sqrt(pow(npost[0],2)+pow(npost[1],2));
    
    nmean = nprev*(lenpost/(lenpost+lenprev)) + npost*(lenprev/(lenprev+lenpost));
    nmean /= sqrt(pow(nmean[0],2)+pow(nmean[1],2));

    nx[](2*indicesFree(k))= nmean[0]; ny[](2*indicesFree(k)+1) = nmean[1];
    nprev = npost; lenprev = lenpost;
  }

  // Last normal, ensure periodicity
  nx[](2*indicesFree(nFree-1))= nx[](2*indicesFree(0));
  ny[](2*indicesFree(nFree-1)+1) = ny[](2*indicesFree(0)+1);


  normalPerio = normal; // Project the normals computed at the non-periodic space into the periodic one.

  if (debug) {
    plot(
      Th,/*normal,*/normalPerio, value = true, fill = false, nbiso = 64, wait = true,
      cmm = "(nx,ny) periodic;",bb=[[-1*0.3,-aVisor*0.3],[aVisor*0.3,aVisor*0.3]]
    );
  }
  // --------------------------------------------------------------------------

  for (int iLc=0; iLc<nLc; iLc++){
    for (int iZeta=0; iZeta<nZeta; iZeta++){
      for (int iLambda=0; iLambda<nLambda; iLambda++){
        
        // Problem Parameters
        real Lc = LcList[iLc];             // Nematic length
        real Zeta = ZetaList[iZeta];       // -Constractility
        real Lambda = LambdaList[iLambda]; // Hydrodynamic screening length, sqrt(eta/xi)

        // Adim parameters
        real a = -Zeta/(zi*Lc); // Negative sign to compensate a positive defined contractility
        real b = l0/Lambda;
        real c = l0/Lc;
        
        string fileNameLocalSol = "/local_sols/sol_"+(iAmp+1)+"Amp_"+(iLc+1)+"Lc_"+(iZeta+1)+"Zeta_"+(iLambda+1)+"Lambda.txt";
        string fileNameFreeBnd = "/free_bnd/bnd_"+(iAmp+1)+"Amp_"+(iLc+1)+"Lc_"+(iZeta+1)+"Zeta_"+(iLambda+1)+"Lambda.txt";

        // Define & solve the polarity equations ------------------------------
        // P2 extension of polarity Dirichlet data
        varf bndDirichlet(pD, q) = on(free[0], pDx = nxPerio) + on(free[0], pDy = nyPerio);
        Pol pD=[0,0];
        pDx[] = bndDirichlet(0, Pol, tgv = 1.0);

        // Bilinear and linear variational forms P (Modified Homogeneous Drirchlet problem for p-pD)
        varf ap(p, q) = int2d(Th)(
            (grad(px)'*grad(qx) + grad(py)'*grad(qy))
            + c*c*(p'*q)
          )
            + on(free[0], px = 0.0) + on(free[0], py=0.0) 
            + on(fixed[0], px = 0.0) + on(fixed[0], py=0.0);

        varf lp(p, q) = int2d(Th)(
            - (grad(pDx)'*grad(qx) + grad(pDy)'*grad(qy)) 
            - c*c*(pD'*q)
          )
            + on(free[0], px = 0.0) + on(free[0], py=0.0) 
            + on(fixed[0], px = 0.0) + on(fixed[0], py=0.0);

        // Assembly P
        matrix Ap = ap(Pol, Pol, tgv = -2); // LHS matrix
        real[int] bp = lp(0, Pol); // RHS

        // P solution with vanishing Dirichlet data
        real[int] solP(Pol.ndof);
        //set(Ap,solver=sparsesolver);
        solP=Ap^-1*bp;
        Pol p=[0,0];
        px[]=solP(0:Pol.ndof-1);

        // P solution
        p = p + pD;

        // if (debug) {
        //   plot(Th,p, value = true, fill = true, nbiso = 64, wait = true, cmm = "(px,py)"/*, bb=[[-2*0.5,-aVisor*0.5],[aVisor*0.5,aVisor*0.5]]*/);
        //   Pola pABS = sqrt(px(x,y)^2 + py(x,y)^2); // Abs(P)
        //   plot(Th,pABS, value = travgDivVue, fill = true, nbiso = 64, wait = true, cmm = "|p|"/*, bb=[[-2*0.5,-aVisor*0.5],[aVisor*0.5,aVisor*0.5]]*/);
        // }

        // Define & solve the velocity equation -------------------------------
        // Bilinear and linear variational forms V
        varf av(v, u) = int2d(Th)(
            ((Grad(vx,vy)+GradT(vx,vy))'*Grad(ux,uy))
            + pow(b,2)*(v'*u)
          ) 
            + on(fixed[0], vx = 0.0) + on(fixed[0], vy = 0.0); // -viscosity -friction

        varf lv(v, u) = int2d(Th)( 
            + a*(pp(px,py)'*Grad(ux,uy))
            + c*(p'*u)
          ) 
            + on(fixed[0], vx = 0.0) + on(fixed[0], vy = 0.0); //contractility +active traction

        // Assembly V
        matrix Av = av(Vel, Vel);
        real[int] bv = lv(0, Vel);

        // V solution
        real[int] solV(Vel.ndof);
        //set(Av,solver=sparsesolver);
        solV=Av^-1*bv;
        Vel v=[0,0];
        vx[]=solV(0:Vel.ndof-1);

        // if (debug) {
        //   plot(Th,v, value = true, fill = true, nbiso = 64, wait = true, cmm = "(vx,vy)"/*, bb=[[-2*0.5,-aVisor*0.5],[aVisor*0.5,aVisor*0.5]]*/);
        //   Pola vABS = sqrt(vx(x,y)^2 + vy(x,y)^2); // Abs(P)
        //   plot(Th,vABS, value = true, fill = true, nbiso = 64, wait = true, cmm = "|v|"/*, bb=[[-2*0.5,-aVisor*0.5],[aVisor*0.5,aVisor*0.5]]*/);
        // }
        //---------------------------------------------------------------------

        // Compute the gradient of p for the posterior analysis ---------------
        varf aGradP(dp, dq) = int2d(Th)(dp'*dq);
        varf lGradP(dp, dq) = int2d(Th)(Grad(px,py)'*dq);

        matrix AGradP = aGradP(dPol, dPol);  // LHS matrix
        real[int] bGradP = lGradP(0, dPol);  // RHS vector

        real[int] solGradP(dPol.ndof);
        solGradP=AGradP^-1*bGradP;
        dPol dp=[0,0,0,0];
        dpxdx[]=solGradP(0:dPol.ndof-1);
        //---------------------------------------------------------------------

        // Compute the gradient of v for the posterior analysis ---------------
        varf aGradV(dv, du) = int2d(Th)(dv'*du);
        varf lGradV(dv, du) = int2d(Th)(Grad(vx,vy)'*du);

        matrix AGradV = aGradV(dVel, dVel);	// LHS matrix
        real[int] bGradV = lGradV(0, dVel); // RHS vector

        real[int] solGradV(dVel.ndof);
        solGradV=AGradV^-1*bGradV;
        dVel dv=[0,0,0,0];
        dvxdx[]=solGradV(0:dVel.ndof-1);
        

        // Compute the Hessian of px for posterior analysis
        varf aHessPx(d2px,d2qx) = int2d(Th)(d2px'*d2qx);
        varf lHessPx(d2px,d2qx) = int2d(Th)(Hessian(px)'*d2qx);

        matrix AHessPx = aHessPx(dPol, dPol);	// LHS matrix
        real[int] bHessPx = lHessPx(0, dPol);	// RHS vector

        real[int] solHessPx(dPol.ndof);
        solHessPx=AHessPx^-1*bHessPx;
        dPol d2px=[0,0,0,0];
        dpxdxx[]=solHessPx(0:dPol.ndof-1);

        // Compute the Hessian of py for posterior analysis
        varf aHessPy(d2py,d2qy) = int2d(Th)(d2py'*d2qy);
        varf lHessPy(d2py,d2qy) = int2d(Th)(Hessian(py)'*d2qy);

        matrix AHessPy = aHessPy(dPol, dPol);	// LHS matrix
        real[int] bHessPy = lHessPy(0, dPol);	// RHS vector

        real[int] solHessPy(dPol.ndof);
        solHessPy=AHessPy^-1*bHessPy;
        dPol d2py=[0,0,0,0];
        dpydxx[]=solHessPy(0:dPol.ndof-1);
        //---------------------------------------------------------------------


        // Compute the intial values of the global variables ------------------
        real avgDivV = int2d(Th)(dvxdx+dvydy)/Area0;    // Average divergergence of the velocity
        //---------------------------------------------------------------------

        real[int] rMin = [bFree(0,0),bFree(1,0)]; // Point of the free boundary with a lower x.
        real[int] rMax = [bFree(0,0),bFree(1,0)]; // Point of the free boundary with a larger x.

        // Find the position and velocity of the free boundary x-maximum and minimum
        for (int i=1; i<nFree; i++){
          real ix = bFree(0,i);
          real iy = bFree(1,i);

          if (ix >= rMax[0]) {
            rMax = [ix, iy]; // Check the maximum
          } else if (iy >= 0 && ix <= rMin[0]) {
            rMin = [ix, iy]; // Check the minimum (y > 0)
          }
        }

        // Compute the velocities
        real vxMin = vx(rMin[0],rMin[1]); // x-Velocity of rMin.
        real vxMax = vx(rMax[0],rMax[1]); // x-Velocity of rMax.

        real dVx = vxMax-vxMin;

        if (debug) {
          cout << "{iAmp,iLc,iZeta,iLambda} = {"+iAmp+", "+iLc+", "+iZeta+", "+iLambda+"}; Amp = "+meshParameters["amp"]+";  -La/Lc = "+a+";  L0/Lc = "+c+";  L0/lambda = "+b << endl;
          Pola vABS = sqrt(vx(x,y)^2 + vy(x,y)^2);
          plot(/*Th,*/vABS,normal, 
            value = true,
            fill = true,
            nbiso = 64,
            wait = false,
            /*bb=[[-2*0.5,-aVisor*0.5],[aVisor*0.5,aVisor*0.5]],*/
            cmm = "Amp = "+meshParameters["amp"]+";  a = "+a+";  b = "+b+";  c = "+c
          );
        }

        // Save {px, py, vx, vy, dpxdx, dpxdy, dpydx, dpydy, dvxdx, dvxdy, dvydx, dvydy, 
        // dpxdxx, dpxdxy, dpxdyx, dpxdyy, dpydxx, dpydxy, dpydyx, dpydyy} on each vertex:
        // Memory efficient method, but needs connectivity data to reconstruct the mesh
        if(saveLocalSols){
          {
            ofstream fileLocalSols (simulHomeDir+fileNameLocalSol);
            
            fileLocalSols.fixed;
            int NbVertices = Th.nv;
            fileLocalSols << "# LocalSolutions" << endl
                          << "# NumFields: " << 20 << "  NumberVertices: " << NbVertices 
                          << " Amp: " << meshParameters["amp"] << " a: " << a 
                          << " b: " << b << " c: " << c << endl
                          << "# px  py  vx  vy  dpxdx  dpxdy  dpydx  dpydy  dvxdx  dvxdy  dvydx  dvydy  " 
                          << "dpxdxx  dpxdxy  dpxdyx  dpxdyy  dpydxx  dpydxy  dpydyx  dpydyy" << endl;
            for (int i = 0; i < NbVertices; i++){
              fileLocalSols << px(Th(i).x,Th(i).y) << "  " << py(Th(i).x,Th(i).y)     << "  "  // {px,py}
                      << vx(Th(i).x,Th(i).y)       << "  " << vy(Th(i).x,Th(i).y)     << "  "  // {vx,vy}
                      << dpxdx(Th(i).x,Th(i).y)    << "  " << dpxdy(Th(i).x,Th(i).y)  << "  "  // {dpxdx,dpxdy}
                      << dpydx(Th(i).x,Th(i).y)    << "  " << dpydy(Th(i).x,Th(i).y)  << "  "  // {dpydx,dpydy}
                      << dvxdx(Th(i).x,Th(i).y)    << "  " << dvxdy(Th(i).x,Th(i).y)  << "  "  // {dvxdx,dvxdy}
                      << dvydx(Th(i).x,Th(i).y)    << "  " << dvydy(Th(i).x,Th(i).y)  << "  "  // {dvydx,dvydy}
                      << dpxdxx(Th(i).x,Th(i).y)   << "  " << dpxdxy(Th(i).x,Th(i).y) << "  "  // {dpxdxx,dpxdxy}
                      << dpxdyx(Th(i).x,Th(i).y)   << "  " << dpydyy(Th(i).x,Th(i).y) << "  "  // {dpxdyx,dpxdyy}
                      << dpydxx(Th(i).x,Th(i).y)   << "  " << dpydxy(Th(i).x,Th(i).y) << "  "  // {dpydxx,dpydxy}
                      << dpydyx(Th(i).x,Th(i).y)   << "  " << dpydyy(Th(i).x,Th(i).y) << endl; // {dpydyx,dpydyy}
            }
          }
        }

        // Save {x, y, px, py, vx, vy} on each vertex of the free boundary:
        // Eases the posterior analysis
        {
            ofstream fileFreeBnd (simulHomeDir+fileNameFreeBnd);
            
            fileFreeBnd.fixed;
            fileFreeBnd << "# FreeBoundary" << endl
                          << "# NumFields: " << 7 << "  NumberVertices: " << nFree 
                          << " Amp: " << meshParameters["amp"] << " a: " << a 
                          << " b: " << b << " c: " << c << endl
                          << "# x  y  s  px  py  vx  vy" << endl;
            for (int i = 0; i < nFree; i++){
              fileFreeBnd << bFree(0,i)   << "  " << bFree(1,i) << "  " << bFree(2,i)   << "  "  // {x,y,s}
                      << px(bFree(0,i),bFree(1,i)) << "  " << py(bFree(0,i),bFree(1,i)) << "  "  // {px,py}
                      << vx(bFree(0,i),bFree(1,i)) << "  " << vy(bFree(0,i),bFree(1,i)) << endl; // {vx,vy}
            }
          }

        // Save Global Data (variables integratet over the domain)
        {
          ofstream fileGlobalSols (simulHomeDir+fileNameGlobalSols, append);
          
          // i.Amp,i.Lc,i.Zeta,i.Lambda,avgDivV,xMin,yMin,xMax,yMax,vxMin,
          // vxMax,dVx,pathMsh,pathLocalSol,pathFreeBnd

          fileGlobalSols.fixed;
          fileGlobalSols << iAmp        << "," << iLc              << ","  
                         << iZeta       << "," << iLambda          << ","
                         << avgDivV     << ","
                         << rMin[0]     << "," << rMin[0]          << ","
                         << rMax[1]     << "," << rMax[1]          << ","
                         << vxMin       << "," << vxMax            << ","
                         << dVx         << ","  
                         << fileNameMsh << "," << fileNameLocalSol << ","
                         << fileNameFreeBnd                        << endl;
        }
      }
    }
  }
  cout << "Amp = " << meshParameters["amp"] << " Finished!" << endl; 
}
