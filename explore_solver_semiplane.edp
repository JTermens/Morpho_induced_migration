// PACKAGES FOR ADVANCED REMESHING SCHEME
load "Curvature"
load "distance"
load "isoline"
load "gsl"

// Manage command-line arguments
include "getARGV.idp"

// include <iostream>; // If needed

int iRun = getARGV("-i", 1);
bool debug = getARGV("-d", 1);
bool err = 0;

//include <iostream>;
include "parameters_sets/params_contractility_exploration.edp";
include "lib/meshes.edp"; // load the mesh generation & remeshing functions

string simulHomeDir = rootDir+"/"+simulName;
string fileNameParams = "/params.csv";
string fileNameParamsMhs = "/params_msh.csv";
string fileNameGlobalSols = "/global_sols.csv";

// Lengths of each parameter list
int nAmp = AmpList.n;
int nLc = LcList.n;
int nZeta = ZetaList.n;
int nLambda = LambdaList.n;

if (iRun == 0){
  exec("mkdir "+simulHomeDir);                // Make a home directory for the simulation
  exec("mkdir "+simulHomeDir+"/msh");         // Make and save the meshes in a separeted directory
  exec("mkdir "+simulHomeDir+"/local_sols");  // Make and save the local solutions in a separeted directory

  {ofstream fileParams (simulHomeDir+fileNameParams); // Save the exploration parameters in separate file

      fileParams.fixed;

      fileParams << "pathGlobalSols" << "," << fileNameGlobalSols << endl;
      fileParams << "pathParamsMsh" << "," << fileNameParamsMhs << endl;
      // fileParams << "maxStress" << "," << maxStress << endl;
      fileParams << "zi" << "," << zi << endl;
      // fileParams << "refCst" << refCst << endl;

      fileParams << "Amp"; // Save the list of amplitudes
      for [j, jAmp:AmpList]{fileParams << "," << jAmp;}
      fileParams << endl;

      fileParams << "Lc"; // Save the list of Lc
      for [j, jLc:LcList]{fileParams << "," << jLc;}
      fileParams << endl;

      fileParams << "Zeta"; // Save the list of contractilities
      for [j, jZeta:ZetaList]{fileParams << "," << jZeta;}
      fileParams << endl;

      fileParams << "Lambda"; // Save the list of Lambdas
      for [j, jLambda:LambdaList]{fileParams << "," << jLambda;}
      fileParams << endl;
    }

  {ofstream fileParamsMhs (simulHomeDir+fileNameParamsMhs); // Generate a separate file for the mesh parameters

    //fileParamsMhs.fixed;
    fileParamsMhs << "Mesh_Parameters" << endl
            << "q,Amp,Lx,Ly,obd,ibd,BndLayer,pathMesh" << endl;
  }

  {ofstream fileGlobalSols (simulHomeDir+fileNameGlobalSols); // Generate a separate file for the global variables (integrates ones)

    //fileGlobalSol.fixed;
    fileGlobalSols << "Global_Solutions" << endl
            << "Amp.i,"<<"Lc.i,"<<"Zeta.i,"<<"Lambda.i,"
            <<"pathMsh,pathLocalSol" << endl
            << "adim,"<<"adim,"<<"adim,"<<"adim,"
            <<"path,path" << endl;
  }
}

//Macros
macro pD [pDx, pDy] //                              // P2 extension for Dirichlet data
macro p [px, py] //                                 // Polarity vector field
macro q [qx, qy] //                                 // Polarity test functions
macro v [vx, vy] //                                 // Velocity vector field
macro u [ux, uy] //                                 // Velocity test functions
macro normal [nx, ny] //                            // Normal vectors on the non-periodic space
macro normalPerio [nxPerio, nyPerio] //             // Normal vectors on the periodic space

macro dp [dpxdx,dpxdy,dpydx,dpydy] //               // Gradient of the polarity field
macro dq [dqxdx,dqxdy,dqydx,dqydy] //               // Gradient of the polarity test functions
macro dv [dvxdx,dvxdy,dvydx,dvydy] //               // Gradient of the velocity field
macro du [duxdx,duxdy,duydx,duydy] //               // Gradient of the velocity test functions
macro d2px [dpxdxx,dpxdxy,dpxdyx,dpxdyy] //			    // Hessian of the x-polarity
macro d2py [dpydxx,dpydxy,dpydyx,dpydyy] //			    // Hessian of the y-polarity
macro d2qx [dqxdxx,dqxdxy,dqxdyx,dqxdyy] //			    // Hessian of the x-polarity test function
macro d2qy [dqydxx,dqydxy,dqydyx,dqydyy] //			    // Hessian of the y-polarity test function
      
macro grad(u) [dx(u),dy(u)] //                      // Gradient of a sclar
macro Grad(ux,uy) [dx(ux),dy(ux),dx(uy),dy(uy)] //  // Gradient of a vector
macro GradT(ux,uy) [dx(ux),dx(uy),dy(ux),dy(uy)] // // Grad vector transpose
macro Hessian(u) [dxx(u),dxy(u),dyx(u),dyy(u)] //	  // Hessian of a scalar
macro pp(px,py) [px*px,px*py,py*px,py*py] //        // Active stress tensor

macro Norm(u) dist(u#x,u#y) + 1.e-12 //             // Vector norm + offset to avoid 0-length vectors

for (int iAmp = i0Amp[iRun]: iAmp<ifAmp[iRun]; iAmp++){

  string AmpName = AmpNames[iAmp];
  string fileNameMsh = "/msh/mesh_"+AmpName+".msh";

  // Mesh parameters
  real Amp = AmpList[iAmp]; // Amplitude of the finguer perturbation
  

  // Mesh labels
  int[int] periodic = [1,3];
  int[int] free = [2];
  int[int] fixed = [4];

  // Generate the initial mesh
  mesh Th = sinusoidalSemiplane(obd, real[string]& meshParameters , int[int] free, int[int] fixed,
  int[int] periodic, real lengthScale, real Nmax
) 

}
