// Packages for advanced remeshing scheme
// load "Curvature"
// load "distance"
// load "isoline"
// load "gsl"

func mesh fourCurveShape(
  int obd, real rUp, real rDown, real rLeft,
  real rRight, real d, real symmAxis, int labelBnd
){

  mesh Th; // Final mesh

  if (((d+rUp-rDown-2*rRight) <= 0) || ((d+rUp-rDown-2*rLeft) <= 0)) {
    cout << "ERROR: d + rUp - rDown - 2*(rRight and rLeft) > 0" << endl;
    return Th;
  }

  real thetaDownRight = acos(
    (pow((rDown+rRight),2)+pow(d,2)-pow((rUp-rRight),2))/(2*(rDown+rRight)*d));
  real thetaDownLeft = acos(
    (pow((rDown+rLeft),2)+pow(d,2)-pow((rUp-rLeft),2))/(2*(rDown+rLeft)*d));
  real thetaUpRight = acos(
    (pow((rDown+rRight),2)-pow(d,2)-pow((rUp-rRight),2))/(2*(rUp-rRight)*d));
  real thetaUpLeft = acos(
    (pow((rDown+rLeft),2)-pow(d,2)-pow((rUp-rLeft),2))/(2*(rUp-rLeft)*d));
  real thetaRight = acos(
    (pow(d,2)-pow((rUp-rRight),2)-pow(rDown+rRight,2))/(2*(rUp-rRight)*(rDown+rRight)));
  real thetaLeft = acos(
    (pow(d,2)-pow((rUp-rLeft),2)-pow(rDown+rLeft,2))/(2*(rUp-rLeft)*(rDown+rLeft)));

  real xRight = -(d*(pow(d,2) - (rDown + 2*rRight - rUp)*(rDown + rUp))*cos(symmAxis) -
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rRight - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*sin(symmAxis))/(2*pow(d,2));
  real yRight = -(d*(pow(d,2) - (rDown + 2*rRight - rUp)*(rDown + rUp))*sin(symmAxis) +
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rRight - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*cos(symmAxis))/(2*pow(d,2));

  real xLeft = -(d*(pow(d,2) - (rDown + 2*rLeft - rUp)*(rDown + rUp))*cos(symmAxis) +
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rLeft - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*sin(symmAxis))/(2*pow(d,2));
  real yLeft = -(d*(pow(d,2) - (rDown + 2*rLeft - rUp)*(rDown + rUp))*sin(symmAxis) -
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rLeft - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*cos(symmAxis))/(2*pow(d,2));


  // Define the borders without mesh adaptation
  border rightArch(t=0, 1){
    x = xRight + rRight*cos((symmAxis-thetaUpRight-thetaRight)+thetaRight*t);
    y = yRight + rRight*sin((symmAxis-thetaUpRight-thetaRight)+thetaRight*t);
    label = labelBnd;
  };
 
  border upArch(t=0,1){
    x = rUp*cos((symmAxis-thetaUpRight)+(thetaUpLeft+thetaUpRight)*t);
    y = rUp*sin((symmAxis-thetaUpRight)+(thetaUpLeft+thetaUpRight)*t);
    label = labelBnd;
  };

  border leftArch(t=0,1){
    x = xLeft + rLeft*cos((symmAxis+thetaUpLeft)+thetaLeft*t);
    y = yLeft + rLeft*sin((symmAxis+thetaUpLeft)+thetaLeft*t);
    label = labelBnd;
  };
  
  border downArch(t=0,1){
    x = -d*cos(symmAxis)+rDown*cos((symmAxis+thetaDownLeft)-(thetaDownLeft+thetaDownRight)*t);
    y = -d*sin(symmAxis)+rDown*sin((symmAxis+thetaDownLeft)-(thetaDownLeft+thetaDownRight)*t);
    label = labelBnd;
  };

  Th = buildmesh(
    rightArch(obd*rRight*thetaRight)
    + upArch(obd*rUp*(thetaUpLeft+thetaUpRight))
    + leftArch(obd*rLeft*thetaLeft)
    + downArch(obd*rDown*(thetaDownLeft+thetaDownRight))
  );

  return Th;
}

func mesh oneCutSmooth(
  int obd, real cut,real r0, real rArch, real symmAxis, int labelBnd
){
  // Perturbations of the circular domain with 1 cut, smoth with 1/f = 0

  real cutAxis = symmAxis+pi;
  real t1 = acos((cos(cut/2.)-(rArch/r0))/(1-(rArch/r0)));

  // cout << "R0 = " << r0 << ", RArc = " << rArch << ", cut axis = " << cutAxis << endl;
  // cout << "theta1 = " << t1 << endl;

  real OxRight = (r0-rArch)*cos(cutAxis+t1);
  real OyRight = (r0-rArch)*sin(cutAxis+t1);
  real OxLeft = (r0-rArch)*cos(cutAxis-t1);
  real OyLeft = (r0-rArch)*sin(cutAxis-t1);
  real lenCut = sqrt((OxRight-OxLeft)*(OxRight-OxLeft) + (OyRight-OyLeft)*(OyRight-OyLeft));

  // cout << "O_right = (" << OxRight <<", "<< OyRight <<"); O_left = (" << OxLeft <<", "<< OyLeft <<"); lenCut = " << lenCut << endl;

  border GammaArchLeft(t=0,1){
    x = OxLeft+rArch*cos(cutAxis-t1*(1-t)); 
    y = OyLeft+rArch*sin(cutAxis-t1*(1-t)); 
    label = labelBnd;
  };

  border GammaCut(t=0,1){
    x = ((OxLeft+rArch*cos(cutAxis))+(OxRight-OxLeft)*t);
    y = ((OyLeft+rArch*sin(cutAxis))+(OyRight-OyLeft)*t);
    label = labelBnd;
  };

  border GammaArchRight(t=0,1){
    x = OxRight+rArch*cos(cutAxis+t1*t); 
    y = OyRight+rArch*sin(cutAxis+t1*t);
    label = labelBnd;
  };

  border GammaArchFront(t=0,1){
    x = r0*cos(cutAxis+t1+2*(pi-t1)*t);
    y = r0*sin(cutAxis+t1+2*(pi-t1)*t);
    label = labelBnd;
  };

  mesh Th=buildmesh(
    GammaArchLeft(obd*rArch*t1)
    + GammaCut(obd*lenCut)
    + GammaArchRight(obd*rArch*t1)
    + GammaArchFront(obd*r0*2*(pi-t1))
  );

  return Th;
}

func mesh sinePerturb(
  int obd, real r0, real ampFrac, int q, real symmAxis, int labelBnd
){
  // Sinusoidal perturbations of the circular domain with q lobes and a symmetry axis

  border Gamma(t=0,1){
    x = r0*(1 + ampFrac*cos(2*pi*q*t))*cos(2*pi*t+symmAxis);
    y = r0*(1 + ampFrac*cos(2*pi*q*t))*sin(2*pi*t+symmAxis);
    label = labelBnd;
  }

  mesh Th = buildmesh(Gamma(2*pi*obd));

  return Th;
}

func mesh twoCurvesTriangle(
  int obd, real r0, real rIn, real rOut, real symmAxis, int labelBnd
){
  real alpha = (2*pi/3)/2; // a 6th of a circle arclegth
  real rCentIn = r0-rIn;
  // Compute rCentOut by the cosine law with alpha and solving for it
  real rCentOut = rCentIn*cos(alpha)+sqrt(pow(rCentIn,2)*(pow(cos(alpha),2)-1)+pow(rOut+rIn,2));

  // Compute thetaOut by the cosine law with rCentIn, rCentOut & rIn+rOut
  real thetaOut = acos(
    (pow(rOut+rIn,2)+pow(rCentOut,2)-pow(rCentIn,2))/(2*(rOut+rIn)*rCentOut)
  );
  real thetaIn = alpha + thetaOut;

  real[int] xCentIn = [rCentIn*cos(symmAxis),rCentIn*cos(symmAxis+2*alpha),rCentIn*cos(symmAxis+4*alpha)];
  real[int] yCentIn = [rCentIn*sin(symmAxis),rCentIn*sin(symmAxis+2*alpha),rCentIn*sin(symmAxis+4*alpha)];

  real[int] xCentOut = [rCentOut*cos(symmAxis+alpha),rCentOut*cos(symmAxis+3*alpha),rCentOut*cos(symmAxis+5*alpha)];
  real[int] yCentOut = [rCentOut*sin(symmAxis+alpha),rCentOut*sin(symmAxis+3*alpha),rCentOut*sin(symmAxis+5*alpha)];

  border archIn0(t=0,1){
    x = xCentIn[0] + rIn*cos((symmAxis-thetaIn)+2*thetaIn*t);
    y = yCentIn[0] + rIn*sin((symmAxis-thetaIn)+2*thetaIn*t);
    label = labelBnd;
  };
  border archOut0(t=0,1){
    x = xCentOut[0]+rOut*cos((-symmAxis+alpha+thetaOut)-2*thetaOut*t);
    y = yCentOut[0]+rOut*sin((-symmAxis+alpha+thetaOut)-2*thetaOut*t);
    label = labelBnd;
  };

  border archIn1(t=0,1){
    x = xCentIn[1] + rIn*cos((symmAxis+2*alpha-thetaIn)+2*thetaIn*t);
    y = yCentIn[1] + rIn*sin((symmAxis+2*alpha-thetaIn)+2*thetaIn*t);
    label = labelBnd;
  };
  border archOut1(t=0,1){
    x = xCentOut[1]+rOut*cos((-symmAxis+3*alpha+thetaOut)-2*thetaOut*t);
    y = yCentOut[1]+rOut*sin((-symmAxis+3*alpha+thetaOut)-2*thetaOut*t);
    label = labelBnd;
  };

  border archIn2(t=0,1){
    x = xCentIn[2] + rIn*cos((symmAxis+4*alpha-thetaIn)+2*thetaIn*t);
    y = yCentIn[2] + rIn*sin((symmAxis+4*alpha-thetaIn)+2*thetaIn*t);
    label = labelBnd;
  };
  border archOut2(t=0,1){
    x = xCentOut[2]+rOut*cos((-symmAxis+5*alpha+thetaOut)-2*thetaOut*t);
    y = yCentOut[2]+rOut*sin((-symmAxis+5*alpha+thetaOut)-2*thetaOut*t);
    label = labelBnd;
  };

  mesh Th = buildmesh(
    archIn0(2*thetaIn*rIn*obd)
    + archIn1(2*thetaIn*rIn*obd)
    + archIn2(2*thetaIn*rIn*obd)
    + archOut0(2*thetaOut*rOut*obd)
    + archOut1(2*thetaOut*rOut*obd)
    + archOut2(2*thetaOut*rOut*obd)
  );
  
  return Th;
}

func mesh roundedTriangle(
  int obd, real[int] sideLengths, real rRound, int labelBnd
){
  // It is only possible to build a triangle if the sum of each pair of
  // sides is larger than the third one.
  bool err = 0;

  if(
    sideLengths[0]+sideLengths[1] <= sideLengths[2] || 
    sideLengths[1]+sideLengths[2] <= sideLengths[0] || 
    sideLengths[2]+sideLengths[0] <= sideLengths[1]
  ){
    cout << "ERROR: Unable to buid a triangle with side lengths "
            +sideLengths[0]+", "+sideLengths[1]+" & "+sideLengths[2] << endl;
  }
  
  // Consider P2 = (0,0), P1 = (a, sideLengths[0],0) and compute the position
  // of the 3rd point such that d(P1,P2) = sideLengths[1] & d(P2,P0) = sideLengths[2]
  real x2 = (pow(sideLengths[0],2)-pow(sideLengths[1],2)+pow(sideLengths[2],2))/(2*sideLengths[0]);
  real y2 = sqrt(pow(sideLengths[2],2)-pow(x2,2));

  // Compute the barycenter
  // Its position is the average of the vertices
  real xCenter = (sideLengths[0] + x2)/3;
  real yCenter = y2/3;

  real[int,int] vertices = [
    [-xCenter, sideLengths[0]-xCenter, x2-xCenter],
    [-yCenter, -yCenter, y2-yCenter]
  ];

  // To generate the roundings we need 4 parametrers per vertex
  real[int,int] roundings(2,3); // centers of the roundings
  real[int] theta0(3); real[int] dtheta(3); // initial and angle increment

  // Plus the new beginnings and ends of each side
  real[int,int] sides(2,6);

  real angleSide = 0; // Angle of the side with the horizontal
  real angleVertex = 0; // Interior angle of the triangle at a vertex
  real dRoundVertex = 0; // distance between the vertex and the rounding center

  int[int] idx = [1,2,0];
  int[int] idxPost = [2,0,1];

  for (int iPrev=0; iPrev < 3; iPrev++){

    int i = idx[iPrev];
    int iPost = idxPost[iPrev];

    angleVertex = acos(
      ((vertices(0,i)-vertices(0,iPrev))*(vertices(0,i)-vertices(0,iPost))
        + (vertices(1,i)-vertices(1,iPrev))*(vertices(1,i)-vertices(1,iPost))
      )/(sideLengths[i]*sideLengths[iPrev])
    );

    theta0(i) = angleSide - pi/2;
    dtheta(i) = pi - angleVertex;

    dRoundVertex = rRound/sin(angleVertex/2);
    roundings(0,i) = vertices(0,i) + dRoundVertex*cos(angleSide+2*pi-angleVertex/2);
    roundings(1,i) = vertices(1,i) + dRoundVertex*sin(angleSide+2*pi-angleVertex/2);

    sides(0,2*iPrev+1) = roundings(0,i) + rRound*cos(theta0(i)); // Set end of the iPrev side
    sides(1,2*iPrev+1) = roundings(1,i) + rRound*sin(theta0(i));

    sides(0,2*i) = roundings(0,i) + rRound*cos(theta0(i) + dtheta(i)); // Set start of the i side
    sides(1,2*i) = roundings(1,i) + rRound*sin(theta0(i) + dtheta(i));

    angleSide += pi - angleVertex;
  }

  // create multiborder sides
  border side(t=0,1;i){
    x = sides(0,2*i) + (sides(0,2*i+1)-sides(0,2*i))*t;
    y = sides(1,2*i) + (sides(1,2*i+1)-sides(1,2*i))*t;
    label = labelBnd;
  }

  // create multiborder roundings
  border rounding(t=0,1;i){
    x = roundings(0,i) + rRound*cos(theta0(i)+dtheta(i)*t);
    y = roundings(1,i) + rRound*sin(theta0(i)+dtheta(i)*t);
    label = labelBnd;
  }

  int[int] nBndSide = [
    lrint(dist((sides(0,1)-sides(0,0)),(sides(1,1)-sides(1,0)))*obd),
    lrint(dist((sides(0,3)-sides(0,2)),(sides(1,3)-sides(1,2)))*obd),
    lrint(dist((sides(0,5)-sides(0,4)),(sides(1,5)-sides(1,4)))*obd)
  ];
  int[int] nBndRound = [
    lrint(dtheta(0)*rRound*obd), 
    lrint(dtheta(1)*rRound*obd), 
    lrint(dtheta(2)*rRound*obd)
  ];

  // plot(rounding(nBndRound)+side(nBndSide), wait=1);

  mesh Th = buildmesh(rounding(nBndRound)+side(nBndSide));//buildmesh(side(nBnd));

  return Th;
}

func mesh closedRemesh(
  real[int,int] bnd, real lBnd, int nBnd,real bndLayerLentgh, int obd, 
  int ibd, int labelBnd, real smoothCoef, bool keepPoints, bool bndLayer
){

  int[int] be(1); // To save begin and ends of the curve
  int minPoints = 20;

  // It is not convenient to define a border inside an If
  // So 1st define all borderd and the apply the If to the mesh generation

  border OuterKeepPoints(t=0,1){ P=Curve(bnd,bnd(2,round(t*(nBnd)))/lBnd);label=labelBnd;}
  
  // Remesh the outr boundary using an Akima spline
  gslspline splineX(gslinterpakima, bnd(2,:), bnd(0,:));
  gslspline splineY(gslinterpakima, bnd(2,:), bnd(1,:));

  border OuterSpline(t=0,1){x=splineX(t*lBnd); y=splineY(t*lBnd); label=labelBnd;}
  
  int nOut = keepPoints? nBnd : round(obd*lBnd);

  mesh Th0;
  if (keepPoints) {
    Th0 = buildmesh(OuterKeepPoints(nOut));
  } else {
    Th0 = buildmesh(OuterSpline(nOut));
  }

  if (!bndLayer) {
    return Th0;
  }

  // FEM Spaces
  fespace Dh(Th0, P1); // For distance function (remeshing scheme) and data exports

  // Distance function (d is the minimal distance to the boundary)
  varf vong(B, d)= on(labelBnd,B=1);
  real[int] ong=vong(0,Dh);
  Dh B =1, d;
  B[] = ong ? 0 : B[];
  distance(Th0,B,d[]);
  // plot(d,Th0, wait=1);

  // Just one inner loop
  // real[int,int] ISO(3,1); int nc=isoline(Th0,d,iso=bndLayerLentgh,close=1,ISO,smoothing=bndLayerLentgh*smoothCoef,ratio=1.e-0);
  // real lInner=ISO(2,ISO.m-1); // lInner is the perimeter of ISO
  // border Inner(t=0,1){ P=Curve(ISO,t);label=0;} // Linear interpolation of the inner boundary (simple and robust)
  // int nInnerFilter = round(ibd*lInner); // new number of elements (prescribed density ibd)

  // Get the new inner boundary vertices (ISO is the contour d==bndLayerLentgh) with multiple loops
  real[int,int] ISO(3,1); int nc=isoline(Th0,d,iso=bndLayerLentgh,close=0,ISO,beginend=be,smoothing=bndLayerLentgh*smoothCoef,ratio=1.e-0);
  int nInnerLoops = be.n/2;
  // cout << be << endl;

  int[int] nInner(nInnerLoops); // numer of points per loop
  int nCorrectLoops = 0; // number of loops with more than minPoints
  real[int] s0(nInnerLoops); // initial archlenght of the loop
  // find number of points and count > minPoints
  // Also, filter for errors in the archlength
  for (int i=0;  i < nInnerLoops; i++){
    real lInner=ISO(2,be(i*2+1)-1);
    s0[i] = ISO(2,be(i*2));
    nInner[i] = round(ibd*lInner);
    if((nInner[i] > minPoints) && (s0[i] == 0)){nCorrectLoops++;}
  }

  // if the number of points is less than minPoints, filter the border for safety
  int[int] nInnerFilter(nCorrectLoops);
  int[int] beFilter(2*nCorrectLoops);

  int j = 0;
  for (int i=0;  i < nInnerLoops; i++){
    if((nInner[i] > minPoints) && (s0[i] == 0)){
      nInnerFilter[j] = nInner[i];
      beFilter[2*j] = be[i*2];
      beFilter[2*j+1] = be[i*2+1];
      j++;
    }
  }

  // cout << nInner << "\n" << nInnerFilter << endl;
  
  border Inner(t=0,1;i) {P=Curve(ISO,beFilter(i*2),beFilter(i*2+1)-1,t); label=(labelBnd+1);} // Inner boundary multi-border
  // cout << nInner << endl;

  mesh Th;
  if (keepPoints) {
    // plot(OuterKeepPoints(nOut),Inner(nInnerFilter)/*, wait=1*/
    Th = buildmesh(OuterKeepPoints(nOut)+Inner(nInnerFilter));
  } else {
    // plot(OuterSpline(nOut),Inner(nInnerFilter)/*, wait=1*/
    Th = buildmesh(OuterSpline(nOut)+Inner(nInnerFilter));
  }
  Th = change(Th, rmInternalEdges=1);
  return Th;
}

func real computeDistAxis(real xPoint, real yPoint, real[int] axis){
  real[int] axisP1 = [0,axis[0]], axisP2 = [0,axis[1]];

  return abs((axisP2[0]-axisP1[0])*(axisP1[1]-yPoint) - (axisP2[1]-axisP1[1])*(axisP1[0]-xPoint)) /
         dist(axisP1[1]-axisP2[1],axisP1[0]-axisP2[0]);
}

func int computeFrontRear(real[int,int] bnd, int nBnd, real[int,int] frontRear){
  real[int] distAxis(nBnd), bestFourY(4);
  int[int] pointIdx(nBnd), bestFourIdx(4);
  real[int] axis = [0,1];

  for (int i=0; i < nBnd; i++){
    pointIdx[i] = i;
    distAxis[i] = computeDistAxis(bnd(0,i),bnd(1,i),axis);
  }
  sort(distAxis,pointIdx); // Find the 4 closest points to the symmetry axis
  for (int i=0; i<4; i++){
    bestFourIdx[i] = pointIdx[i];
    bestFourY[i] = bnd(1,pointIdx[i]);
  }
  sort(bestFourY,bestFourIdx); // Find the indices of the front & rear points

  frontRear(0,0) = bnd(0,bestFourIdx[3]); frontRear(0,1) = bnd(1,bestFourIdx[3]); // Front
  frontRear(1,0) = bnd(0,bestFourIdx[0]); frontRear(1,1) = bnd(1,bestFourIdx[0]); // Rear
  
  return 0;
}

func mesh circle(
  int obd, real r0, int labelBnd
){
  // Outer border of a circle
  border arch(t=0,1){
    x = r0*cos(2*pi*t);
    y = r0*sin(2*pi*t);
    label = labelBnd;
  };
  mesh Th = buildmesh(
    arch(obd*r0*2*pi)
  );

  return Th;
}

// Util functions ------------------------------------------------------------
func real[int,int] computeArchlength(real[int,int] b0, int n0, int i0, int i1){
  real[int,int] b1(3,n0);
  b1(0,:) = b0(0,:); b1(1,:) = b0(1,:);
  b1(2,i0) = 0;
  for (int i=i0+1; i<i1; i++){
    b1(2,i) = b1(2,i-1) + dist((b1(0,i)-b1(0,i-1)),(b1(1,i)-b1(1,i-1)));
  }
  return b1;
}

func real[int,int] twinPerioPoints(real [int,int] b0, int n0, real yTwin){
  real[int,int] b1(3,n0);
  for (int i=0; i<n0; i++){
    b1(0,(n0-1)-i) = b0(0,i); b1(1,(n0-1)-i) = yTwin;
  }
  return computeArchlength(b1,n0,0,n0);
}

func real[int,int] linInterpX(real x0, real x1, real y0, int n){
  real [int,int] b(2,n);
  real lb = x1-x0;
  for (int i=0; i<n; i++){
    real xi = x0 + lb*(real(i)/(n-1));
    b(0,i) = xi;
    b(1,i) = y0;
  }

  return b;
}

func int[int] retrieveIndices(real[int,int] b0, int n0, mesh Th0){
  int[int] indices(n0);

  int iTri;
  real eps = 1e-12;

  mesh Th = Th0; // required for Th().nuTriangle to work

  for (int k=0; k<n0; k++){
    // Find the triangle index of the kth bnd point
    iTri = Th(b0(0,k),b0(1,k)).nuTriangle;

    // Find index of the kth bnd point from its triangle index
    for (int jTri=0; jTri<3; jTri++) {
      if( abs(Th0[iTri][jTri].x-b0(0,k))<eps && abs(Th0[iTri][jTri].y-b0(1,k))<eps){
        indices(k) = Th0[iTri][jTri];
      }
    }
  }

  return indices;
}

func mesh periodicRemesh1FreeBnd(
  mesh Th0, real obd, real ibd, real bndLayerWidth, int[int] free,
  int[int] fixed, int[int] periodic, real smoothCoef
){

  int[int] labelPerio =  periodic; // Periodic boundaries
  int labelFree = free[0];   // Free boundary
  int labelFixed = fixed[0];  // Fixed boundary, opposed to the free one

  int[int] be(1); // To save begin and ends of the layer curve
  int minPoints = 5;
  real eps = pow(10,-9);

  // Extract the non-periodic boundary pieces
  real[int,int] bFree(3,1); real lFree = extractborder(Th0,labelFree,bFree);             // extract free
  real[int,int] bFixed(3,1); real lFixed = extractborder(Th0,labelFixed,bFixed);         // extract fixed

  // ------------------------------------------------------------------------------------

  // Define an inner border that defines the boundary layer through isolines
  
  real xLayer = 0;
  // Find the extreme points of the periodic boundaries
  real[int] pointsXPerio = [bFixed(0,bFixed.m-1), xLayer, bFree(0,0)];
  real[int] pointsYPerio = [bFixed(1,bFixed.m-1), bFixed(1,0)];

  mesh Th = Th0;
  fespace Dh(Th, P1);

  // Distance function (d is the minimal distance to the boundary)
  varf vong(B, d)= on(labelFree,B=1);
  real[int] ong=vong(0,Dh);
  Dh B = 1, d;
  B[] = ong ? 0 : B[];
  distance(Th,B,d[]);
  // plot(Th, d wait=1);

  // Get the new inner boundary vertices (bLayer is the contour d==bndLayerWidth)
  real[int,int] bLayer(3,1); 
  int nLayer=isoline(
    Th,d,iso=bndLayerWidth,close=0,bLayer,beginend=be,
    smoothing=bndLayerWidth*smoothCoef,ratio=1.e-0
  );
  
  int nInnerLines = be.n/2;
  // cout << be << endl;

  int[int] nInner(nInnerLines); // numer of points per loop
  real[int] s0(nInnerLines); // initial archlenght of the loop
  int nCorrectLines = 0; // number of loops with more than minPoints
  // find number of points, count > minPoints & correct open ends
  // Also, filter for errors in the archlength
  for (int i=0;  i < nInnerLines; i++){

    real lInner = bLayer(2,be(i*2+1)-1);
    s0[i] = bLayer(2,be(i*2));
    nInner[i] = lround(ibd*lInner);
    if((nInner[i] > minPoints) && (s0[i] == 0)){nCorrectLines++;}

    if(dist((bLayer(0,be(i*2+1)-1)-bLayer(0,be(i*2))),(bLayer(1,be(i*2+1)-1)-bLayer(1,be(i*2)))) > eps){ // Open loop
      bLayer(1,be(i*2)) = pointsYPerio[0]; // correct y-coords
      bLayer(1,be(i*2+1)-1) = pointsYPerio[1];

      nLayer = be(i*2+1)-be(i*2); // # points in the layer's isoline
      xLayer = bLayer(0,be(i*2)); // x-coord of the layer
      bLayer(0,be(i*2+1)-1) = xLayer; // correct x-coords

      bLayer = computeArchlength(bLayer,bLayer.m,be(2*i),be(2*i+1));
    }
  }

  // if the number of points is less than minPoints, filter the border for safety
  int[int] nInnerF(nCorrectLines);
  int[int] beF(2*nCorrectLines);

  int j = 0;
  for (int i=0;  i < nInnerLines; i++){
    if((nInner[i] > minPoints) && (s0[i] == 0)) {
      nInnerF[j] = nInner[i];
      beF[2*j] = be[i*2];
      beF[2*j+1] = be[i*2+1];
      j++;
    }
  }
  //  cout << "# Lines = " << nCorrectLines << "; " << endl;

  border Inner(t=0,1;i) {P=Curve(bLayer,beF(i*2),beF(i*2+1)-1,t);} // Inner boundary multi-border
  // cout << nInner << endl;
  // plot(Inner(nInnerF),wait=true);

  // ------------------------------------------------------------------------------------

  // Find the extreme points of the periodic boundaries
  pointsXPerio[1] = xLayer;
  // cout << pointsXPerio << endl;

  // We take extremaXPerio as the x-cords of the periodic bnds extremes
  // and extremaYPerio as their y-coords 

  // Chechk the free-perio junctions
  bFree(0,bFree.m-1) = bFree(0,0); // Correct the x-coord in order to match the points
  bFree(1,0) = pointsYPerio[0];
  bFree(1,bFree.m-1) = pointsYPerio[1];

  bFree = computeArchlength(bFree,bFree.m,0,bFree.m);

  // Remesh the free boundary using an spline
  gslspline splineXFree(gslinterpakimaperiodic, bFree(2, :), bFree(0, :)); 	// x(s) akima spline
  gslspline splineYFree(gslinterpakimaperiodic, bFree(2, :), bFree(1, :)); 	// y(s) akima spline

  int nFree = round(obd*lFree);	// new number of elements (prescribed density obd)
  border Free(t=0,lFree){
    x = splineXFree(t);
    y = splineYFree(t);
    label = labelFree;
  }

  // Keep the same vertices for the fixed
  int nFixed = bFixed.m-1;
  border Fixed(t=0,1){
    P = Curve(bFixed,bFixed(2,lround(t*nFixed))/lFixed);
    label = labelFixed;
  }

  // Define the periodic boundaries by linear interpolation
  real lPerioB = pointsXPerio[1]-pointsXPerio[0];
  real lPerioL = pointsXPerio[2]-pointsXPerio[1];
  int nPerioB = lround(ibd*lPerioB);
  int nPerioL = lround(obd*lPerioL);

  real[int,int] bPerioB = computeArchlength(linInterpX(pointsXPerio[0],pointsXPerio[1],pointsYPerio[0],nPerioB),nPerioB,0,nPerioB);
  real[int,int] bPerioL = computeArchlength(linInterpX(pointsXPerio[1],pointsXPerio[2],pointsYPerio[0],nPerioL),nPerioL,0,nPerioL);

  // real[int,int] bPerio1B = twinPerioPoints(bPerio0B,pointsYPerio[1],nPerioB);
  // real[int,int] bPerio1L = twinPerioPoints(bPerio0L,pointsYPerio[1],nPerioL);

  // cout << nPerioL << endl;
  // cout << linInterpX(pointsXPerio[1],pointsXPerio[2],pointsYPerio[0],nPerioL) << endl;
  // cout << bPerioL << endl;

  // Tried with diferent options, using splines  is the most robust
  gslspline splineXPerioB(gslinterpakimaperiodic, bPerioB(2, :), bPerioB(0, :)); 	// x(s) akima spline
  gslspline splineXPerioL(gslinterpakimaperiodic, bPerioL(2, :), bPerioL(0, :)); 	// x(s) akima spline

  // cout << "(" << bFree(0,0)             << ", " << bFree(1,0)      << ");"
  //      << "(" << splineXPerioL(lPerioB) << ", " << pointsYPerio[0] << ");" << endl;

  border Perio0B(t=0,lPerioB){
    label = labelPerio[0];
    x = splineXPerioB(t); y = pointsYPerio[0];
  }

  border Perio0L(t=0,lPerioL){
    label = labelPerio[0];
    x = splineXPerioL(t); y = pointsYPerio[0];
  }
  
  border Perio1B(t=lPerioB,0){
    label = labelPerio[1];
    x = splineXPerioB(t); y = pointsYPerio[1];
  }

  border Perio1L(t=lPerioL,0){
    label = labelPerio[1];
    x = splineXPerioL(t); y = pointsYPerio[1];
  }

  // plot(
  //   Perio0B(nPerioB) + Perio0L(nPerioL) + Perio1B(nPerioB) + Perio1L(nPerioL) 
  //   + Free(nFree) + Fixed(nFixed) + Inner(nInnerF), wait =1
  // );

  Th = buildmesh(
    Perio0B(nPerioB) 
    + Perio0L(nPerioL) 
    + Perio1B(nPerioB) 
    + Perio1L(nPerioL) 
    + Free(nFree) 
    + Fixed(nFixed) 
    + Inner(nInnerF)/*,
    fixedborder=1*/
  );

  Th = change(Th, rmInternalEdges=1);

  return Th;
}

func mesh sinusoidalSemiplane(
  real bndDensity, real[string]& meshParameters , int[int] free, int[int] fixed,
  int[int] periodic, real lengthScale, real Nmax
){
  /*
  [mesh] meshSemiplaneSinusoidal returns a rectangular mesh with nFigers 
  sinusoidal fingers on its left side. The bopundary extremes always match with
  a finger minimum.

  Parameters:
    - real bndDensity: boundary density, num. of points per unit lenght at the
      boundary.
    - real[string]& meshParameters: parameters that define the shape:
      - "lx": width of the rectangle (x-axis). The total x-length is lx+2*amp.
      - "amp": amplitude of the sinusoidal finger. Take into account 
        that the finger overtakes the base rectangle by 2*amp, as it runs for 
        a full wavelength. 
      - "lFree": width of the rectangle (y-axis).
      - "nFingers": num. of fingers. Their wavelength = lFree/n.
  - int[int] free, fixed, periodic: free is the label of the free boundary 
    (right); fixed for the fixed one (left) & periodic for the top and bottom.
  - real lengthScale: length scale to adimensionalize the mesh (x, y /= L).
  - real Nmax: Maximum number of points per border piece.

  * Return type: mesh
  */

  // Unpack meshParameters.
  real lx = meshParameters["lx"]; 
  real lFree = meshParameters["lFree"];
  real amp = meshParameters["amp"];
  int nFingers = meshParameters["nFingers"];

  // Unpack the labels.
  int labelBottom = periodic[0]; // 1st periodic boundary (Bottom)
  int labelTop = periodic[1];    // 2nd periodic boundary (Top)
  int labelRight = free[0];      // Free boundary (right)
  int labelLeft = fixed[0];      // Fixed boundary, opposed to the free one (left)

  // Define the borders for both the bulk and the layer meshes
  // Defien the borders for both the bulk and the layer meshes.
  border Bottom(t=0, 1){
    x = (lx*(t-1))/lengthScale; 
    y = (-lFree/2.)/lengthScale;
    label = labelBottom;
  }

  border Top(t=0, 1){
    x = (0-lx*t)/lengthScale; 
    y = (lFree/2.)/lengthScale; 
    label = labelTop;
  }

  border Left(t=0,1){
    x = (-lx)/lengthScale;
    y = (lFree*(1/2.-t))/lengthScale;
    label = labelLeft;
  }

  // change for a perturbed front, if needed. Mantain extreme points at x=0
  border RightFinger(t=0,1){
    x = (amp*(cos(pi*(2*nFingers*t-1))+1))/lengthScale;
    y = (lFree*(t-1/2.))/lengthScale;
    label = labelRight;
  }

  mesh Th = buildmesh(
    Bottom(min(Nmax, bndDensity*lx/lengthScale))
    + RightFinger(min(Nmax, bndDensity*lFree/lengthScale))
    + Top(min(Nmax, bndDensity*lx/lengthScale))
    + Left(min(Nmax, bndDensity*lFree/lengthScale))
  );
  
  return Th;
}


// // Construct the mesh -------------------------------------------------------------------------------------------------

// // Common params
// int obd = 45;
// int ibd = 15;
// real symmAxis = pi/2;

// real r0 = 1;
// int labelBnd = 1;
// real bLayerThickness = 0.15;

// // fourCurveShape params
// real rUp = r0;
// real rDown = 0.5;
// real rLeft = 0.25;
// real rRight = 0.25;
// real d = 0.5;

// oneCutSmooth params
// real cut = 2*pi/3;
// real fracRarc = 0.1;

// // sinePerturb params
// real ampFrac = 0.5;
// int q = 3;

// // twoCurvesTriangle params
// real rIn = 0.3;
// real rOut = 0.35;

// // triangleMesh params
// real[int] sideLengths = [2,5,5];
// real rRound = 0.1;

// mesh Th = fourCurveShape(obd,rUp,rDown,rLeft,rRight,d,symmAxis,labelBnd);
// mesh Th = oneCutSmooth(obd,cut,r0,fracRarc,symmAxis,labelBnd);
// mesh Th = sinePerturb(obd,r0,ampFrac,q,symmAxis,labelBnd);
// mesh Th = twoCurvesTriangle(obd,r0,rInreal Area0 = Th.measure; // Inital Area of the Fluid Domain
// real Xcm0 = int2d(Th)(x)/Area0; //Initial x_cm
// real Ycm0 = int2d(Th)(y)/Area0; //Initial y_cm


// plot(
//   Th,value = true, fill = false, nbiso=64, wait=true, 
//   cmm = "adaptive mesh;  A0="+Area0+",  (xcm0,yxm0)=("+Xcm0+","+Ycm0+")"
// );,rOut,symmAxis,labelBnd);
// mesh Th = roundedTriangle(obd,sideLengths,rRound,labelBnd);

// real L0 = sqrt(Th.measure);

// sideLengths /= L0; rRound /= L0;

// Th = roundedTriangle(obd,sideLengths,rRound,labelBnd);

// // Extract outer boundary
// // extractborder gives bOut(3,Th.nbe+1) with 1st point == last point
// // for k in (0,Th.nbe-1): 
// //		bOut(0,k) == x coord kth vertex
// //		bOut(1,k) == y coord ktha ( vertex
// //		bOut(2,k) == arch length at the kth vertex
// real[int,int] bMesh(3,1); real lMesh = extractborder(Th, labelBnd, bMesh);

// real[int,int] frontRear(2,2);
// cout << frontRear << endl;
// int err = computeFrontRear(bMesh, bMesh.m-1, frontRear);
// cout << frontRear << endl;

// Th = closedRemesh(bMesh,lMesh,bMesh.m-1,bLayerThickness,obd,ibd,labelBnd,.5,0,1); // Custom mesh adaptation

// // Initial variables for shape characterization
// real Area0 = Th.measure; // Inital Area of the Fluid Domain
// real Xcm0 = int2d(Th)(x)/Area0; //Initial x_cm
// real Ycm0 = int2d(Th)(y)/Area0; //Initial y_cm


// plot(
//   Th,value = true, fill = false, nbiso=64, wait=true, 
//   cmm = "adaptive mesh;  A0="+Area0+",  (xcm0,yxm0)=("+Xcm0+","+Ycm0+")"
// );

// //---------------------------------------------------------------------------------------------------------------------
