func mesh fourCurveShape(
  int bndDensity, real[int] meshParameters , int[int] labels
){
  /*
  [mesh] fourCurveShape returns a mesh with a boundary defined by four 
  tangetial circumference arches. The centers of the Up & Down arches are 
  separrated by a distance d, while the Left & Right ones are tangent to those
  and close the boundary.

  Parameters:
  - int bndDensity: boundary density, num. of points per unit lenght at the boundary.
  - real[int] meshParameters: parameters that define the shape. By order:
    - 0, rUp: radius of the upper arch.
    - 1, rDown: radius of the lower arch.
    - 2, rLeft: radius of the left arch. 
    - 3, rRight: radius of the right arch.
    - 4, d: distance between the center of the Up & Down arches.
    - 5, symmAxis: orientation of the (not necessary symmetric) shape. Defines
    the line between the centers of the Up & Down arches.
  - int[int] labels: the first element is the boundary label, other ones will
  be ignored 

  * Return type: mesh
  */

  // Unpack mesh parameters
  real rUp = meshParameters[0];
  real rDown = meshParameters[1];
  real rLeft = meshParameters[2];
  real rRight = meshParameters[3];
  real d = meshParameters[4];
  real symmAxis = meshParameters[5];

  // Set the closed-boundary label
  int labelBnd = labels[0];

  mesh Th; // Final mesh

  if (((d+rUp-rDown-2*rRight) <= 0) || ((d+rUp-rDown-2*rLeft) <= 0)) {
    cout << "ERROR: d + rUp - rDown - 2*(rRight and rLeft) > 0" << endl;
    return Th;
  }

  real thetaDownRight = acos(
    (pow((rDown+rRight),2)+pow(d,2)-pow((rUp-rRight),2))/(2*(rDown+rRight)*d));
  real thetaDownLeft = acos(
    (pow((rDown+rLeft),2)+pow(d,2)-pow((rUp-rLeft),2))/(2*(rDown+rLeft)*d));
  real thetaUpRight = acos(
    (pow((rDown+rRight),2)-pow(d,2)-pow((rUp-rRight),2))/(2*(rUp-rRight)*d));
  real thetaUpLeft = acos(
    (pow((rDown+rLeft),2)-pow(d,2)-pow((rUp-rLeft),2))/(2*(rUp-rLeft)*d));
  real thetaRight = acos(
    (pow(d,2)-pow((rUp-rRight),2)-pow(rDown+rRight,2))/(2*(rUp-rRight)*(rDown+rRight)));
  real thetaLeft = acos(
    (pow(d,2)-pow((rUp-rLeft),2)-pow(rDown+rLeft,2))/(2*(rUp-rLeft)*(rDown+rLeft)));

  real xRight = -(d*(pow(d,2) - (rDown + 2*rRight - rUp)*(rDown + rUp))*cos(symmAxis) -
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rRight - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*sin(symmAxis))/(2*pow(d,2));
  real yRight = -(d*(pow(d,2) - (rDown + 2*rRight - rUp)*(rDown + rUp))*sin(symmAxis) +
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rRight - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*cos(symmAxis))/(2*pow(d,2));

  real xLeft = -(d*(pow(d,2) - (rDown + 2*rLeft - rUp)*(rDown + rUp))*cos(symmAxis) +
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rLeft - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*sin(symmAxis))/(2*pow(d,2));
  real yLeft = -(d*(pow(d,2) - (rDown + 2*rLeft - rUp)*(rDown + rUp))*sin(symmAxis) -
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rLeft - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*cos(symmAxis))/(2*pow(d,2));


  // Define the borders without mesh adaptation
  border rightArch(t=0, 1){
    x = xRight + rRight*cos((symmAxis-thetaUpRight-thetaRight)+thetaRight*t);
    y = yRight + rRight*sin((symmAxis-thetaUpRight-thetaRight)+thetaRight*t);
    label = labelBnd;
  };
 
  border upArch(t=0,1){
    x = rUp*cos((symmAxis-thetaUpRight)+(thetaUpLeft+thetaUpRight)*t);
    y = rUp*sin((symmAxis-thetaUpRight)+(thetaUpLeft+thetaUpRight)*t);
    label = labelBnd;
  };

  border leftArch(t=0,1){
    x = xLeft + rLeft*cos((symmAxis+thetaUpLeft)+thetaLeft*t);
    y = yLeft + rLeft*sin((symmAxis+thetaUpLeft)+thetaLeft*t);
    label = labelBnd;
  };
  
  border downArch(t=0,1){
    x = -d*cos(symmAxis)+rDown*cos((symmAxis+thetaDownLeft)-(thetaDownLeft+thetaDownRight)*t);
    y = -d*sin(symmAxis)+rDown*sin((symmAxis+thetaDownLeft)-(thetaDownLeft+thetaDownRight)*t);
    label = labelBnd;
  };

  Th = buildmesh(
    rightArch(bndDensity*rRight*thetaRight)
    + upArch(bndDensity*rUp*(thetaUpLeft+thetaUpRight))
    + leftArch(bndDensity*rLeft*thetaLeft)
    + downArch(bndDensity*rDown*(thetaDownLeft+thetaDownRight))
  );

  return Th;
}

func mesh oneCutSmooth(
  int bndDensity, real[int] meshParameters , int[int] labels
){
  /*
  [mesh] oneCutSmooth returns a mesh with a boundary defined by circle with a
  strigth cut of angular length cut, perpendicular to a ray in the symmAxis 
  direction. The vertices of the cut are smoothed by tangential arches of 
  radius rArch.

  Parameters:
  - int bndDensity: boundary density, num. of points per unit lenght at the boundary.
  - real[int] meshParameters: parameters that define the shape. By order:
    - 0, cut: angluar length of the straight cut line.
    - 1, r0: radius of the circumference (Front) arch.
    - 2, rArch: radius of the tangential arches that smooth the cut vertices. 
    - 3, symmAxis: orientation of the shape. Defines the mid-line of the cut.
  - int[int] labels: the first element is the boundary label, other ones will
  be ignored 

  * Return type: mesh
  */

  // Unpack meshParameters
  real cut = meshParameters[0];
  real r0 = meshParameters[1];
  real rArch = meshParameters[2];
  real symmAxis = meshParameters[3];

  // Set the closed-boundary label
  int labelBnd = labels[0];

  real cutAxis = symmAxis+pi;
  real t1 = acos((cos(cut/2.)-(rArch/r0))/(1-(rArch/r0)));

  real OxRight = (r0-rArch)*cos(cutAxis+t1);
  real OyRight = (r0-rArch)*sin(cutAxis+t1);
  real OxLeft = (r0-rArch)*cos(cutAxis-t1);
  real OyLeft = (r0-rArch)*sin(cutAxis-t1);
  real lenCut = sqrt((OxRight-OxLeft)*(OxRight-OxLeft) + (OyRight-OyLeft)*(OyRight-OyLeft));

  border ArchLeft(t=0,1){
    x = OxLeft+rArch*cos(cutAxis-t1*(1-t)); 
    y = OyLeft+rArch*sin(cutAxis-t1*(1-t)); 
    label = labelBnd;
  };

  border Cut(t=0,1){
    x = ((OxLeft+rArch*cos(cutAxis))+(OxRight-OxLeft)*t);
    y = ((OyLeft+rArch*sin(cutAxis))+(OyRight-OyLeft)*t);
    label = labelBnd;
  };

  border ArchRight(t=0,1){
    x = OxRight+rArch*cos(cutAxis+t1*t); 
    y = OyRight+rArch*sin(cutAxis+t1*t);
    label = labelBnd;
  };

  border ArchFront(t=0,1){
    x = r0*cos(cutAxis+t1+2*(pi-t1)*t);
    y = r0*sin(cutAxis+t1+2*(pi-t1)*t);
    label = labelBnd;
  };

  mesh Th=buildmesh(
    ArchLeft(bndDensity*rArch*t1)
    + Cut(bndDensity*lenCut)
    + ArchRight(bndDensity*rArch*t1)
    + ArchFront(bndDensity*r0*2*(pi-t1))
  );

  return Th;
}

func mesh sinePerturb(
  int bndDensity, real[int] meshParameters , int[int] labels
){
  /*
  [mesh] sinePerturb returns a mesh with a boundary defined by the sinusoidal perturbations of a circle

  Parameters:
  - int bndDensity: boundary density, num. of points per unit lenght at the boundary.
  - real[int] meshParameters: parameters that define the shape. By order:
    - 0, r0: radius of the base circumference.
    - 1, Amp: Amplitude of the sinusoidal perturbations.
    - 2, q: perturbation wave-number (number of lobes).
    - 3, symmAxis: orientation of the shape. Defines the symmetry axis.
  - int[int] labels: the first element is the boundary label, other ones will
  be ignored 

  * Return type: mesh
  */

  // Unpack meshParameters
  real r0 = meshParameters[0];
  real Amp = meshParameters[1];
  int q = lrint(meshParameters[2]);
  real symmAxis = meshParameters[3];

  // Set the closed-boundary label
  int labelBnd = labels[0];

  border Boundary(t=0,1){
    x = (r0 + Amp*cos(2*pi*q*t))*cos(2*pi*t+symmAxis);
    y = (r0 + Amp*cos(2*pi*q*t))*sin(2*pi*t+symmAxis);
    label = labelBnd;
  }

  mesh Th = buildmesh(Boundary(bndDensity*r0*2*pi));

  return Th;
}

func mesh twoCurvesTriangle(
  int bndDensity, real[int] meshParameters, int[int] labels
){
  /*
  [mesh] twoCurvesTriangle returns a mesh with a boundary defined by an equilateral triangle of apothem r0 with cricumference arches of radius rVertex at its vertices and tangetial circumference arches of radius rSide at its sides.  

  Parameters:
  - int bndDensity: boundary density, num. of points per unit lenght at the boundary.
  - real[int] meshParameters: parameters that define the shape. By order:
    - 0, r0: radius of the base circumference.
    - 1, rSide: Amplitude of the sinusoidal perturbations.
    - 2, rVertex: perturbation wave-number (number of lobes).
    - 3, symmAxis: orientation of the shape. Defines the symmetry axis.
  - int[int] labels: the first element is the boundary label, other ones will
  be ignored 

  * Return type: mesh
  */

  // Unpack the meshParameters
  real r0 = meshParameters[0];
  real rSide = meshParameters[1];
  real rVertex = meshParameters[2];
  real symmAxis = meshParameters[3];

  // Set the closed-boundary label
  int labelBnd = labels[0];

  real alpha = (2*pi/3)/2; // a 6th of a circle arclegth
  real rCentSide = r0-rSide;
  // Compute rCentVertex by the cosine law with alpha and solving for it
  real rCentVertex = rCentSide*cos(alpha)+sqrt(pow(rCentSide,2)*(pow(cos(alpha),2)-1)+pow(rVertex+rSide,2));

  // Compute thetaVertex by the cosine law with rCentSide, rCentVertex & rSide+rVertex
  real thetaVertex = acos(
    (pow(rVertex+rSide,2)+pow(rCentVertex,2)-pow(rCentSide,2))/(2*(rVertex+rSide)*rCentVertex)
  );
  real thetaSide = alpha + thetaVertex;

  real[int] xCentSide = [rCentSide*cos(symmAxis),rCentSide*cos(symmAxis+2*alpha),rCentSide*cos(symmAxis+4*alpha)];
  real[int] yCentSide = [rCentSide*sin(symmAxis),rCentSide*sin(symmAxis+2*alpha),rCentSide*sin(symmAxis+4*alpha)];

  real[int] xCentVertex = [rCentVertex*cos(symmAxis+alpha),rCentVertex*cos(symmAxis+3*alpha),rCentVertex*cos(symmAxis+5*alpha)];
  real[int] yCentVertex = [rCentVertex*sin(symmAxis+alpha),rCentVertex*sin(symmAxis+3*alpha),rCentVertex*sin(symmAxis+5*alpha)];

  border archSide0(t=0,1){
    x = xCentSide[0] + rSide*cos((symmAxis-thetaSide)+2*thetaSide*t);
    y = yCentSide[0] + rSide*sin((symmAxis-thetaSide)+2*thetaSide*t);
    label = labelBnd;
  };
  border archVertex0(t=0,1){
    x = xCentVertex[0]+rVertex*cos((-symmAxis+alpha+thetaVertex)-2*thetaVertex*t);
    y = yCentVertex[0]+rVertex*sin((-symmAxis+alpha+thetaVertex)-2*thetaVertex*t);
    label = labelBnd;
  };

  border archSide1(t=0,1){
    x = xCentSide[1] + rSide*cos((symmAxis+2*alpha-thetaSide)+2*thetaSide*t);
    y = yCentSide[1] + rSide*sin((symmAxis+2*alpha-thetaSide)+2*thetaSide*t);
    label = labelBnd;
  };
  border archVertex1(t=0,1){
    x = xCentVertex[1]+rVertex*cos((-symmAxis+3*alpha+thetaVertex)-2*thetaVertex*t);
    y = yCentVertex[1]+rVertex*sin((-symmAxis+3*alpha+thetaVertex)-2*thetaVertex*t);
    label = labelBnd;
  };

  border archSide2(t=0,1){
    x = xCentSide[2] + rSide*cos((symmAxis+4*alpha-thetaSide)+2*thetaSide*t);
    y = yCentSide[2] + rSide*sin((symmAxis+4*alpha-thetaSide)+2*thetaSide*t);
    label = labelBnd;
  };
  border archVertex2(t=0,1){
    x = xCentVertex[2]+rVertex*cos((-symmAxis+5*alpha+thetaVertex)-2*thetaVertex*t);
    y = yCentVertex[2]+rVertex*sin((-symmAxis+5*alpha+thetaVertex)-2*thetaVertex*t);
    label = labelBnd;
  };

  mesh Th = buildmesh(
    archSide0(bndDensity*2*thetaSide*rSide)
    + archSide1(bndDensity*2*thetaSide*rSide)
    + archSide2(bndDensity*2*thetaSide*rSide)
    + archVertex0(bndDensity*2*thetaVertex*rVertex)
    + archVertex1(bndDensity*2*thetaVertex*rVertex)
    + archVertex2(bndDensity*2*thetaVertex*rVertex)
  );
  
  return Th;
}

func mesh roundedTriangle(
  int obd, real[int] sideLengths, real rRound, int labelBnd
){
  // It is only possible to build a triangle if the sum of each pair of
  // sides is larger than the third one.
  bool err = 0;

  if(
    sideLengths[0]+sideLengths[1] <= sideLengths[2] || 
    sideLengths[1]+sideLengths[2] <= sideLengths[0] || 
    sideLengths[2]+sideLengths[0] <= sideLengths[1]
  ){
    cout << "ERROR: Unable to buid a triangle with side lengths "
            +sideLengths[0]+", "+sideLengths[1]+" & "+sideLengths[2] << endl;
  }
  
  // Consider P2 = (0,0), P1 = (a, sideLengths[0],0) and compute the position
  // of the 3rd point such that d(P1,P2) = sideLengths[1] & d(P2,P0) = sideLengths[2]
  real x2 = (pow(sideLengths[0],2)-pow(sideLengths[1],2)+pow(sideLengths[2],2))/(2*sideLengths[0]);
  real y2 = sqrt(pow(sideLengths[2],2)-pow(x2,2));

  // Compute the barycenter
  // Its position is the average of the vertices
  real xCenter = (sideLengths[0] + x2)/3;
  real yCenter = y2/3;

  real[int,int] vertices = [
    [-xCenter, sideLengths[0]-xCenter, x2-xCenter],
    [-yCenter, -yCenter, y2-yCenter]
  ];

  // To generate the roundings we need 4 parametrers per vertex
  real[int,int] roundings(2,3); // centers of the roundings
  real[int] theta0(3); real[int] dtheta(3); // initial and angle increment

  // Plus the new beginnings and ends of each side
  real[int,int] sides(2,6);

  real angleSide = 0; // Angle of the side with the horizontal
  real angleVertex = 0; // Interior angle of the triangle at a vertex
  real dRoundVertex = 0; // distance between the vertex and the rounding center

  int[int] idx = [1,2,0];
  int[int] idxPost = [2,0,1];

  for (int iPrev=0; iPrev < 3; iPrev++){

    int i = idx[iPrev];
    int iPost = idxPost[iPrev];

    angleVertex = acos(
      ((vertices(0,i)-vertices(0,iPrev))*(vertices(0,i)-vertices(0,iPost))
        + (vertices(1,i)-vertices(1,iPrev))*(vertices(1,i)-vertices(1,iPost))
      )/(sideLengths[i]*sideLengths[iPrev])
    );

    theta0(i) = angleSide - pi/2;
    dtheta(i) = pi - angleVertex;

    dRoundVertex = rRound/sin(angleVertex/2);
    roundings(0,i) = vertices(0,i) + dRoundVertex*cos(angleSide+2*pi-angleVertex/2);
    roundings(1,i) = vertices(1,i) + dRoundVertex*sin(angleSide+2*pi-angleVertex/2);

    sides(0,2*iPrev+1) = roundings(0,i) + rRound*cos(theta0(i)); // Set end of the iPrev side
    sides(1,2*iPrev+1) = roundings(1,i) + rRound*sin(theta0(i));

    sides(0,2*i) = roundings(0,i) + rRound*cos(theta0(i) + dtheta(i)); // Set start of the i side
    sides(1,2*i) = roundings(1,i) + rRound*sin(theta0(i) + dtheta(i));

    angleSide += pi - angleVertex;
  }

  // create multiborder sides
  border side(t=0,1;i){
    x = sides(0,2*i) + (sides(0,2*i+1)-sides(0,2*i))*t;
    y = sides(1,2*i) + (sides(1,2*i+1)-sides(1,2*i))*t;
    label = labelBnd;
  }

  // create multiborder roundings
  border rounding(t=0,1;i){
    x = roundings(0,i) + rRound*cos(theta0(i)+dtheta(i)*t);
    y = roundings(1,i) + rRound*sin(theta0(i)+dtheta(i)*t);
    label = labelBnd;
  }

  int[int] nBndSide = [
    lrint(dist((sides(0,1)-sides(0,0)),(sides(1,1)-sides(1,0)))*obd),
    lrint(dist((sides(0,3)-sides(0,2)),(sides(1,3)-sides(1,2)))*obd),
    lrint(dist((sides(0,5)-sides(0,4)),(sides(1,5)-sides(1,4)))*obd)
  ];
  int[int] nBndRound = [
    lrint(dtheta(0)*rRound*obd), 
    lrint(dtheta(1)*rRound*obd), 
    lrint(dtheta(2)*rRound*obd)
  ];

  // plot(rounding(nBndRound)+side(nBndSide), wait=1);

  mesh Th = buildmesh(rounding(nBndRound)+side(nBndSide));//buildmesh(side(nBnd));

  return Th;
}

func mesh closedRemesh(
  real[int,int] bnd, real lBnd, int nBnd,real bndLayerLentgh, int obd, 
  int ibd, int labelBnd, real smoothCoef, bool keepPoints, bool bndLayer
){

  int[int] be(1); // To save begin and ends of the curve
  int minPoints = 20;

  // It is not convenient to define a border inside an If
  // So 1st define all borderd and the apply the If to the mesh generation

  border OuterKeepPoints(t=0,1){ P=Curve(bnd,bnd(2,round(t*(nBnd)))/lBnd);label=labelBnd;}
  
  // Remesh the outr boundary using an Akima spline
  gslspline splineX(gslinterpakima, bnd(2,:), bnd(0,:));
  gslspline splineY(gslinterpakima, bnd(2,:), bnd(1,:));

  border OuterSpline(t=0,1){x=splineX(t*lBnd); y=splineY(t*lBnd); label=labelBnd;}
  
  int nOut = keepPoints? nBnd : round(obd*lBnd);

  mesh Th0;
  if (keepPoints) {
    Th0 = buildmesh(OuterKeepPoints(nOut));
  } else {
    Th0 = buildmesh(OuterSpline(nOut));
  }

  if (!bndLayer) {
    return Th0;
  }

  // FEM Spaces
  fespace Dh(Th0, P1); // For distance function (remeshing scheme) and data exports

  // Distance function (d is the minimal distance to the boundary)
  varf vong(B, d)= on(labelBnd,B=1);
  real[int] ong=vong(0,Dh);
  Dh B =1, d;
  B[] = ong ? 0 : B[];
  distance(Th0,B,d[]);
  // plot(d,Th0, wait=1);

  // Just one inner loop
  // real[int,int] ISO(3,1); int nc=isoline(Th0,d,iso=bndLayerLentgh,close=1,ISO,smoothing=bndLayerLentgh*smoothCoef,ratio=1.e-0);
  // real lInner=ISO(2,ISO.m-1); // lInner is the perimeter of ISO
  // border Inner(t=0,1){ P=Curve(ISO,t);label=0;} // Linear interpolation of the inner boundary (simple and robust)
  // int nInnerFilter = round(ibd*lInner); // new number of elements (prescribed density ibd)

  // Get the new inner boundary vertices (ISO is the contour d==bndLayerLentgh) with multiple loops
  real[int,int] ISO(3,1); int nc=isoline(Th0,d,iso=bndLayerLentgh,close=0,ISO,beginend=be,smoothing=bndLayerLentgh*smoothCoef,ratio=1.e-0);
  int nInnerLoops = be.n/2;
  // cout << be << endl;

  int[int] nInner(nInnerLoops); // numer of points per loop
  int nCorrectLoops = 0; // number of loops with more than minPoints
  // find number of points and count > minPoints
  for (int i=0;  i < nInnerLoops; i++){
    real lInner=ISO(2,be(i*2+1)-1);
    nInner[i] = round(ibd*lInner);
    if(nInner[i] > minPoints){nCorrectLoops++;}
  }

  // if the number of points is less than minPoints, filter the border for safety
  int[int] nInnerFilter(nCorrectLoops);
  int[int] beFilter(2*nCorrectLoops);

  int j = 0;
  for (int i=0;  i < nInnerLoops; i++){
    if(nInner[i] > minPoints){
      nInnerFilter[j] = nInner[i];
      beFilter[2*j] = be[i*2];
      beFilter[2*j+1] = be[i*2+1];
      j++;
    }
  }

  // cout << nInner << "\n" << nInnerFilter << endl;
  
  border Inner(t=0,1;i) {P=Curve(ISO,beFilter(i*2),beFilter(i*2+1)-1,t); label=(labelBnd+1);} // Inner boundary multi-border
  // cout << nInner << endl;

  mesh Th;
  if (keepPoints) {
    // plot(OuterKeepPoints(nOut),Inner(nInnerFilter)/*, wait=1*/
    Th = buildmesh(OuterKeepPoints(nOut)+Inner(nInnerFilter));
  } else {
    // plot(OuterSpline(nOut),Inner(nInnerFilter)/*, wait=1*/
    Th = buildmesh(OuterSpline(nOut)+Inner(nInnerFilter));
  }
  Th = change(Th, rmInternalEdges=1);
  return Th;
}

func real computeDistAxis(real xPoint, real yPoint, real[int] axis){
  real[int] axisP1 = [0,axis[0]], axisP2 = [0,axis[1]];

  return abs((axisP2[0]-axisP1[0])*(axisP1[1]-yPoint) - (axisP2[1]-axisP1[1])*(axisP1[0]-xPoint)) /
         dist(axisP1[1]-axisP2[1],axisP1[0]-axisP2[0]);
}

func int computeFrontRear(real[int,int] bnd, int nBnd, real[int,int] frontRear){
  real[int] distAxis(nBnd), bestFourY(4);
  int[int] pointIdx(nBnd), bestFourIdx(4);
  real[int] axis = [0,1];

  for (int i=0; i < nBnd; i++){
    pointIdx[i] = i;
    distAxis[i] = computeDistAxis(bnd(0,i),bnd(1,i),axis);
  }
  sort(distAxis,pointIdx); // Find the 4 closest points to the symmetry axis
  for (int i=0; i<4; i++){
    bestFourIdx[i] = pointIdx[i];
    bestFourY[i] = bnd(1,pointIdx[i]);
  }
  sort(bestFourY,bestFourIdx); // Find the indices of the front & rear points

  frontRear(0,0) = bnd(0,bestFourIdx[3]); frontRear(0,1) = bnd(1,bestFourIdx[3]); // Front
  frontRear(1,0) = bnd(0,bestFourIdx[0]); frontRear(1,1) = bnd(1,bestFourIdx[0]); // Rear
  
  return 0;
}

func mesh circle(
  int obd, real r0, int labelBnd
){
  // Outer border of a circle
  border arch(t=0,1){
    x = r0*cos(2*pi*t);
    y = r0*sin(2*pi*t);
    label = labelBnd;
  };
  mesh Th = buildmesh(
    arch(obd*r0*2*pi)
  );

  return Th;
}
