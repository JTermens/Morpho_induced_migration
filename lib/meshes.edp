/* meshes.edp
Catalog of FreeFem++ meshes for the Ephithelial-tissues-FEM project. It includes the following mesh generation functions:

Closed meshes:
- fourCurveShape
- oneCutSmooth
- sinePerturb
- twoCurvesTriangle
- roundedTriangle
- circle

Semi-periodic meshes
- 

All the meshes share the same arguments:
- int bndDensity: boundary density, num. of points per unit lenght at the boundary.
- real[int] meshParameters: array with the parameters that define the shape.
- int[int] labels: labels of the mesh boundaries.
*/

func mesh fourCurveShape(
  int bndDensity, real[int] meshParameters , int[int] labels
){
  /*
  [mesh] fourCurveShape returns a mesh with a boundary defined by four 
  tangetial circumference arches. The centers of the Up & Down arches are 
  separrated by a distance d, while the Left & Right ones are tangent to those
  and close the boundary.

  Parameters:
  - int bndDensity: boundary density, num. of points per unit lenght at the boundary.
  - real[int] meshParameters: parameters that define the shape. By order:
    - 0, rUp: radius of the upper arch.
    - 1, rDown: radius of the lower arch.
    - 2, rLeft: radius of the left arch. 
    - 3, rRight: radius of the right arch.
    - 4, d: distance between the center of the Up & Down arches.
    - 5, symmAxis: orientation of the (not necessary symmetric) shape. Defines
    the line between the centers of the Up & Down arches.
  - int[int] labels: the first element is the boundary label, other ones will
  be ignored.

  * Return type: mesh
  */

  // Unpack mesh parameters
  real rUp = meshParameters[0];
  real rDown = meshParameters[1];
  real rLeft = meshParameters[2];
  real rRight = meshParameters[3];
  real d = meshParameters[4];
  real symmAxis = meshParameters[5];

  // Set the closed-boundary label
  int labelBnd = labels[0];

  mesh Th; // Final mesh

  if (((d+rUp-rDown-2*rRight) <= 0) || ((d+rUp-rDown-2*rLeft) <= 0)) {
    cout << "ERROR: d + rUp - rDown - 2*(rRight and rLeft) > 0" << endl;
    return Th;
  }

  real thetaDownRight = acos(
    (pow((rDown+rRight),2)+pow(d,2)-pow((rUp-rRight),2))/(2*(rDown+rRight)*d));
  real thetaDownLeft = acos(
    (pow((rDown+rLeft),2)+pow(d,2)-pow((rUp-rLeft),2))/(2*(rDown+rLeft)*d));
  real thetaUpRight = acos(
    (pow((rDown+rRight),2)-pow(d,2)-pow((rUp-rRight),2))/(2*(rUp-rRight)*d));
  real thetaUpLeft = acos(
    (pow((rDown+rLeft),2)-pow(d,2)-pow((rUp-rLeft),2))/(2*(rUp-rLeft)*d));
  real thetaRight = acos(
    (pow(d,2)-pow((rUp-rRight),2)-pow(rDown+rRight,2))/(2*(rUp-rRight)*(rDown+rRight)));
  real thetaLeft = acos(
    (pow(d,2)-pow((rUp-rLeft),2)-pow(rDown+rLeft,2))/(2*(rUp-rLeft)*(rDown+rLeft)));

  real xRight = -(d*(pow(d,2) - (rDown + 2*rRight - rUp)*(rDown + rUp))*cos(symmAxis) -
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rRight - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*sin(symmAxis))/(2*pow(d,2));
  real yRight = -(d*(pow(d,2) - (rDown + 2*rRight - rUp)*(rDown + rUp))*sin(symmAxis) +
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rRight - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*cos(symmAxis))/(2*pow(d,2));

  real xLeft = -(d*(pow(d,2) - (rDown + 2*rLeft - rUp)*(rDown + rUp))*cos(symmAxis) +
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rLeft - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*sin(symmAxis))/(2*pow(d,2));
  real yLeft = -(d*(pow(d,2) - (rDown + 2*rLeft - rUp)*(rDown + rUp))*sin(symmAxis) -
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rLeft - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*cos(symmAxis))/(2*pow(d,2));


  // Define the borders without mesh adaptation
  border rightArch(t=0, 1){
    x = xRight + rRight*cos((symmAxis-thetaUpRight-thetaRight)+thetaRight*t);
    y = yRight + rRight*sin((symmAxis-thetaUpRight-thetaRight)+thetaRight*t);
    label = labelBnd;
  };
 
  border upArch(t=0,1){
    x = rUp*cos((symmAxis-thetaUpRight)+(thetaUpLeft+thetaUpRight)*t);
    y = rUp*sin((symmAxis-thetaUpRight)+(thetaUpLeft+thetaUpRight)*t);
    label = labelBnd;
  };

  border leftArch(t=0,1){
    x = xLeft + rLeft*cos((symmAxis+thetaUpLeft)+thetaLeft*t);
    y = yLeft + rLeft*sin((symmAxis+thetaUpLeft)+thetaLeft*t);
    label = labelBnd;
  };
  
  border downArch(t=0,1){
    x = -d*cos(symmAxis)+rDown*cos((symmAxis+thetaDownLeft)-(thetaDownLeft+thetaDownRight)*t);
    y = -d*sin(symmAxis)+rDown*sin((symmAxis+thetaDownLeft)-(thetaDownLeft+thetaDownRight)*t);
    label = labelBnd;
  };

  Th = buildmesh(
    rightArch(bndDensity*rRight*thetaRight)
    + upArch(bndDensity*rUp*(thetaUpLeft+thetaUpRight))
    + leftArch(bndDensity*rLeft*thetaLeft)
    + downArch(bndDensity*rDown*(thetaDownLeft+thetaDownRight))
  );

  return Th;
}

func mesh oneCutSmooth(
  int bndDensity, real[int] meshParameters , int[int] labels
){
  /*
  [mesh] oneCutSmooth returns a mesh with a boundary defined by circle with a
  strigth cut of angular length cut, perpendicular to a ray in the symmAxis 
  direction. The vertices of the cut are smoothed by tangential arches of 
  radius rArch.

  Parameters:
  - int bndDensity: boundary density, num. of points per unit lenght at the boundary.
  - real[int] meshParameters: parameters that define the shape. By order:
    - 0, cut: angluar length of the straight cut line.
    - 1, r0: radius of the circumference (Front) arch.
    - 2, rArch: radius of the tangential arches that smooth the cut vertices. 
    - 3, symmAxis: orientation of the shape. Defines the mid-line of the cut.
  - int[int] labels: the first element is the boundary label, other ones will
  be ignored.

  * Return type: mesh
  */

  // Unpack meshParameters
  real cut = meshParameters[0];
  real r0 = meshParameters[1];
  real rArch = meshParameters[2];
  real symmAxis = meshParameters[3];

  // Set the closed-boundary label
  int labelBnd = labels[0];

  real cutAxis = symmAxis+pi;
  real t1 = acos((cos(cut/2.)-(rArch/r0))/(1-(rArch/r0)));

  real OxRight = (r0-rArch)*cos(cutAxis+t1);
  real OyRight = (r0-rArch)*sin(cutAxis+t1);
  real OxLeft = (r0-rArch)*cos(cutAxis-t1);
  real OyLeft = (r0-rArch)*sin(cutAxis-t1);
  real lenCut = sqrt((OxRight-OxLeft)*(OxRight-OxLeft) + (OyRight-OyLeft)*(OyRight-OyLeft));

  border ArchLeft(t=0,1){
    x = OxLeft+rArch*cos(cutAxis-t1*(1-t)); 
    y = OyLeft+rArch*sin(cutAxis-t1*(1-t)); 
    label = labelBnd;
  };

  border Cut(t=0,1){
    x = ((OxLeft+rArch*cos(cutAxis))+(OxRight-OxLeft)*t);
    y = ((OyLeft+rArch*sin(cutAxis))+(OyRight-OyLeft)*t);
    label = labelBnd;
  };

  border ArchRight(t=0,1){
    x = OxRight+rArch*cos(cutAxis+t1*t); 
    y = OyRight+rArch*sin(cutAxis+t1*t);
    label = labelBnd;
  };

  border ArchFront(t=0,1){
    x = r0*cos(cutAxis+t1+2*(pi-t1)*t);
    y = r0*sin(cutAxis+t1+2*(pi-t1)*t);
    label = labelBnd;
  };

  mesh Th=buildmesh(
    ArchLeft(bndDensity*rArch*t1)
    + Cut(bndDensity*lenCut)
    + ArchRight(bndDensity*rArch*t1)
    + ArchFront(bndDensity*r0*2*(pi-t1))
  );

  return Th;
}

func mesh sinePerturb(
  int bndDensity, real[int] meshParameters , int[int] labels
){
  /*
  [mesh] sinePerturb returns a mesh with a boundary defined by the sinusoidal perturbations of a circle

  Parameters:
  - int bndDensity: boundary density, num. of points per unit lenght at the boundary.
  - real[int] meshParameters: parameters that define the shape. By order:
    - 0, r0: radius of the base circumference.
    - 1, Amp: Amplitude of the sinusoidal perturbations.
    - 2, q: perturbation wave-number (number of lobes).
    - 3, symmAxis: orientation of the shape. Defines the symmetry axis.
  - int[int] labels: the first element is the boundary label, other ones will
  be ignored.

  * Return type: mesh
  */

  // Unpack meshParameters
  real r0 = meshParameters[0];
  real Amp = meshParameters[1];
  int q = lrint(meshParameters[2]);
  real symmAxis = meshParameters[3];

  // Set the closed-boundary label
  int labelBnd = labels[0];

  border Boundary(t=0,1){
    x = (r0 + Amp*cos(2*pi*q*t))*cos(2*pi*t+symmAxis);
    y = (r0 + Amp*cos(2*pi*q*t))*sin(2*pi*t+symmAxis);
    label = labelBnd;
  }

  mesh Th = buildmesh(Boundary(bndDensity*r0*2*pi));

  return Th;
}

func mesh twoCurvesTriangle(
  int bndDensity, real[int] meshParameters, int[int] labels
){
  /*
  [mesh] twoCurvesTriangle returns a mesh with a boundary defined by an equilateral triangle of apothem r0 with cricumference arches of radius rVertex at its vertices and tangetial circumference arches of radius rSide at its sides.  

  Parameters:
  - int bndDensity: boundary density, num. of points per unit lenght at the boundary.
  - real[int] meshParameters: parameters that define the shape. By order:
    - 0, r0: radius of the base circumference.
    - 1, rSide: radius of the arches at the sides.
    - 2, rVertex: radius of the arches at the vertices.
    - 3, symmAxis: orientation of the upper vertex. Defines the symmetry axis.
  - int[int] labels: the first element is the boundary label, other ones will
  be ignored.

  * Return type: mesh
  */

  // Unpack the meshParameters
  real r0 = meshParameters[0];
  real rSide = meshParameters[1];
  real rVertex = meshParameters[2];
  real symmAxis = meshParameters[3];

  // Set the closed-boundary label
  int labelBnd = labels[0];

  real alpha = (2*pi/3)/2; // a 6th of a circle arclegth
  real rCentSide = r0-rSide;
  // Compute rCentVertex by the cosine law with alpha and solving for it
  real rCentVertex = rCentSide*cos(alpha)+sqrt(pow(rCentSide,2)*(pow(cos(alpha),2)-1)+pow(rVertex+rSide,2));

  // Compute thetaVertex by the cosine law with rCentSide, rCentVertex & rSide+rVertex
  real thetaVertex = acos(
    (pow(rVertex+rSide,2)+pow(rCentVertex,2)-pow(rCentSide,2))/(2*(rVertex+rSide)*rCentVertex)
  );
  real thetaSide = alpha + thetaVertex;

  real[int] xCentSide = [rCentSide*cos(symmAxis),rCentSide*cos(symmAxis+2*alpha),rCentSide*cos(symmAxis+4*alpha)];
  real[int] yCentSide = [rCentSide*sin(symmAxis),rCentSide*sin(symmAxis+2*alpha),rCentSide*sin(symmAxis+4*alpha)];

  real[int] xCentVertex = [rCentVertex*cos(symmAxis+alpha),rCentVertex*cos(symmAxis+3*alpha),rCentVertex*cos(symmAxis+5*alpha)];
  real[int] yCentVertex = [rCentVertex*sin(symmAxis+alpha),rCentVertex*sin(symmAxis+3*alpha),rCentVertex*sin(symmAxis+5*alpha)];

  border Side0(t=0,1){
    x = xCentSide[0] + rSide*cos((symmAxis-thetaSide)+2*thetaSide*t);
    y = yCentSide[0] + rSide*sin((symmAxis-thetaSide)+2*thetaSide*t);
    label = labelBnd;
  };
  border Vertex0(t=0,1){
    x = xCentVertex[0]+rVertex*cos((-symmAxis+alpha+thetaVertex)-2*thetaVertex*t);
    y = yCentVertex[0]+rVertex*sin((-symmAxis+alpha+thetaVertex)-2*thetaVertex*t);
    label = labelBnd;
  };

  border Side1(t=0,1){
    x = xCentSide[1] + rSide*cos((symmAxis+2*alpha-thetaSide)+2*thetaSide*t);
    y = yCentSide[1] + rSide*sin((symmAxis+2*alpha-thetaSide)+2*thetaSide*t);
    label = labelBnd;
  };
  border Vertex1(t=0,1){
    x = xCentVertex[1]+rVertex*cos((-symmAxis+3*alpha+thetaVertex)-2*thetaVertex*t);
    y = yCentVertex[1]+rVertex*sin((-symmAxis+3*alpha+thetaVertex)-2*thetaVertex*t);
    label = labelBnd;
  };

  border Side2(t=0,1){
    x = xCentSide[2] + rSide*cos((symmAxis+4*alpha-thetaSide)+2*thetaSide*t);
    y = yCentSide[2] + rSide*sin((symmAxis+4*alpha-thetaSide)+2*thetaSide*t);
    label = labelBnd;
  };
  border Vertex2(t=0,1){
    x = xCentVertex[2]+rVertex*cos((-symmAxis+5*alpha+thetaVertex)-2*thetaVertex*t);
    y = yCentVertex[2]+rVertex*sin((-symmAxis+5*alpha+thetaVertex)-2*thetaVertex*t);
    label = labelBnd;
  };

  mesh Th = buildmesh(
    Side0(bndDensity*2*thetaSide*rSide)
    + Side1(bndDensity*2*thetaSide*rSide)
    + Side2(bndDensity*2*thetaSide*rSide)
    + Vertex0(bndDensity*2*thetaVertex*rVertex)
    + Vertex1(bndDensity*2*thetaVertex*rVertex)
    + Vertex2(bndDensity*2*thetaVertex*rVertex)
  );
  
  return Th;
}

func mesh roundedTriangle(
  int bndDensity, real[int] meshParameters, int[int] labels
){
  /*
  [mesh] roundedTriangle returns a mesh with a boundary defined by a triangle of the given sides and rounded vertices with a radius of rRound.

  Parameters:
  - int bndDensity: boundary density, num. of points per unit lenght at the boundary.
  - real[int] meshParameters: parameters that define the shape. By order:
    - 0:2, sideLengths: lengths of the traingle sides.
    - 3, rRound: radius of the rounded vertices.
  - int[int] labels: the first element is the boundary label, other ones will
  be ignored.

  * Return type: mesh
  */
  
  // Unpack meshParameters
  real[int] sideLengths = [meshParameters[0], meshParameters[1], meshParameters[2]];
  real rRound = meshParameters[3];

  // Set the closed-boundary label
  int labelBnd = labels[0];
  
  // It is only possible to build a triangle if the sum of each pair of
  // sides is larger than the third one.
  bool err = 0;

  if(
    sideLengths[0]+sideLengths[1] <= sideLengths[2] || 
    sideLengths[1]+sideLengths[2] <= sideLengths[0] || 
    sideLengths[2]+sideLengths[0] <= sideLengths[1]
  ){
    cout << "ERROR: Unable to buid a triangle with side lengths "
            +sideLengths[0]+", "+sideLengths[1]+" & "+sideLengths[2] << endl;
  }
  
  // Consider P2 = (0,0), P1 = (a, sideLengths[0],0) and compute the position
  // of the 3rd point such that d(P1,P2) = sideLengths[1] & d(P2,P0) = sideLengths[2]
  real x2 = (pow(sideLengths[0],2)-pow(sideLengths[1],2)+pow(sideLengths[2],2))/(2*sideLengths[0]);
  real y2 = sqrt(pow(sideLengths[2],2)-pow(x2,2));

  // Compute the barycenter
  // Its position is the average of the vertices
  real xCenter = (sideLengths[0] + x2)/3;
  real yCenter = y2/3;

  real[int,int] vertices = [
    [-xCenter, sideLengths[0]-xCenter, x2-xCenter],
    [-yCenter, -yCenter, y2-yCenter]
  ];

  // To generate the roundings we need 4 parametrers per vertex
  real[int,int] roundings(2,3); // centers of the roundings
  real[int] theta0(3); real[int] dtheta(3); // initial and angle increment

  // Plus the new beginnings and ends of each side
  real[int,int] sides(2,6);

  real angleSide = 0; // Angle of the side with the horizontal
  real angleVertex = 0; // Interior angle of the triangle at a vertex
  real dRoundVertex = 0; // distance between the vertex and the rounding center

  int[int] idx = [1,2,0];
  int[int] idxPost = [2,0,1];

  for (int iPrev=0; iPrev < 3; iPrev++){

    int i = idx[iPrev];
    int iPost = idxPost[iPrev];

    angleVertex = acos(
      ((vertices(0,i)-vertices(0,iPrev))*(vertices(0,i)-vertices(0,iPost))
        + (vertices(1,i)-vertices(1,iPrev))*(vertices(1,i)-vertices(1,iPost))
      )/(sideLengths[i]*sideLengths[iPrev])
    );

    theta0(i) = angleSide - pi/2;
    dtheta(i) = pi - angleVertex;

    dRoundVertex = rRound/sin(angleVertex/2);
    roundings(0,i) = vertices(0,i) + dRoundVertex*cos(angleSide+2*pi-angleVertex/2);
    roundings(1,i) = vertices(1,i) + dRoundVertex*sin(angleSide+2*pi-angleVertex/2);

    sides(0,2*iPrev+1) = roundings(0,i) + rRound*cos(theta0(i)); // Set end of the iPrev side
    sides(1,2*iPrev+1) = roundings(1,i) + rRound*sin(theta0(i));

    sides(0,2*i) = roundings(0,i) + rRound*cos(theta0(i) + dtheta(i)); // Set start of the i side
    sides(1,2*i) = roundings(1,i) + rRound*sin(theta0(i) + dtheta(i));

    angleSide += pi - angleVertex;
  }

  // create multiborder sides
  border side(t=0,1;i){
    x = sides(0,2*i) + (sides(0,2*i+1)-sides(0,2*i))*t;
    y = sides(1,2*i) + (sides(1,2*i+1)-sides(1,2*i))*t;
    label = labelBnd;
  }

  // create multiborder roundings
  border rounding(t=0,1;i){
    x = roundings(0,i) + rRound*cos(theta0(i)+dtheta(i)*t);
    y = roundings(1,i) + rRound*sin(theta0(i)+dtheta(i)*t);
    label = labelBnd;
  }

  int[int] nBndSide = [
    lrint(dist((sides(0,1)-sides(0,0)),(sides(1,1)-sides(1,0)))*bndDensity),
    lrint(dist((sides(0,3)-sides(0,2)),(sides(1,3)-sides(1,2)))*bndDensity),
    lrint(dist((sides(0,5)-sides(0,4)),(sides(1,5)-sides(1,4)))*bndDensity)
  ];
  int[int] nBndRound = [
    lrint(dtheta(0)*rRound*bndDensity), 
    lrint(dtheta(1)*rRound*bndDensity), 
    lrint(dtheta(2)*rRound*bndDensity)
  ];

  // plot(rounding(nBndRound)+side(nBndSide), wait=1);

  mesh Th = buildmesh(rounding(nBndRound)+side(nBndSide));

  return Th;
}

func mesh circle(
  int bndDensity, real[int] meshParameters, int[int] labels
){
  /*
  [mesh] circle returns a circular mesh with radius r0.

  Parameters:
  - int bndDensity: boundary density, num. of points per unit lenght at the boundary.
  - real[int] meshParameters: parameters that define the shape. By order:
    - 0, r0: circle radius.
  - int[int] labels: the first element is the boundary label, other ones will
  be ignored.

  * Return type: mesh
  */

  // Unpack meshParameters
  real r0= meshParameters[0];

  // Set the closed-boundary label
  int labelBnd = labels[0];

  // Outer border of a circle
  border arch(t=0,1){
    x = r0*cos(2*pi*t);
    y = r0*sin(2*pi*t);
    label = labelBnd;
  };
  mesh Th = buildmesh(
    arch(bndDensity*r0*2*pi)
  );

  return Th;
}

// Needs an update
func mesh sinusoidalSemiplane(
  int obd, int ibd, real bLayerThickness, real Lx, real Ly, real Amp, real q, int[int] labels 
){

  int labelBottom = labels[0];  // 1st periodic boundary (Bottom)
  int labelTop = labels[1];     // 2nd periodic boundary (Top)
  int labelRight = labels[2];   // Free boundary (right)
  int labelLeft = labels[3];    // Fixed boundary, opposed to the free one (left)

  real xMaxBnd = Amp*cos(q*Ly);

  // Define the borders for both the bulk and the layer meshes
  border Bottom(t=0, 1){
    x = -Lx+(Lx+xMaxBnd-bLayerThickness)*t; 
    y = -Ly;
    label = labelBottom;
  }
  border BottomLayer(t=0, 1){
    x = xMaxBnd-bLayerThickness*(1-t);
    y = -Ly;
    label = labelBottom/*L*/;
  }

  border Top(t=0, 1){
    x = xMaxBnd-bLayerThickness-(Lx-bLayerThickness+xMaxBnd)*t; 
    y = Ly; 
    label = labelTop;
  }
  border TopLayer(t=0, 1){
    x = xMaxBnd-bLayerThickness*t;
    y = Ly;
    label = labelTop/*L*/;
  }

  border Left(t=0,1){
    x = -Lx;
    y = Ly*(1-2*t);
    label = labelLeft;
  }

  // change for a perturbed front, if needed. Mantain extreme points at x=0
  border Right(t=0,1){
    x = 0+Amp*cos(q*Ly*(2*t-1));
    y = Ly*(2*t-1);
    label = labelRight;
  }
  // border Inner(t=0,1){
  //   x = -bLayerThickness+Amp*cos(q*Ly*(2*t-1));
  //   y = Ly*(2*t-1);
  // }

  mesh Th = buildmesh(
    Bottom(ibd*(Lx-bLayerThickness))
    + BottomLayer(obd*bLayerThickness)
    + Right(obd*2.*Ly)
    /*+ Inner(obd*2.*Ly)*/
    + TopLayer(obd*bLayerThickness)
    + Top(ibd*(Lx-bLayerThickness))
    + Left(ibd*2.*Ly)
  );

  // Th = change(Th,rmInternalEdges=1);

  return Th;
}

func mesh bufferSinusoidalSemiplane(
  int bndDensity, real[int] meshParameters, int[int] labels 
){
  /*
  [mesh] meshSemiplaneBufferSinusoidal returns a rectangular mesh with a 
  centered single sinusoidal finger on its left side.

  Parameters:
    - int bndDensity: boundary density, num. of points per unit lenght at the boundary.
    - real[int] meshParameters: parameters that define the shape. By order:
      - 0, real Lx: width of the rectangle (x-axis). The total x-length is 
      Lx+2*Amp.
      - 1, real waveLength: wavelength of the sinusoidal finger.
      - 2, real Amp: amplitude of the sinusoidal finger. Take into account 
      that the finger overtakes the base rectangle by 2*Amp, as it runs for 
      a full wavelength. 
      - 3, real buff: finger buffer length. The sinusoidal finger is buffered
      both top and bottom by straigth lines of length wavelength*buff/2.
  - int[int] labels: labels of the different sides. labels[0] maks the bottom
  [1] marks the top, both periodic boundaries, [2] marks the right free 
  boundary and [3], the left fixed one.

  * Return type: mesh
  */

  // Unpack mesh parameters
  real Lx = meshParameters[0];
  real waveLength = meshParameters[1];
  real Amp = meshParameters[2];
  real buff = meshParameters[3];

  // Unpack labels 
  int labelBottom = labels[0];  // 1st periodic boundary (Bottom)
  int labelTop = labels[1];     // 2nd periodic boundary (Top)
  int labelRight = labels[2];   // Free boundary (right)
  int labelLeft = labels[3];    // Fixed boundary, opposed to the free one (left)

  // Defien the borders for both the bulk and the layer meshes
  border Bottom(t=0, 1){
    x = Lx*(t-1); 
    y = -(waveLength*(1+buff)/2);
    label = labelBottom;
  }

  border Top(t=0, 1){
    x = 0-Lx*t; 
    y = (waveLength*(1+buff)/2); 
    label = labelTop;
  }

  border Left(t=0,1){
    x = -Lx;
    y = (waveLength*(1+buff)/2)*(1-2*t);
    label = labelLeft;
  }

  // change for a perturbed front, if needed. Mantain extreme points at x=0

  border RightBuffBottom(t=0,1){
    x = 0;
    y = (waveLength/2.)*(buff*(t-1)-1);
    label = labelRight;
  }

  border RightBuffTop(t=0,1){
    x = 0;
    y = (waveLength/2.)*(1+buff*t);
    label = labelRight;
  }

  border RightFinger(t=0,1){
    x = Amp*(cos(pi*(2*t-1))+1);
    y = waveLength*(t-1/2.);
    label = labelRight;

  }
  
  mesh Th = buildmesh(
   Bottom(bndDensity*Lx)
    + RightBuffBottom(bndDensity*waveLength*(buff/2.))
    + RightFinger(bndDensity*waveLength)
    + RightBuffTop(bndDensity*waveLength*(buff/2.))
    + Top(bndDensity*Lx)
    + Left(bndDensity*waveLength*(1+buff))
  );

  return Th;
}
