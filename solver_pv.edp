// Packages for advanced remeshing scheme
load "Curvature"
load "distance"
load "isoline"
load "gsl"

// include <iostream>; // If needed
include "parameters_sets/parameters_poster_runs.edp";
// include "tests/parameters.edp";

string simulName;
string simulHomeDir;

// Mesh identifiers
int labelOut = 1;

// func mesh fourCurveShape(int obd, real rUp, real rDown, real rLeft,real rRight, real d, real symmAxis, int labelOut){

// 	mesh Th; // Final mesh (Th)

// 	if (((d+rUp-rDown-2*rRight) <= 0) || ((d+rUp-rDown-2*rLeft) <= 0)) {
// 		cout << "ERROR: d + rUp - rDown - 2*(rRight and rLeft) > 0" << endl;
// 		return Th;
// 	}

//   real thetaDownRight = acos((pow((rDown+rRight),2)+pow(d,2)-pow((rUp-rRight),2))/(2*(rDown+rRight)*d));
//   real thetaDownLeft = acos((pow((rDown+rLeft),2)+pow(d,2)-pow((rUp-rLeft),2))/(2*(rDown+rLeft)*d));
//   real thetaUpRight = acos((pow((rDown+rRight),2)-pow(d,2)-pow((rUp-rRight),2))/(2*(rUp-rRight)*d));
//   real thetaUpLeft = acos((pow((rDown+rLeft),2)-pow(d,2)-pow((rUp-rLeft),2))/(2*(rUp-rLeft)*d));
// 	real thetaRight = acos((pow(d,2)-pow((rUp-rRight),2)-pow(rDown+rRight,2))/(2*(rUp-rRight)*(rDown+rRight)));
// 	real thetaLeft = acos((pow(d,2)-pow((rUp-rLeft),2)-pow(rDown+rLeft,2))/(2*(rUp-rLeft)*(rDown+rLeft)));

//   real xRight = -(d*(pow(d,2) - (rDown + 2*rRight - rUp)*(rDown + rUp))*cos(symmAxis) -
//     sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rRight - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*sin(symmAxis))/(2*pow(d,2));
//   real yRight = -(d*(pow(d,2) - (rDown + 2*rRight - rUp)*(rDown + rUp))*sin(symmAxis) +
// 		sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rRight - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*cos(symmAxis))/(2*pow(d,2));

// 	real xLeft = -(d*(pow(d,2) - (rDown + 2*rLeft - rUp)*(rDown + rUp))*cos(symmAxis) +
//     sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rLeft - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*sin(symmAxis))/(2*pow(d,2));
//   real yLeft = -(d*(pow(d,2) - (rDown + 2*rLeft - rUp)*(rDown + rUp))*sin(symmAxis) -
// 		sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rLeft - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*cos(symmAxis))/(2*pow(d,2));


//   // Define the borders without mesh adaptation
// 	border rightArch(t=0, 1){
//     x = xRight + rRight*cos((symmAxis-thetaUpRight-thetaRight)+thetaRight*t);
//     y = yRight + rRight*sin((symmAxis-thetaUpRight-thetaRight)+thetaRight*t);
//     label = labelOut;}

//   border upArch(t=0, 1){
//     x = rUp*cos((symmAxis-thetaUpRight)+(thetaUpLeft+thetaUpRight)*t);
//     y = rUp*sin((symmAxis-thetaUpRight)+(thetaUpLeft+thetaUpRight)*t);
//     label = labelOut;}

// 	border leftArch(t=0, 1){
//     x = xLeft + rLeft*cos((symmAxis+thetaUpLeft)+thetaLeft*t);
//     y = yLeft + rLeft*sin((symmAxis+thetaUpLeft)+thetaLeft*t);
//     label = labelOut;}
	
//   border downArch(t=0,1){
//     x = -d*cos(symmAxis)+rDown*cos((symmAxis+thetaDownLeft)-(thetaDownLeft+thetaDownRight)*t);
//     y = -d*sin(symmAxis)+rDown*sin((symmAxis+thetaDownLeft)-(thetaDownLeft+thetaDownRight)*t);
//     label = labelOut;}

//   Th = buildmesh(
// 		rightArch(obd*rRight*thetaRight)
//     + upArch(obd*rUp*(thetaUpLeft+thetaUpRight))
//     + leftArch(obd*rLeft*thetaLeft)
// 		+ downArch(obd*rDown*(thetaDownLeft+thetaDownRight))
// 	);

//   return Th;
// }

func mesh oneCutSmooth(int obd, real cut,real r0, real rArch, real symmAxis, int labelOut){
	// Perturbations of the circular domain with 1 cut, smoth with 1/f = 0

	real cutAxis = symmAxis+pi;
  real t1 = asin((sin(cut/2.)-(rArch/r0))/(1-(rArch/r0)));

	// cout << "R0 = " << r0 << ", RArc = " << rArch << ", cut axis = " << cutAxis << endl;
	// cout << "theta1 = " << t1 << endl;

	real OxRight = (r0-rArch)*cos(cutAxis+t1);
	real OyRight = (r0-rArch)*sin(cutAxis+t1);
	real OxLeft = (r0-rArch)*cos(cutAxis-t1);
	real OyLeft = (r0-rArch)*sin(cutAxis-t1);
	real lenCut = sqrt((OxRight-OxLeft)*(OxRight-OxLeft) + (OyRight-OyLeft)*(OyRight-OyLeft));

	// cout << "O_right = (" << OxRight <<", "<< OyRight <<"); O_left = (" << OxLeft <<", "<< OyLeft <<"); lenCut = " << lenCut << endl;

  border GammaArchLeft(t=0,1){x=OxLeft+rArch*cos(cutAxis-t1*(1-t)); y=OyLeft+rArch*sin(cutAxis-t1*(1-t)); label=labelOut;}
	border GammaCut(t=0,1){x=((OxLeft+rArch*cos(cutAxis))+(OxRight-OxLeft)*t);
													y=((OyLeft+rArch*sin(cutAxis))+(OyRight-OyLeft)*t);label=labelOut;}
	border GammaArchRight(t=0,1){x=OxRight+rArch*cos(cutAxis+t1*t); y=OyRight+rArch*sin(cutAxis+t1*t); label=labelOut;}
	border GammaArchFront(t=0,1){x=r0*cos(cutAxis+t1+2*(pi-t1)*t);
													 y=r0*sin(cutAxis+t1+2*(pi-t1)*t);label=labelOut;}

	mesh Th=buildmesh(GammaArchLeft(obd*rArch*t1)
							+GammaCut(obd*lenCut)
							+GammaArchRight(obd*rArch*t1)
							+GammaArchFront(obd*r0*2*(pi-t1))
							);

	return Th;
}

//Macros
macro pD [pDx, pDy]																// P2 extension for Dirichlet data
macro p [px, py]																	// Polarity vector field
macro q [qx, qy]																	// Polarity test functions
macro v [vx, vy]																	// Velocity vector field
macro u [ux, uy]																	// Velocity test functions

macro dp [dpxdx,dpxdy,dpydx,dpydy]								// Gradient of the polarity field
macro dq [dqxdx,dqxdy,dqydx,dqydy]								// Gradient of the polarity test functions
macro dv [dvxdx,dvxdy,dvydx,dvydy]								// Gradient of the velocity field
macro du [duxdx,duxdy,duydx,duydy]								// Gradient of the velocity test functions
			
macro grad(u) [dx(u),dy(u)]												// Gradient of a sclar
macro Grad(ux,uy) [dx(ux),dy(ux),dx(uy),dy(uy)]		// Gradient of a vector
macro GradT(ux,uy) [dx(ux),dx(uy),dy(ux),dy(uy)]	// Grad vector transpose
macro pp(px,py) [px*px,px*py,py*px,py*py]					// Active stress tensor

for (int i=0; i<nSimul; i++){
	simulName = simulNames[i];

	real cut = cuts[i];

	// real rUp = 1;
	// real rDown = rDownFracs[i]*rUp;
	// real rLeft = rLeftFracs[i]*rUp;
	// real rRight = rRightFracs[i]*rUp;
	// real d = dFracs[i]*rUp;
	// real symmAxis = symmAxes[i];

	// mesh Th = fourCurveShape(obd,rUp,rDown,rLeft,rRight,d,symmAxis,labelOut);
	// mesh Th = oneCutSmooth(obd,cut,1,fracRarc,symmAxis,labelOut);
	// real areaCst = Th.measure;

	// Problem length & timescales
	real R0 = Reffs[i]; 		 				 // Initial adimensionalized radius
	real lambda = sqrt(eta/xi); 		 // hydrodynamic sceening length
	real La = abs(zeta)/zi; 				 // active length; < 0 (> 0) for contractile (extensile) active stresses
	// real Lc 											 // nematic length, defined in the parameters file
	real tscale = eta/(zi*Lc[i]); 	 // Problem timescale
	// real R0 = sqrt(pi/areaCst); 		 // Adimensionalized radius so that adim Area = pi
	// real lambda = sqrt(eta/xi); 		 // hydrodynamic sceening length
	// real La = abs(zeta)/zi; 				 // active length; < 0 (> 0) for contractile (extensile) active stresses
	// // real Lc 											 // nematic length, defined in the parameters file
	// real tscale = eta/(zi*Reffs[i]); // Problem timescale

  // Problem Parameters
  real a = La/Lc[i]; 			// Active length, zeta/zi, and effective radius ratio
  real b = Reffs[i]/lambda;		// Effective radius and hydrodynamic length, sqrt(eta/xi), ratio
  real c = Reffs[i]/Lc[i];  		 			// Effective radius and nematic length ratio
	real bLayerThickness = 1/c;	// Adim. nematic length

	mesh Th = oneCutSmooth(obd,cut,1,fracRarc,symmAxis,labelOut);
	// Th = oneCutSmooth(obd,cut,R0,R0*fracRarc,symmAxis,labelOut);

	// FEM Spaces
	fespace Dh(Th, P1); // For distance function (remeshing scheme) and data exports

	func mesh closedRemesh(mesh Th0,int obd, int ibd, int labelOut, real smoothCoef){

		int[int] be(1); // To save begin and ends of the curve
		int minPoints = 5;

		// Extract outer boundary
		real[int,int] bOut(3,1); real lOut = extractborder(Th0, labelOut, bOut);

		// Remesh the outr boundary using an Akima spline
		gslspline splineX(gslinterpakima, bOut(2,:), bOut(0,:));
		gslspline splineY(gslinterpakima, bOut(2,:), bOut(1,:));

		border Out(t=0,lOut){x=splineX(t); y=splineY(t); label=labelOut;}
		int nOut = round(obd*lOut);

		// Distance function (d is the minimal distance to the boundary)
		varf vong(B, d)= on(labelOut,B=1);
		real[int] ong=vong(0,Dh);
		Dh B =1, d;
		B[] = ong ? 0 : B[];
		distance(Th0,B,d[]);
		// plot(d,Th0, wait=1);

		// Get the new inner boundary vertices (ISO is the contour d==bLayerThickness)
		real[int,int] ISO(3,1); int nc=isoline(Th0,d,iso=bLayerThickness,close=0,ISO,beginend=be,smoothing=bLayerThickness*smoothCoef,ratio=1.e0);
		int nInnerLoops = be.n/2;
		// cout << be << endl;

		int[int] nInner(nInnerLoops); // numer of points per loop
		int nCorrectLoops = 0; // number of loops with more than minPoints
		// find number of points and count > minPoints
		for (int i=0;  i < nInnerLoops; i++){
			real lInner=ISO(2,be(i*2+1)-1);
			nInner[i] = round(ibd*lInner);
			if(nInner[i] > minPoints){nCorrectLoops++;}
		}

		// if the number of points is less than minPoints, filter the border for safety
		int[int] nInnerFilter(nCorrectLoops);
		int[int] beFilter(2*nCorrectLoops);

		for (int i=0;  i < nInnerLoops; i++){
			if(nInner[i] > minPoints){
				nInnerFilter[i] = nInner[i];
				beFilter[2*i] = be[i*2];
				beFilter[2*i+1] = be[i*2+1];
			}
		}
		
		border Inner(t=0,1;i) {P=Curve(ISO,beFilter(i*2),beFilter(i*2+1)-1,t);} // Inner boundary multi-border
		// cout << nInner << endl;

		// plot(Out(nOut),Inner(nInnerFilter)/*, wait=1*/
		try {
      mesh Th = buildmesh(Out(nOut)+Inner(nInnerFilter));
			Th = change(Th, rmInternalEdges=1);
      return Th;
    }
    catch(...){
      cout << "MESH ERROR"<< endl;
      break;
    }
	}

	Th = closedRemesh(Th,obd,ibd,labelOut,.5);

	// // Initial variables for shape characterization
	real Area0 = Th.measure; // Inital Area of the Fluid Domain
  real Xcm0 = int2d(Th)(x)/Area0; //Initial x_cm
  real Ycm0 = int2d(Th)(y)/Area0; //Initial y_cm
	real areaCst = Area0;

	if (bsave){
		simulHomeDir = rootDir+"/"+simulName;
		string fileNameParams = "/params.csv";
		string fileNameGlobalSol = "/global_sol.csv";

		exec("mkdir "+simulHomeDir);							// Make a home directory for the simulation
		exec("mkdir "+simulHomeDir+"/msh");				// Make and save the meshes in a separeted directory
		exec("mkdir "+simulHomeDir+"/local_sol");	// Make and save the local solutions in a separeted directory

		{ofstream fileParams (simulHomeDir+fileNameParams); // Save the parameters in separate file

      fileParams.fixed;
			fileParams << "cut,R0,Reff,fracRarc,areaCst,h,Lc,lambda,La,eta,xi,zi,zeta,tscale,dt,dsave" /*<< ",gamma"*/ <<  endl;
			fileParams << "rad,adim,um,adim,adim,um,um,um,um,kPa*s,kPa*s/um^2,kPa/um,kPa,s,adim,adim,R0Lc_adim" /*<< ",kPa*um"*/ << endl;
			fileParams << cut 		<< "," << R0 		 << "," << Reffs[i] << "," << fracRarc << ","
								 << areaCst << "," << h 		 << "," << Lc[i] 		<< "," << lambda 	 << ","
								 << La 			<< "," << eta 	 << "," << xi 			<< "," << zi 			 << "," 
								 << zeta 		<< "," << tscale << "," << dt 			<< "," << dsave /*<< "," << gamma*/ << endl;// 
    }

  	{ofstream fileGlobalSol (simulHomeDir+fileNameGlobalSol);	// Generate a separate file for the global variables (integrates ones)
  		//fileGlobalSol.fixed;
			fileGlobalSol	<< "Time,Xcm,Ycm,Pxcm,Pycm,dPxcmdt,dPycmdt,Vxcm,Vycm,Axcm,Aycm,Area,dAreadt,Ix,Iy,dIxdt,dIydt,avgDivV,divTermsX,divTermsY" << endl;
  	}
	}


  cout << "Simul: " << simulName << ", saving = " << bsave << "\nReff = " << Reffs[i] /*<< ", Rc = " << Rc*/
	<< ", lambda = " << lambda << ", Lc = " << Lc[i] << ", La = " << La << ", tscale = " << tscale << endl;

  if (verbosity) {
  	plot(Th,value = true, fill = false, nbiso=64, wait=true, cmm = "adaptive mesh;  A0="+Area0+",  (xcm0,yxm0)=("+Xcm0+","+Ycm0+")");
  }

  //FEM spaces
  fespace Pol(Th, [P2, P2]);					// For polarity vector
  fespace Pola(Th, P2 );	// For |p| (not essential, just visualization)
	fespace dPol(Th,[P2,P2,P2,P2]);			// For the gradient of the polarity vector
  fespace Vel(Th, [P1b, P1b]);				// For velocity vector
  fespace dVel(Th,[P1b,P1b,P1b,P1b]);	// For the gradient of the velocity vector
	// fespace Dh(Th, P1);								  // For distance function (remeshing scheme) and data exports
  // fespace Vor(Th,P1b);								// To compute the vorticity & divergence
  fespace Nh(Th,[P1,P1]);						  // For the corrected normal vector at the boundary

  // Correction of the normal vectors at the boundary
  int NbBoundaryElements = Th.nbe;
  int[int] bcon(NbBoundaryElements);
  real[int] xx(NbBoundaryElements+1),yy(NbBoundaryElements+1);
  for (int k = 0; k < NbBoundaryElements; k++){
           bcon[k] = Th.be(k)[0];
  	 xx[k]=Th(Th.be(k)[0]).x; yy[k]=Th(Th.be(k)[0]).y;
  }
  xx[NbBoundaryElements]=xx[0]; yy[NbBoundaryElements]=yy[0];

  Nh [nx,ny]; // here the Dof of nx,ny are scramble .
  nx[]=0;ny[]=0;

  real[int] nprev(2), npost(2), nmean(2);
  real lenprev, lenpost;
  nprev = [(yy[0]-yy[NbBoundaryElements-1]),-(xx[0]-xx[NbBoundaryElements-1])];
  lenprev = sqrt(pow(nprev[0],2)+pow(nprev[1],2));

  for (int k = 0; k < NbBoundaryElements; k++){
    npost = [(yy[k+1]-yy[k]),-(xx[k+1]-xx[k])];
    lenpost = sqrt(pow(npost[0],2)+pow(npost[1],2));

    nmean = nprev/(1+lenprev/lenpost) + npost/(1+lenpost/lenprev);
    nmean /= sqrt(pow(nmean[0],2)+pow(nmean[1],2));

  	nx[](2*bcon(k))= nmean[0]; ny[](2*bcon(k)+1) = nmean[1];
  	nprev = npost; lenprev = lenpost;
  }

  // P2 extension of polarity Dirichlet data
  varf bndDirichlet(pD, q) = on(labelOut, pDx = nx) + on(labelOut, pDy = ny);// + on(labelOut, px = N.x) + on(labelOut, py = N.y);
  Pol pD=[0,0];
  pDx[] = bndDirichlet(0, Pol, tgv = 1.0);

  if (verbosity) {
  	plot(pDx, value = true, fill = true, nbiso=64, wait=true, cmm = "pDx");
  	plot(pDy, value = true, fill = true, nbiso=64, wait=true, cmm = "pDy");
  }
  // Bilinear and linear variational forms P (Modified Homogeneous Drirchlet problem for p-pD)
  varf ap(p, q) = int2d(Th)(  grad(px)'*grad(qx) + grad(py)'*grad(qy) )  + int2d(Th)(c*c*(p'*q)) + on(labelOut, px = 0.0) + on(labelOut, py = 0.0);
  varf lp(p, q) = -int2d(Th)( grad(pDx)'*grad(qx) + grad(pDy)'*grad(qy) ) - int2d(Th)(c*c*(pD'*q))  + on(labelOut, px = 0.0) + on(labelOut, py = 0.0);

  // Assembly P
  matrix Ap = ap(Pol, Pol, tgv = -2); // LHS matrix
  real[int] bp = lp(0, Pol); // RHS

  // P solution with vanishing Dirichlet data
  real[int] solP(Pol.ndof);
  //set(Ap,solver=sparsesolver);
  solP=Ap^-1*bp;
  Pol p=[0,0];
  px[]=solP(0:Pol.ndof-1);

  if (verbosity) {
  	plot(Th,px, value = true, fill = true, nbiso=64, wait=true, cmm = "dpx = px-pDx");
  	plot(Th,py, value = true, fill = true, nbiso=64, wait=true, cmm = "dpy = py-pDy");
  }

  // P solution
  p = p + pD;

	// Compute the gradient of p for the posterior analysis
  varf aGradP(dp, dq) = int2d(Th)(dp'*dq);
  varf lGradP(dp, dq) = int2d(Th)(Grad(px,py)'*dq);

  matrix AGradP = aGradP(dPol, dPol);		// LHS matrix
  real[int] bGradP = lGradP(0, dPol);	// RHS vector

  real[int] solGradP(dPol.ndof);
  solGradP=AGradP^-1*bGradP;
  dPol dp=[0,0,0,0];
  dpxdx[]=solGradP(0:dPol.ndof-1);

  if (verbosity) {
  	plot(Th,px, value = true, fill = true, nbiso = 64, wait = true, cmm = "px");
    plot(Th,py, value = true, fill = true, nbiso = 64, wait = true, cmm = "py");
  	plot(Th,p, value = true, fill = true, nbiso = 64, wait = true, cmm = "(px,py)");
		Pola pABS = sqrt(px(x,y)^2 + py(x,y)^2); // Abs(P)
		Pola divP = dpxdx(x,y)+dpydy(x,y);
		Pola rotP = dpydx(x,y)-dpxdy(x,y);
  	plot(Th,pABS, value = true, fill = true, nbiso = 64, wait = true, cmm = "|p|");
		plot(Th,divP, value = true, fill = true, nbiso = 64, wait = true, cmm = "Div(p)");
  	plot(Th,rotP, value = true, fill = true, nbiso = 64, wait = true, cmm = "Curl(p)");
  }

  // Bilinear and linear variational forms V
  varf av(v, u) = int2d(Th)( ((Grad(vx,vy)+GradT(vx,vy))'*Grad(ux,uy)) )  + int2d(Th)( b*(v'*u) ); // -viscosity -friction
  varf lv(v, u) = int2d(Th)( -a*(pp(px,py)'*Grad(ux,uy)) ) + int2d(Th)( c*(p'*u) ); //contractility +active traction

  // Assembly V
  matrix Av = av(Vel, Vel);
  real[int] bv = lv(0, Vel);

  // V solution
  real[int] solV(Vel.ndof);
  //set(Av,solver=sparsesolver);
  solV=Av^-1*bv;
  Vel v=[0,0];
  vx[]=solV(0:Vel.ndof-1);

  // Compute the gradient of v for the posterior analysis
  varf aGradV(dv, du) = int2d(Th)(dv'*du);
  varf lGradV(dv, du) = int2d(Th)(Grad(vx,vy)'*du);

  matrix AGradV = aGradV(dVel, dVel);		// LHS matrix
  real[int] bGradV = lGradV(0, dVel);	// RHS vector

  real[int] solGradV(dVel.ndof);
  solGradV=AGradV^-1*bGradV;
  dVel dv=[0,0,0,0];
  dvxdx[]=solGradV(0:dVel.ndof-1);

	// Compute the intial values of the global variables
  real Areai = Area0;	// Current area
	real AreaP = Areai;	// Previous area
	real dAreadt = (Areai-AreaP)/dt; // time-derivative of the area (backward)

	real Xcm = Xcm0; // Current x of the center of mass (x_cm)
	real Ycm = Ycm0; // Current y of the center of mass (y_cm)
  real[int] XcmP = [Xcm0,Xcm0]; // Previous x_cms (-dt & -2*dt)
	real[int] YcmP = [Ycm0,Ycm0]; // Previous y_cms (-dt & -2*dt)
	real Vxcm = (Xcm-XcmP[0])/dt; // Center of mass x velocity (backward)
	real Vycm = (Ycm-YcmP[0])/dt; // Center of mass y velocity (backward)
	real Axcm = (Xcm-2.*XcmP[0]+XcmP[1])/pow(dt,2); // Center of mass x acceleration (2nd order backward)
	real Aycm = (Ycm-2.*YcmP[0]+YcmP[1])/pow(dt,2); // Center of mass y acceleration (2nd order backward)

	real Pxcm = int2d(Th)(px)/Areai; // Current P_x cm
	real Pycm = int2d(Th)(py)/Areai; // Current P_y cm
	real PxcmP = Pxcm; // Previous P_x cm
	real PycmP = Pycm; // Previous P_y cm
	real dPxcmdt = (Pxcm-PxcmP)/dt; // time-derivative of P_x cm (backward)
	real dPycmdt = (Pycm-PycmP)/dt; // time-derivative of P_y cm (backward)

	real Ix = int2d(Th)(pow(y-Ycm,2))/Areai;	// Current 2nd Moment of area with respect to x axis at the CM
	real Iy = int2d(Th)(pow(x-Xcm,2))/Areai;	// Current 2nd Moment of area with respect to y axis at the CM
	real IxP = Ix; // Previous 2n Moment of x
	real IyP = Iy; // Previous 2n Moment of y
	real dIxdt = (Ix-IxP)/dt; // time-derivative of Ix (backward)
	real dIydt = (Iy-IyP)/dt; // time-derivative of Iy (backward)

	real avgDivV = int2d(Th)(dvxdx+dvydy)/Areai; // Average divergergence of the velocity
	real divTermsX = int2d(Th)(x*((dvxdx+dvydy)-avgDivV))/Areai;	// Current value of the Div terms of V_x cm
	real divTermsY = int2d(Th)(y*((dvxdx+dvydy)-avgDivV))/Areai;	// Current value of the Div terms of V_y cm


  if (verbosity) {
  	plot(Th,vx, value = true, fill = true, nbiso = 64, wait = true, cmm = "vx");
    plot(Th,vy, value = true, fill = true, nbiso = 64, wait = true, cmm = "vy");
  	plot(Th,v, value = true, fill = true, nbiso = 64, wait = true, cmm = "(vx,vy)");
		Pola vABS = sqrt(vx(x,y)^2 + vy(x,y)^2); // Abs(P)
		Pola divV = dvxdx(x,y)+dvydy(x,y);
		Pola rotV = dvydx(x,y)-dvxdy(x,y);
  	plot(Th,vABS, value = true, fill = true, nbiso = 64, wait = true, cmm = "|v|");
		plot(Th,divV, value = true, fill = true, nbiso = 64, wait = true, cmm = "Div(v)");
  	plot(Th,rotV, value = true, fill = true, nbiso = 64, wait = true, cmm = "Curl(v)");
  }

  // Iterate time
  for (int iterTime=0 ; iterTime<NiterTime ; iterTime++) {

  	if (iterTime % 100 == 0 && iterTime > 0) {
  		cout << iterTime << " out of " << NiterTime << " iterations completed" << endl;
  	}

  	// Correction of the normal vectors at the boundary
  	int NbBoundaryElements = Th.nbe;
  	int[int] bcon(NbBoundaryElements);
  	real[int] xx(NbBoundaryElements+1),yy(NbBoundaryElements+1);
  	for (int k = 0; k < NbBoundaryElements; k++){
  	         bcon[k] = Th.be(k)[0];
  		 xx[k]=Th(Th.be(k)[0]).x; yy[k]=Th(Th.be(k)[0]).y;
  	}
  	xx[NbBoundaryElements]=xx[0]; yy[NbBoundaryElements]=yy[0];

  	Nh [nx,ny]; // here the Dof of nx,ny are scramble .
  	nx[]=0;ny[]=0;

    real[int] nprev(2), npost(2), nmean(2);
	  real lenprev, lenpost;
	  nprev = [(yy[0]-yy[NbBoundaryElements-1]),-(xx[0]-xx[NbBoundaryElements-1])];
	  lenprev = sqrt(pow(nprev[0],2)+pow(nprev[1],2));

	  for (int k = 0; k < NbBoundaryElements; k++){
	    npost = [(yy[k+1]-yy[k]),-(xx[k+1]-xx[k])];
	    lenpost = sqrt(pow(npost[0],2)+pow(npost[1],2));

	    nmean = nprev/(1+lenprev/lenpost) + npost/(1+lenpost/lenprev);
	    nmean /= sqrt(pow(nmean[0],2)+pow(nmean[1],2));

	  	nx[](2*bcon(k))= nmean[0]; ny[](2*bcon(k)+1) = nmean[1];
	  	nprev = npost; lenprev = lenpost;
	  }

  	// P2 extension of polarity Dirichlet data
  	varf bndDirichlet(pD, q) = on(labelOut, pDx = nx) + on(labelOut, pDy = ny);// + on(2, p1 = N.x) + on(2, p2 = N.y);
  	Pol pD=[0,0];
  	pDx[] = bndDirichlet(0, Pol, tgv = 1.0);

  	// Assembly P
  	varf lp(p, q) = -int2d(Th)( grad(pDx)'*grad(qx) + grad(pDy)'*grad(qy) ) - int2d(Th)(c*c*(pD'*q))  + on(labelOut, px = 0.0) + on(labelOut, py=0.0);
  	matrix Ap = ap(Pol, Pol, tgv = -2); 	// LHS matrix
  	real[int] bp = lp(0, Pol); 			// RHS

  	// P solution with vanishing Dirichlet data
  	real[int] sol(Pol.ndof);
  	//set(Ap,solver=sparsesolvenetr);
  	sol=Ap^-1*bp;
  	Pol p=[0,0];
  	px[]=sol(0:Pol.ndof-1);

  	// P solution
  	p = p + pD;

  	// Compute the gradient of p for the posterior analysis
		varf aGradP(dp, dq) = int2d(Th)(dp'*dq);
		varf lGradP(dp, dq) = int2d(Th)(Grad(px,py)'*dq);

		matrix AGradP = aGradP(dPol, dPol);		// LHS matrix
		real[int] bGradP = lGradP(0, dPol);	// RHS vector

		real[int] solGradP(dPol.ndof);
		solGradP=AGradP^-1*bGradP;
		dPol dp=[0,0,0,0];
		dpxdx[]=solGradP(0:dPol.ndof-1);

  	// Assembly V
  	varf lv(v, u) = int2d(Th)( -a*(pp(px,py)'*Grad(ux,uy)) ) + int2d(Th)( c*(p'*u) ); //contractility + active traction
  	matrix Av = av(Vel, Vel);  			// LHS matrix
  	real[int] bv = lv(0, Vel);			// RHS

  	// V solution
  	real[int] solV(Vel.ndof);
  	//set(Av,solver=sparsesolver);
  	solV=Av^-1*bv;
  	Vel v=[0,0];
  	vx[]=solV(0:Vel.ndof-1);

  	// Compute the gradient of v for the posterior analysis
		varf aGradV(dv, du) = int2d(Th)(dv'*du);
		varf lGradV(dv, du) = int2d(Th)(Grad(vx,vy)'*du);

		matrix AGradV = aGradV(dVel, dVel);		// LHS matrix
		real[int] bGradV = lGradV(0, dVel);	// RHS vector

		real[int] solGradV(dVel.ndof);
		solGradV=AGradV^-1*bGradV;
		dVel dv=[0,0,0,0];
		dvxdx[]=solGradV(0:dVel.ndof-1);

		// Compute the global variables
		Areai = Th.measure;	// Current area
		dAreadt = (Areai-AreaP)/dt; // time-derivative of the area (backward)

		Xcm = int2d(Th)(x)/Areai;	// Current Xcm
		Ycm = int2d(Th)(y)/Areai;	// Current Ycm
		Vxcm = (Xcm-XcmP[0])/dt; // Center of mass x velocity (backward)
		Vycm = (Ycm-YcmP[0])/dt; // Center of mass y velocity (backward)
		Axcm = (Xcm-2.*XcmP[0]+XcmP[1])/pow(dt,2); // Center of mass x acceleration (2nd order backward)
		Aycm = (Ycm-2.*YcmP[0]+YcmP[1])/pow(dt,2); // Center of mass y acceleration (2nd order backward)

		Pxcm = int2d(Th)(px)/Areai;	// Current P_x cm
		Pycm = int2d(Th)(py)/Areai;	// Current P_y cm
		dPxcmdt = (Pxcm-PxcmP)/dt; // time-derivative of P_x cm (backward)
		dPycmdt = (Pycm-PycmP)/dt; // time-derivative of P_y cm (backward)
		
		Ix = int2d(Th)(pow(y-Ycm,2));	// 2nd Moment of area with respect to x axis at the CM
		Iy = int2d(Th)(pow(x-Xcm,2));	// 2nd Moment of area with respect to y axis at the CM
		dIxdt = (Ix-IxP)/dt; // time-derivative of Ix (backward)
		dIydt = (Iy-IyP)/dt; // time-derivative of Iy (backward)

		avgDivV = int2d(Th)(dvxdx+dvydy)/Areai;								// Average divergergence of the velocity
		divTermsX = int2d(Th)(x*(dvxdx+dvydy-avgDivV))/Areai;	// Current value of the Div terms of V_x cm
		divTermsY = int2d(Th)(y*(dvxdx+dvydy-avgDivV))/Areai;	// Current value of the Div terms of V_y cm

  	// Plot v
  	// if (verbosity) { // Show it always, regardless of the verbosity
  	Pola vABS = sqrt(vx(x,y)^2 + vy(x,y)^2);
  		plot(/*Th,[NDerP1,NDerP2],/*CurlV*/vABS, value = true, fill = true, nbiso = 64, wait = false, bb=[[-2,-2],[2,2]],
  				cmm = "t="+(dt*iterTime)+";  A/A0="+(Areai/Area0)+", (xcm,yxm)-(xcm0,yxm0)=("+(Xcm-Xcm0)+","+(Ycm-Ycm0)
  											+"), (vx,vy)=("+Vxcm+","+Vycm+")"
  											+"), A^-1(c/b)int p=("+(c/b)*Pxcm+","+(c/b)*Pycm+")");
  	// }

  	// Export data
  	if(iterTime % dsave == 0 && bsave==1){

			string fileNameGlobalSol = "/global_sol.csv";
			string fileNameLocalSol = "/local_sol/sol_"+(1000000+iterTime)+".txt";
			string fileNameMsh = "/msh/mesh_"+(1000000+iterTime)+".msh";

  		// Save {px, py, vx, vy, dpxdx, dpxdy, dpydx, dpydy, dvxdx, dvxdy, dvydx, dvydy} on each vertex:
  		// Memory efficient method, but needs connectivity data to reconstruct the mesh
  		{ofstream fileLocalSols (simulHomeDir+fileNameLocalSol);
  			
				fileLocalSols.fixed;
  			int NbVertices = Th.nv;
  			fileLocalSols << "# LocalSolutions" << endl
											<< "# NumFields: " << 12 << "	NumberVertices: " << NbVertices /*<< " cut: " << cut*/ << " a: " << a << " b: " << b << " c: " << c << endl
  										<< "# px	py	vx	vy	dpxdx	dpxdy	dpydx	dpydy	dvxdx	dvxdy	dvydx	dvydy" << endl;
  			for (int i = 0; i < NbVertices; i++){
  				fileLocalSols << px(Th(i).x,Th(i).y) 		<< "	" << py(Th(i).x,Th(i).y) 		<< "	"  // {px,py}
												<< vx(Th(i).x,Th(i).y) 		<< "	" << vy(Th(i).x,Th(i).y) 		<< "	"	 // {vx,vy}
												<< dpxdx(Th(i).x,Th(i).y) << "	" << dpxdy(Th(i).x,Th(i).y) << "	"	 //	{dpxdx,dpxdy}
												<< dpydx(Th(i).x,Th(i).y) << "	" << dpydy(Th(i).x,Th(i).y) << "	"	 // {dpydx,dpydy}
												<< dvxdx(Th(i).x,Th(i).y) << "	" << dvxdy(Th(i).x,Th(i).y) << "	"	 // {dvxdx,dvxdy}
												<< dvydx(Th(i).x,Th(i).y) << "	" << dvydy(Th(i).x,Th(i).y) << endl; // {dvydx,dvydy}
  			}
  		}

  		// Save Global Data (variables integratet over the domain)
			{ofstream fileGlobalSol (simulHomeDir+fileNameGlobalSol, append);
				
				fileGlobalSol.fixed;
  			fileGlobalSol	<< iterTime*dt << "," << Xcm 		 << "," << Ycm 			<< "," << Pxcm 			<< "," << Pycm 			<< ","
											<< dPxcmdt 		 << "," << dPycmdt << "," << Vxcm 		<< "," << Vycm 			<< "," << Axcm 			<< ","
											<< Aycm 			 << "," << Areai 	 << "," << dAreadt 	<< "," << Ix 				<< "," << Iy 				<< ","
											<< dIxdt 			 << "," << dIydt 	 << "," << avgDivV 	<< "," << divTermsX << "," << divTermsY << endl;
  		}

      // save the last mesh
      savemesh(Th,simulHomeDir+fileNameMsh);
  	}
		try{
			// Move mesh
  	// real minT0 = checkmovemesh(Th, [x, y]); // to check for flipped triangles
  	// real minT = checkmovemesh(Th, [x+dt*vx,y+dt*vy]);
  	// cout << "Min triangle area before: "+minT0+" & after: "+minT<<endl;
  	Th = movemesh(Th,[x+dt*vx,y+dt*vy]);
		Th = closedRemesh(Th,obd,ibd,labelOut,.5);
		}
		catch(...) {
			cout << "ERROR: Simulation "+simulName+" stopped after "+iterTime+" iterations due to a remeshing error" << endl;
    //   break;
		}
  	

		// Update previous global variables
		AreaP = Areai;	// Previous area
		XcmP[1] = XcmP[0]; XcmP[0] = Xcm;	// Previous x_cms (-dt & -2*dt)
		YcmP[1] = YcmP[0]; YcmP[0] = Ycm;	// Previous y_cms (-dt & -2*dt)
		PxcmP = Pxcm; // Previous P_x cm
		PycmP = Pycm; // Previous P_y cm
		IxP = Ix; // Previous 2n Moment of x
		IyP = Iy; // Previous 2n Moment of y

    // if(Areai > rateMaxArea*Area0){
    //   cout << "WARNING: Simulation "+SimulName+" stopped after "+iterTime+" iterations due to large area" << endl;
    //   break;
    // }
  }
}
