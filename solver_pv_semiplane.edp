// Packages for advanced remeshing scheme
load "Curvature"
load "distance"
load "isoline"
load "gsl"

// Manage command-line arguments
include "getARGV.idp"

// include <iostream>; // If needed

int iSimul = getARGV("-i", 1);
bool debug = getARGV("-d", 1);
bool err = 0;

// include "parameters_sets/parameters_poster_runs.edp"; // load the parameters
include "lib/meshes.edp"; // load the mesh generation & remeshing functions
include "parameters_sets/parameters_semiplane_evolution.edp"; // load the parameters

// Construct the mesh ---------------------------------------------------------

// Mesh parameters
real[string] meshParameters;
meshParameters["amp"] = AmpList[iAmp];
meshParameters["lx"] = lx;
meshParameters["lFree"] = l0;
meshParameters["nFingers"] = nFinguers;

// Mesh labels
int[int] periodic = [1,3];
int[int] free = [2];
int[int] fixed = [4];

real eps = 1e-12; // numerical tolerance

func perio=[[periodic[0],x],[periodic[1],x]]; // Periodicity

// Generate the initial mesh
mesh Th = sinusoidalSemiplane(obd, meshParameters, free, fixed, periodic, l0, 1e12);

// Custom mesh adaptation
Th = periodicRemesh1FreeBnd(
  Th,obd,ibd,bLayerWidth,free,fixed, periodic,.5
);

// Initial variables for shape characterization
real Area0 = Th.measure; // Inital Area of the Fluid Domain
real Areai = Area0;

if (debug) {
  plot(
    Th, value = true, fill = false, nbiso=64, wait=true, 
    cmm = "adaptive mesh;  A0="+Area0
  );
}
//-----------------------------------------------------------------------------


// Problem physical parameters ------------------------------------------------
real Lc = LcList[iSimul];     // Nematic length [um].
real zeta = zetaList[iSimul]; // -Constractility [kPa].
real eta = etaList[iSimul];   // Viscosity [kPa·s].
real xi = xiList[iSimul];     // Friction [kPa·s/um²].
real zi = ziList[iSimul];     // Traction [kPa/um].

real lambda = sqrt(eta/xi);   // hydrodynamic sceening length.
real La = zeta/zi;            // active length; < 0 (> 0) for contractile (extensile) stress
real tscale = eta/(zi*Lc);    // Problem timescale
real vscale = l0/tscale;      // Problem velocity scale

// Problem Parameters
real a = La/Lc;          // Active length, zeta/zi, and effective radius ratio.
real b = l0/lambda;      // Effective radius and hydrodynamic length, sqrt(eta/xi), ratio.
real c = l0/Lc;          // Effective radius and nematic length ratio.
//-----------------------------------------------------------------------------


// Create folder structure, parameters' file & header of the global solutions'-
if (bsave){
  string simulHomeDir = rootDir+"/"+simulNames[iSimul];
  string fileNameParams = "/params.csv";
  string fileNameGlobalSol = "/global_sol.csv";

  // Make a home directory for the simulation.
  exec("mkdir "+simulHomeDir);

  // Make and save the meshes in a separeted directory.
  exec("mkdir "+simulHomeDir+"/msh");

  // Make and save the local solutions in a separeted directory.
  exec("mkdir "+simulHomeDir+"/local_sols");

  // Make and save the boundaries in a separeted directory.
  exec("mkdir "+simulHomeDir+"/free_bnd");

  {ofstream fileParams (simulHomeDir+fileNameParams); // Save the parameters in separate file

    fileParams.fixed;
    fileParams << "amp,l0,lx,nFingers,obd,ibd,bLayerWidth,Lc,lambda,La,eta,xi,zi,zeta,dt,tscale,vscale,dsave" << endl;
    fileParams << "um,um,um,adim,adim,adim,adim,um,um,um,kPa*s,kPa*s/um^2,kPa/um,kPa,s,s,um/s,adim" << endl;
    fileParams << amp         << "," << l0     << "," << lx        << ","
               << nFingers    << "," << obd    << "," << ibd       << "," 
               << bLayerWidth << "," << Lc     << "," << lambda    << ","
               << La          << "," << eta    << "," << xi        << ","
               << zi          << "," << zeta   << "," << tscale*dt << "," 
               << tscale      << "," << vscale << "," << dsave     << endl;
  }
  // Generate a separate file for the global variables (integrates ones)
  {ofstream fileGlobalSol (simulHomeDir+fileNameGlobalSol);  
    //fileGlobalSol.fixed;
    fileGlobalSols << "Global_Solutions" << endl
            << "Time,avgDivV,xMin,yMin,xMax,yMax,vxMin,vxMax,dVx,"
            << "x0,dx0dt,dx2dt,dx0dtNum,dx2dtNum" << endl
            << "tscale,1/tscale,R,R,R,R,R/tscale,R/tscale,R/tscale,"
            << "R,R/tscale,R^3/tscale,R/tscale,R^3/tscale," << endl;
  }
} 
//-----------------------------------------------------------------------------

// Console Log
cout << "Simul semiplane: " << simulNames[iSimul] 
     << ", saving = " << bsave << endl;
cout << "a (La/Lc) = " << a << ", b (l0/lambda) = " << b 
     << ", c (l0/Lc) = " << c << ", tscale = " << tscale << endl;  


// Define the macros ----------------------------------------------------------
macro pD [pDx, pDy] //                              // P2 extension for Dirichlet data
macro p [px, py] //                                 // Polarity vector field
macro q [qx, qy] //                                 // Polarity test functions
macro v [vx, vy] //                                 // Velocity vector field
macro u [ux, uy] //                                 // Velocity test functions
macro normal [nx, ny] //                            // Normal vectors on the non-periodic space
macro normalPerio [nxPerio, nyPerio] //             // Normal vectors on the periodic space

macro dp [dpxdx,dpxdy,dpydx,dpydy] //               // Gradient of the polarity field
macro dq [dqxdx,dqxdy,dqydx,dqydy] //               // Gradient of the polarity test functions
macro dv [dvxdx,dvxdy,dvydx,dvydy] //               // Gradient of the velocity field
macro du [duxdx,duxdy,duydx,duydy] //               // Gradient of the velocity test functions
macro d2px [dpxdxx,dpxdxy,dpxdyx,dpxdyy] //         // Hessian of the x-polarity
macro d2py [dpydxx,dpydxy,dpydyx,dpydyy] //         // Hessian of the y-polarity
macro d2qx [dqxdxx,dqxdxy,dqxdyx,dqxdyy] //         // Hessian of the x-polarity test function
macro d2qy [dqydxx,dqydxy,dqydyx,dqydyy] //         // Hessian of the y-polarity test 
      
macro grad(u) [dx(u),dy(u)] //                      // Gradient of a sclar
macro Grad(ux,uy) [dx(ux),dy(ux),dx(uy),dy(uy)] //  // Gradient of a vector
macro GradT(ux,uy) [dx(ux),dx(uy),dy(ux),dy(uy)] // // Grad vector transpose
macro Hessian(u) [dxx(u),dxy(u),dyx(u),dyy(u)] //   // Hessian of a scalar
macro pp(px,py) [px*px,px*py,py*px,py*py] //        // Active stress tensor

macro Norm(u) dist(u#x,u#y) + 1.e-12 //             // Vector norm + offset to avoid 0-length vectors
//-----------------------------------------------------------------------------

// FEM spaces -----------------------------------------------------------------
fespace Pol(Th, [P2, P2],periodic=perio);          // For polarity vector
fespace Pola(Th, P2,periodic=perio);               // For |p| (not essential, just visualization)
fespace dPol(Th,[P2,P2,P2,P2],periodic=perio);     // For the gradient of the polarity vector

fespace Vel(Th, [P1b, P1b],periodic=perio);        // For velocity vector
fespace dVel(Th,[P1b,P1b,P1b,P1b],periodic=perio); // For the gradient of the velocity vector
fespace prodVel(Th, P1b,periodic=perio);

//fespace Vor(Th,P1b);                               // To compute the vorticity & divergence
fespace Nh(Th,[P1,P1]);                              // For the corrected normal vector at the boundary & non-periodic geometry
fespace NhPerio(Th,[P1,P1],periodic=perio);          // For the corrected normal vector at the boundary & periodic geometry
//-----------------------------------------------------------------------------

// Extract the free boundary
// extractborder gives bFree(3,Th.nbe) with 1st point == last point
// for k in (0,Th.nbe-1): 
//    bFree(0,k) == x coord kth vertex
//    bFree(1,k) == y coord kth vertex
//    bFree(2,k) == arch length at the kth vertex
real[int,int] bFree(3,1); real sFree = extractborder(Th, free[0], bFree);
int nFree = bFree.m; // instead of Th.nbe to avoid problems with mesh labels

// Retrieve the indices of the verices of bFree with the same ordering --------
int[int] indicesFree(nFree);

int iTri;
for (int k=0; k<nFree; k++){
  // Find the triangle index of the kth bnd point
  iTri = Th(bFree(0,k),bFree(1,k)).nuTriangle;

  // Find index of the kth bnd point from its triangle index
  for (int jTri=0; jTri<3; jTri++) {
    if( abs(Th[iTri][jTri].x-bFree(0,k))<eps && abs(Th[iTri][jTri].y-bFree(1,k))<eps){
      indicesFree(k) = Th[iTri][jTri];
    }
  }
}

// Correction of the normal vectors at the boundary ---------------------------

Nh normal = [0,0]; // here the Dof of nx,ny are scramble.
NhPerio normalPerio = [0,0];

real[int] nprev(2), npost(2), nmean(2);
int iBndElem; // index of the boundary element
real lenprev, lenpost;
nprev = [(bFree(1,nFree-1)-bFree(1,nFree-2)),-(bFree(0,nFree-1)-bFree(0,nFree-2))];
lenprev = sqrt(pow(nprev[0],2)+pow(nprev[1],2));

for (int k = 0; k < nFree-1; k++){
  npost = [(bFree(1,k+1)-bFree(1,k)),-(bFree(0,k+1)-bFree(0,k))];
  lenpost = sqrt(pow(npost[0],2)+pow(npost[1],2));
  
  nmean = nprev*(lenpost/(lenpost+lenprev)) + npost*(lenprev/(lenprev+lenpost));
  nmean /= sqrt(pow(nmean[0],2)+pow(nmean[1],2));

  nx[](2*indicesFree(k))= nmean[0]; ny[](2*indicesFree(k)+1) = nmean[1];
  nprev = npost; lenprev = lenpost;
}

// Last normal, ensure periodicity
nx[](2*indicesFree(nFree-1))= nx[](2*indicesFree(0));
ny[](2*indicesFree(nFree-1)+1) = ny[](2*indicesFree(0)+1);


normalPerio = normal; // Project the normals computed at the non-periodic space into the periodic one.

if (debug) {
  plot(
    Th,/*normal,*/normalPerio, value = true, fill = false, nbiso = 64, wait = true,
    cmm = "(nx,ny) periodic;",bb=[[-1*0.3,-aVisor*0.3],[aVisor*0.3,aVisor*0.3]]
  );
}
// ----------------------------------------------------------------------------

// Define & solve the polarity equations --------------------------------------
// P2 extension of polarity Dirichlet data
varf bndDirichlet(pD, q) = on(free[0], pDx = nxPerio) + on(free[0], pDy = nyPerio);
Pol pD=[0,0];
pDx[] = bndDirichlet(0, Pol, tgv = 1.0);

// Bilinear and linear variational forms P (Modified Homogeneous Drirchlet problem for p-pD)
varf ap(p, q) = int2d(Th)(
    (grad(px)'*grad(qx) + grad(py)'*grad(qy))
    + c*c*(p'*q)
  )
    + on(free[0], px = 0.0) + on(free[0], py=0.0) 
    + on(fixed[0], px = 0.0) + on(fixed[0], py=0.0);

varf lp(p, q) = int2d(Th)(
    - (grad(pDx)'*grad(qx) + grad(pDy)'*grad(qy)) 
    - c*c*(pD'*q)
  )
    + on(free[0], px = 0.0) + on(free[0], py=0.0) 
    + on(fixed[0], px = 0.0) + on(fixed[0], py=0.0);

// Assembly P
matrix Ap = ap(Pol, Pol, tgv = -2); // LHS matrix
real[int] bp = lp(0, Pol); // RHS

// P solution with vanishing Dirichlet data
real[int] solP(Pol.ndof);
//set(Ap,solver=sparsesolver);
solP=Ap^-1*bp;
Pol p=[0,0];
px[]=solP(0:Pol.ndof-1);

// P solution
p = p + pD;

if (debug) {
  // plot(Th,px, value = true, fill = true, nbiso = 64, wait = true, cmm = "px");
  // plot(Th,py, value = true, fill = true, nbiso = 64, wait = true, cmm = "py");
  plot(Th,p, value = true, fill = true, nbiso = 64, wait = true, cmm = "(px,py)");
  Pola pABS = sqrt(px(x,y)^2 + py(x,y)^2); // Abs(P)
  plot(Th,pABS, value = true, fill = true, nbiso = 64, wait = true, cmm = "|p|");
}

// Define & solve the velocity equation ---------------------------------------
// Bilinear and linear variational forms V
varf av(v, u) = int2d(Th)(
    ((Grad(vx,vy)+GradT(vx,vy))'*Grad(ux,uy))
    + pow(b,2)*(v'*u)
  ) // -viscosity -friction
    + on(fixed[0], vx = 0.0) + on(fixed[0], vy = 0.0);

varf lv(v, u) = int2d(Th)( 
    + a*(pp(px,py)'*Grad(ux,uy))
    + c*(p'*u)
  ) //contractility +active traction
    + on(fixed[0], vx = 0.0) + on(fixed[0], vy = 0.0); 

// Assembly V
matrix Av = av(Vel, Vel);
real[int] bv = lv(0, Vel);

// V solution
real[int] solV(Vel.ndof);
//set(Av,solver=sparsesolver);
solV=Av^-1*bv;
Vel v=[0,0];
vx[]=solV(0:Vel.ndof-1);

if (debug) {
  // plot(Th,vx, value = true, fill = true, nbiso = 64, wait = true, cmm = "vx");
  // plot(Th,vy, value = true, fill = true, nbiso = 64, wait = true, cmm = "vy");
  plot(Th,v, value = true, fill = true, nbiso = 64, wait = true, cmm = "(vx,vy)");
  Pola vABS = sqrt(vx(x,y)^2 + vy(x,y)^2); // Abs(P)
  plot(Th,vABS, value = true, fill = true, nbiso = 64, wait = true, cmm = "|v|");
}
//-----------------------------------------------------------------------------

// Compute the gradient of v for the posterior analysis -----------------------
// Compute it regardless of saveLoclalSols. Needed for avgDivV.
varf aGradV(dv, du) = int2d(Th)(dv'*du);
varf lGradV(dv, du) = int2d(Th)(Grad(vx,vy)'*du);

matrix AGradV = aGradV(dVel, dVel);	// LHS matrix
real[int] bGradV = lGradV(0, dVel); // RHS vector

real[int] solGradV(dVel.ndof);
solGradV=AGradV^-1*bGradV;
dVel dv=[0,0,0,0];
dvxdx[]=solGradV(0:dVel.ndof-1);


dPol dp=[0,0,0,0];
dPol d2px=[0,0,0,0];
dPol d2py=[0,0,0,0];

if (bsave) {
  // Compute the gradient of p for the posterior analysis ---------------------
  varf aGradP(dp, dq) = int2d(Th)(dp'*dq);
  varf lGradP(dp, dq) = int2d(Th)(Grad(px,py)'*dq);

  matrix AGradP = aGradP(dPol, dPol);  // LHS matrix
  real[int] bGradP = lGradP(0, dPol);  // RHS vector

  real[int] solGradP(dPol.ndof);
  solGradP=AGradP^-1*bGradP;
  dpxdx[]=solGradP(0:dPol.ndof-1);

  // Compute the Hessian of px for posterior analysis -------------------------
  varf aHessPx(d2px,d2qx) = int2d(Th)(d2px'*d2qx);
  varf lHessPx(d2px,d2qx) = int2d(Th)(Hessian(px)'*d2qx);

  matrix AHessPx = aHessPx(dPol, dPol);	// LHS matrix
  real[int] bHessPx = lHessPx(0, dPol);	// RHS vector

  real[int] solHessPx(dPol.ndof);
  solHessPx=AHessPx^-1*bHessPx;
  dpxdxx[]=solHessPx(0:dPol.ndof-1);

  // Compute the Hessian of py for posterior analysis -------------------------
  varf aHessPy(d2py,d2qy) = int2d(Th)(d2py'*d2qy);
  varf lHessPy(d2py,d2qy) = int2d(Th)(Hessian(py)'*d2qy);

  matrix AHessPy = aHessPy(dPol, dPol);	// LHS matrix
  real[int] bHessPy = lHessPy(0, dPol);	// RHS vector

  real[int] solHessPy(dPol.ndof);
  solHessPy=AHessPy^-1*bHessPy;
  dpydxx[]=solHessPy(0:dPol.ndof-1);
}
//-----------------------------------------------------------------------------

// Compute the intial values of the global variables --------------------------
real avgDivV = int2d(Th)(dvxdx+dvydy)/Area0; // Average div(velocity)
real lFree = (bFree(1,nFree-1)-bFree(1,0));
real x0 = (1/lFree)*int1d(Th,free[0])(x);
real x2 = (1/lFree)*int1d(Th,free[0])(pow((x-x0),2));
real dx0dt = (1/lFree)*int1d(Th,free[0])(vx);
real dx2dt = (2/lFree)*int1d(Th,free[0])((x-x0)*(vx-dx0dt));

real dx0dtNum = 0; // Zero inicialization
real dx2dtNum = 0;

real[int] rMin = [bFree(0,0),bFree(1,0)]; // Free bnd point with a lower x.
real[int] rMax = [bFree(0,0),bFree(1,0)]; // Free bnd point with a larger x.

// Find the position and velocity of the free boundary x-maximum and minimum
for (int i=1; i<nFree; i++){
  real ix = bFree(0,i);
  real iy = bFree(1,i);

  if (ix >= rMax[0]) {
    rMax = [ix, iy]; // Check the maximum
  } else if (iy >= 0 && ix <= rMin[0]) {
    rMin = [ix, iy]; // Check the minimum (y > 0)
  }
}

// Compute the velocities
real vxMin = vx(rMin[0],rMin[1]); // x-Velocity of rMin.
real vxMax = vx(rMax[0],rMax[1]); // x-Velocity of rMax.
real dVx = vxMax-vxMin;
//-----------------------------------------------------------------------------

// Save some observables for the next iterations
real[string] prevTimeStep;
prevTimeStep["x0"] = x0;
prevTimeStep["x2"] = x2;


// Time iteration -------------------------------------------------------------
for (int iterTime=0 ; iterTime<NiterTime ; iterTime++) {

  if (iterTime % 100 == 0 && iterTime > 0) {
    // Console log every 100 iterations
    cout << iterTime << " out of " << NiterTime << " iterations completed" << endl;
  }

  // Extract the free boundary
  sFree = extractborder(Th, free[0], bFree);
  nFree = bFree.m; // instead of Th.nbe to avoid problems with mesh labels

  // Retrieve the indices of the verices of bFree with the same ordering ------
  int[int] indicesFree(nFree);

  int iTri;
  for (int k=0; k<nFree; k++){
    // Find the triangle index of the kth bnd point
    iTri = Th(bFree(0,k),bFree(1,k)).nuTriangle;

    // Find index of the kth bnd point from its triangle index
    for (int jTri=0; jTri<3; jTri++) {
      if( abs(Th[iTri][jTri].x-bFree(0,k))<eps && abs(Th[iTri][jTri].y-bFree(1,k))<eps){
        indicesFree(k) = Th[iTri][jTri];
      }
    }
  }

  // Correction of the normal vectors at the boundary -------------------------

  Nh normal = [0,0]; // here the Dof of nx,ny are scramble.
  NhPerio normalPerio = [0,0];

  real[int] nprev(2), npost(2), nmean(2);
  int iBndElem; // index of the boundary element
  real lenprev, lenpost;
  nprev = [(bFree(1,nFree-1)-bFree(1,nFree-2)),-(bFree(0,nFree-1)-bFree(0,nFree-2))];
  lenprev = sqrt(pow(nprev[0],2)+pow(nprev[1],2));

  for (int k = 0; k < nFree-1; k++){
    npost = [(bFree(1,k+1)-bFree(1,k)),-(bFree(0,k+1)-bFree(0,k))];
    lenpost = sqrt(pow(npost[0],2)+pow(npost[1],2));
    
    nmean = nprev*(lenpost/(lenpost+lenprev)) + npost*(lenprev/(lenprev+lenpost));
    nmean /= sqrt(pow(nmean[0],2)+pow(nmean[1],2));

    nx[](2*indicesFree(k))= nmean[0]; ny[](2*indicesFree(k)+1) = nmean[1];
    nprev = npost; lenprev = lenpost;
  }

  // Last normal, ensure periodicity
  nx[](2*indicesFree(nFree-1))= nx[](2*indicesFree(0));
  ny[](2*indicesFree(nFree-1)+1) = ny[](2*indicesFree(0)+1);


  normalPerio = normal; // Project the normals computed at the non-periodic space into the periodic one.
  //---------------------------------------------------------------------------

  // Solve the polarity equation ----------------------------------------------
  // P2 extension of polarity Dirichlet data
  varf bndDirichlet(pD, q) = on(free[0], pDx = nxPerio) + on(free[0], pDy = nyPerio);
  Pol pD=[0,0];
  pDx[] = bndDirichlet(0, Pol, tgv = 1.0);

  varf lp(p, q) = int2d(Th)(
      - (grad(pDx)'*grad(qx) + grad(pDy)'*grad(qy)) 
      - c*c*(pD'*q)
    )
      + on(free[0], px = 0.0) + on(free[0], py=0.0) 
      + on(fixed[0], px = 0.0) + on(fixed[0], py=0.0);

  // Assembly P
  matrix Ap = ap(Pol, Pol, tgv = -2); // LHS matrix
  real[int] bp = lp(0, Pol); // RHS

  // P solution with vanishing Dirichlet data
  real[int] solP(Pol.ndof);
  //set(Ap,solver=sparsesolver);
  solP=Ap^-1*bp;
  Pol p=[0,0];
  px[]=solP(0:Pol.ndof-1);

  // P solution
  p = p + pD;
  //---------------------------------------------------------------------------

  // Solve the velocity equation ----------------------------------------------
  varf lv(v, u) = int2d(Th)(
      + a*(pp(px,py)'*Grad(ux,uy))
      + d*(p'*u)
    ); //contractility + active traction
  // Assembly V
  matrix Av = av(Vel, Vel);  // LHS matrix
  real[int] bv = lv(0, Vel); // RHS

  // V solution
  real[int] solV(Vel.ndof);
  //set(Av,solver=sparsesolver);
  solV=Av^-1*bv;
  Vel v=[0,0];
  vx[]=solV(0:Vel.ndof-1);
  //---------------------------------------------------------------------------

  // Compute the gradient of v for the posterior analysis ---------------------
  // Compute it regardless of saveLoclalSols. Needed for avgDivV.
  varf aGradV(dv, du) = int2d(Th)(dv'*du);
  varf lGradV(dv, du) = int2d(Th)(Grad(vx,vy)'*du);

  matrix AGradV = aGradV(dVel, dVel);	// LHS matrix
  real[int] bGradV = lGradV(0, dVel); // RHS vector

  real[int] solGradV(dVel.ndof);
  solGradV=AGradV^-1*bGradV;
  dVel dv=[0,0,0,0];
  dvxdx[]=solGradV(0:dVel.ndof-1);


  dPol dp=[0,0,0,0];
  dPol d2px=[0,0,0,0];
  dPol d2py=[0,0,0,0];

  if (bsave) {
    // Compute the gradient of p for the posterior analysis -------------------
    varf aGradP(dp, dq) = int2d(Th)(dp'*dq);
    varf lGradP(dp, dq) = int2d(Th)(Grad(px,py)'*dq);

    matrix AGradP = aGradP(dPol, dPol);  // LHS matrix
    real[int] bGradP = lGradP(0, dPol);  // RHS vector

    real[int] solGradP(dPol.ndof);
    solGradP=AGradP^-1*bGradP;
    dpxdx[]=solGradP(0:dPol.ndof-1);

    // Compute the Hessian of px for posterior analysis -----------------------
    varf aHessPx(d2px,d2qx) = int2d(Th)(d2px'*d2qx);
    varf lHessPx(d2px,d2qx) = int2d(Th)(Hessian(px)'*d2qx);

    matrix AHessPx = aHessPx(dPol, dPol);	// LHS matrix
    real[int] bHessPx = lHessPx(0, dPol);	// RHS vector

    real[int] solHessPx(dPol.ndof);
    solHessPx=AHessPx^-1*bHessPx;
    dpxdxx[]=solHessPx(0:dPol.ndof-1);

    // Compute the Hessian of py for posterior analysis -----------------------
    varf aHessPy(d2py,d2qy) = int2d(Th)(d2py'*d2qy);
    varf lHessPy(d2py,d2qy) = int2d(Th)(Hessian(py)'*d2qy);

    matrix AHessPy = aHessPy(dPol, dPol);	// LHS matrix
    real[int] bHessPy = lHessPy(0, dPol);	// RHS vector

    real[int] solHessPy(dPol.ndof);
    solHessPy=AHessPy^-1*bHessPy;
    dpydxx[]=solHessPy(0:dPol.ndof-1);
  }
  //---------------------------------------------------------------------------

  // Compute the global variables ---------------------------------------------
  Areai = Th.measure;
  avgDivV = int2d(Th)(dvxdx+dvydy)/Areai; // Average div(velocity)
  lFree = (bFree(1,nFree-1)-bFree(1,0));
  x0 = (1/lFree)*int1d(Th,free[0])(x);
  x2 = (1/lFree)*int1d(Th,free[0])(pow((x-x0),2));
  dx0dt = (1/lFree)*int1d(Th,free[0])(vx);
  dx2dt = (2/lFree)*int1d(Th,free[0])((x-x0)*(vx-dx0dt));

  dx0dtNum = (x0-prevTimeStep["x0"])/dt;
  dx2dtNum = (x2-prevTimeStep["x2"])/dt;

  rMin = [bFree(0,0),bFree(1,0)]; // Free bnd point with a lower x.
  rMax = [bFree(0,0),bFree(1,0)]; // Free bnd point with a larger x.

  // Find the position and velocity of the free boundary x-maximum and minimum
  for (int i=1; i<nFree; i++){
    real ix = bFree(0,i);
    real iy = bFree(1,i);

    if (ix >= rMax[0]) {
      rMax = [ix, iy]; // Check the maximum
    } else if (iy >= 0 && ix <= rMin[0]) {
      rMin = [ix, iy]; // Check the minimum (y > 0)
    }
  }

  // Compute the velocities
  vxMin = vx(rMin[0],rMin[1]); // x-Velocity of rMin.
  vxMax = vx(rMax[0],rMax[1]); // x-Velocity of rMax.
  dVx = vxMax-vxMin;
  //---------------------------------------------------------------------------

  // Update the previous observables.
  prevTimeStep["x0"] = x0;
  prevTimeStep["x2"] = x2;

  if (debug) {
    Pola vABS = sqrt(vx(x,y)^2 + vy(x,y)^2);
    plot(/*Th,*/vABS,normal, 
      value = true,
      fill = true,
      nbiso = 64,
      wait = false,
      /*bb=[[-2*0.5,-aVisor*0.5],[aVisor*0.5,aVisor*0.5]],*/
      cmm = cmm = "iTime="+(iterTime)+"; "+"t="+(dt*iterTime)+
      "; Amp = "+meshParameters["amp"]+";  a = "+a+";  b = "+b+";  c = "+c
    );
  }

  // Export data --------------------------------------------------------------
  if(iterTime % dsave == 0 && bsave==1){

    string simulHomeDir = rootDir+"/"+simulNames[iSimul];
    string fileNameGlobalSol = "/global_sol.csv";
    string fileNameLocalSol = "/local_sol/sol_"+(1000000+iterTime)+".txt";
    string fileNameMsh = "/msh/mesh_"+(1000000+iterTime)+".msh";
    string fileNameFreeBnd = "/free_bnd/bnd_"+(1000000+iterTime)+".txt";

    // Save {px, py, vx, vy, dpxdx, dpxdy, dpydx, dpydy, dvxdx, dvxdy, 
    // dvydx, dvydy, dpxdxx, dpxdxy, dpxdyx, dpxdyy, dpydxx, dpydxy, 
    // dpydyx, dpydyy} on each vertex:
    // Memory efficient method, but needs connectivity data to 
    // reconstruct the mesh
    {
      ofstream fileLocalSols (simulHomeDir+fileNameLocalSol);
      
      fileLocalSols.fixed;
      int NbVertices = Th.nv;
      fileLocalSols << "# LocalSolutions" << endl
                    << "# NumFields: " << 20 << "  NumberVertices: " << NbVertices 
                    << " Amp: " << meshParameters["amp"] << " a: " << a 
                    << " b: " << b << " c: " << c << endl
                    << "# px  py  vx  vy  dpxdx  dpxdy  dpydx  dpydy  dvxdx  dvxdy  dvydx  dvydy  " 
                    << "dpxdxx  dpxdxy  dpxdyx  dpxdyy  dpydxx  dpydxy  dpydyx  dpydyy" << endl;
      for (int i = 0; i < NbVertices; i++){
        fileLocalSols << px(Th(i).x,Th(i).y) << "  " << py(Th(i).x,Th(i).y)     << "  "  // {px,py}
                << vx(Th(i).x,Th(i).y)       << "  " << vy(Th(i).x,Th(i).y)     << "  "  // {vx,vy}
                << dpxdx(Th(i).x,Th(i).y)    << "  " << dpxdy(Th(i).x,Th(i).y)  << "  "  // {dpxdx,dpxdy}
                << dpydx(Th(i).x,Th(i).y)    << "  " << dpydy(Th(i).x,Th(i).y)  << "  "  // {dpydx,dpydy}
                << dvxdx(Th(i).x,Th(i).y)    << "  " << dvxdy(Th(i).x,Th(i).y)  << "  "  // {dvxdx,dvxdy}
                << dvydx(Th(i).x,Th(i).y)    << "  " << dvydy(Th(i).x,Th(i).y)  << "  "  // {dvydx,dvydy}
                << dpxdxx(Th(i).x,Th(i).y)   << "  " << dpxdxy(Th(i).x,Th(i).y) << "  "  // {dpxdxx,dpxdxy}
                << dpxdyx(Th(i).x,Th(i).y)   << "  " << dpydyy(Th(i).x,Th(i).y) << "  "  // {dpxdyx,dpxdyy}
                << dpydxx(Th(i).x,Th(i).y)   << "  " << dpydxy(Th(i).x,Th(i).y) << "  "  // {dpydxx,dpydxy}
                << dpydyx(Th(i).x,Th(i).y)   << "  " << dpydyy(Th(i).x,Th(i).y) << endl; // {dpydyx,dpydyy}
      }
    }

    // Save {x, y, px, py, vx, vy} on each vertex of the free boundary:
    // Eases the posterior analysis
    {
      ofstream fileFreeBnd (simulHomeDir+fileNameFreeBnd);
      
      fileFreeBnd.fixed;
      fileFreeBnd << "# FreeBoundary" << endl
                    << "# NumFields: " << 7 << "  NumberVertices: " << nFree 
                    << " Amp: " << meshParameters["amp"] << " a: " << a 
                    << " b: " << b << " c: " << c << endl
                    << "# x  y  s  px  py  vx  vy" << endl;
      for (int i = 0; i < nFree; i++){
        fileFreeBnd << bFree(0,i)   << "  " << bFree(1,i) << "  " << bFree(2,i)   << "  "  // {x,y,s}
                << px(bFree(0,i),bFree(1,i)) << "  " << py(bFree(0,i),bFree(1,i)) << "  "  // {px,py}
                << vx(bFree(0,i),bFree(1,i)) << "  " << vy(bFree(0,i),bFree(1,i)) << endl; // {vx,vy}
      }
    }

    // Save Global Data (variables integratet over the domain)
    {ofstream fileGlobalSol (simulHomeDir+fileNameGlobalSol, append);
      
      fileGlobalSol.fixed;
      fileGlobalSol  << iterTime*dt << "," << avgDivV  << ","
                     << rMin[0]     << "," << rMin[0]  << ","
                     << rMax[1]     << "," << rMax[1]  << ","
                     << vxMin       << "," << vxMax    << ","
                     << dVx         << ","
                     << x0          << "," << x2       << ","
                     << dx0dt       << "," << dx2dt    << ","
                     << dx0dtNum    << "," << dx2dtNum << endl;
    }

    // save the last mesh
    savemesh(Th,simulHomeDir+fileNameMsh);
  }
  //---------------------------------------------------------------------------


  // Remeshing --------------------------------------------------------------------------------------------------------
  try{
    // Move mesh
    //real minT0 = checkmovemesh(Th, [x, y]); // to check for flipped triangles
    // real minT = checkmovemesh(Th, [x+dt*vx,y+dt*vy]);
    // cout << "Min triangle area before: "+minT0+" & after: "+minT<<endl;
    Th = movemesh(Th,[x+dt*vx,y+dt*vy]);

    // Move boundary test, problems with varying boundary arch length
    /*{
      cout << bOut.m << endl;
      Move the boundary
      for(int i=0; i<nBnd; i++){
        bOut(0,i) += dt*vx(bOut(0,i));
        bOut(1,i) += dt*vy(bOut(1,i)); 
      }
    }*/

    Th = periodicRemesh1FreeBnd(
      Th,obd,ibd,bLayerWidth,free,fixed, periodic,.5
    );
  }
  catch(...) {
    cout << "ERROR: Simulation "+simulNames[iSimul]+" stopped after "+iterTime+" iterations due to a remeshing error" << endl;
    err = 1;
    break;
  }
  //---------------------------------------------------------------------------
}

if (!err){
  cout << "Simulation"+simulNames[iSimul]+" finished without errors" << endl;
}
