/*

*/
// macroInputMeshParameters documentation
// Separate the input of the mesh parameters and the densities, boundary width
// and labels, as the mesh parameters could be defined in a local scope,
// whereas the other variables, are needed for the remeshing macros.
NewMacro macroInputMeshParameters(meshParameters)
// Dynamic map with the mesh parameters. May vary with the mesh generator.
real[string] meshParameters;

{ // Load the parameters as a dynamic map (dictionary) for an easy handling and robustness.
  string[int] meshKeys = $meshKeys;
  real[int] meshValues = $meshValues;
  for [i, iKey : meshKeys]{
    meshParameters[iKey] = meshValues[i];
  }
}
EndMacro

// macroInputLabels documentation
//
NewMacro macroInputLabels(free, fixed, periodic, perio)
IF free //** Unpack the free labels.
int[int] free = $free;
ELSE
int[int] free = [-1]; // No free boundary.
ENDIF
\\
IF fixed //** Unpack the fixed labels.
int[int] fixed = $fixed;
ELSE
int[int] fixed = [-1]; // No fixed boundary.
ENDIF
\\
IF periodic //** Unpack the periodic labels
int[int] periodic = $periodic;
func perio=[[periodic[0],x],[periodic[1],x]]; // Periodicity.
ELSE
int[int] periodic = [-1]; // No periodic boundary.
bool perio = 0;    // No periodicity defined.
ENDIF
\\
EndMacro

// macro
//
NewMacro macroInputNumerics(
  outerBndDensity, innerBndDensity, bndLayerWidth, dt, NiterTime, 
  areaMinMaxRates, dsave, smoothCoef, keepPoints, eps
  )
// Numerical parameters for the simulations (global scope) ------------------
DEFAULT (bndLayerWidth, "50")
DEFAULT (outerBndDensity, "45")
DEFAULT (innerBndDensity, "15")
DEFAULT (dt, "5e-4")
DEFAULT (NiterTime, "2000")
DEFAULT (rateMaxArea, "8")
DEFAULT (rateMinArea, "1/8")
DEFAULT (dsave, "0")
DEFAULT (smoothCoef, "0.5")
DEFAULT (keepPoints, "0")
DEFAULT (eps, "1e-12")
\\
real bndLayerWidth = $bndLayerWidth;    // Width of the boundary layer [μm].
int outerBndDensity = $outerBndDensity; // num outer bnd nodes per unit length.
int innerBndDensity = $innerBndDensity; // num inner bnd nodes per unit length.

real dt = $dt; // Adim. time step, real time step = dt * tscale.

// Num. of iterations, Max time = NiteTime * dt * tscale.
int NiterTime = $NiterTime;

// Stop the simulation when Area >= rateMaxArea * (Initial Area) or 
// Area <= rateMinArea * (Initial Area)
real[string] areaMinMaxRates;
areaMinMaxRates["Min"] = $rateMinArea;
areaMinMaxRates["Max"] = $rateMaxArea;

// Save frame gap. If set to 0, no solutions will be saved.
// Usually we do not need that many solutions to represent an evolution and
// also it will save memory and loading time. 
int dsave = $dsave;

// smoothing of the inner boundary in adaptive meshes 
// = bLayerThickness*smoothCoef.
real smoothCoef = $smoothCoef;

// Keep the same number of point upon remeshing.
bool keepPoints = $keepPoints;

// epsilon: user defined numerical tolerance.
real eps = $eps;
EndMacro


// macroInputParameters documentation
//
NewMacro macroInputParameters(a, b, c, d,/**/ lengthScale)
// Initialize to 0 the problem adim. parameters.
real a = 0; real b = 0; real c = 0; func d = 0;

{
  // Problem physical Parameters ----------------------------------------------
  real Lc = $Lc;      // Nematic length, sqrt(K/a), [μm].
  real eta = $eta;    // Monolayer viscosity, [kPa·s].
  real xi = $xi;      // Friction coef, [kPa·s/μm²].
  real zeta = $zeta;  // -Contractility coef, [kPa]. < 0 for contractile stress.

  IF DUROTAXIS
  // Parameters for durotaxis
  real zi0 = $zi0;    // Offset traction coef, [kPa/μm]. Init traction at CM.
  real gradZi = $gradZi; // Durotactic traction gradient, [kPa/μm²].

  // Linear durotaxis (simplified model).
  func zi = zi0+gradZi*lengthScale*(y-Ycm0);
  ELSE
  \\;
  real zi0 = $zi;    // zi0 instead of zi eases the def. of La, tscale & d.
  func zi = zi0;     // Traction, [kPa/μm].
  ENDIF

  // Problem characteristic scales.
  real lambda = sqrt(eta/xi); // Hydrodynamic sceening length.
  real La = zeta/zi0; // Active length; <0 contractile (>0 extensile) stress.    
  // real tscale = eta/(zi0*Lc); // Problem timescale.
  // real vscale = lengthScale/tscale;    // Problem velocity scale.

  // Problem adimensionalized parameters (global scope) -----------------------
  a = La/Lc;            // Active and characteristic length ratio.
  b = lengthScale/lambda;        // Characteristic and hydrodynamic length ratio.
  c = lengthScale/Lc;            // Characteristic and nematic length ratio.
  d = (zi*lengthScale)/(zi0*Lc); // Modified c for durotaxis.
}
EndMacro
