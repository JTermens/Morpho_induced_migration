/* meshes.edp
Author: Joan TÃ©rmens (https://github.com/JTermens)

Catalog of FreeFem++ meshes for the Ephithelial-tissues-FEM project. 
It includes the following mesh generation functions:

Closed meshes:
- fourCurveShape
- oneCutSmooth
- sinePerturb
- twoCurvesTriangle
- roundedTriangle
- circle

Semi-periodic meshes
- sinusoidalSemiplane
- bufferSinusoidalSemiplane

All the meshes share the same arguments:
- real bndDensity: boundary density, num. of points per unit lenght at the 
  boundary.
- real[string]& meshParameters: dictionary with the parameters that define the
  shape. The & ensures passing it by reference to avoid copy value problems.
- int[int] free: labels of the free boundaries that will be remeshed with 
  splines.
- int[int] fixed: labels of the fixed boundaries (will impose v = 0 on those).
- int[int] periodic: labels of the periodic boundaries. Always in pairs will be
  remesh by linear interpolation.
- real lengthScale: lengthScale to adimesnionalize the domain, 
  {x', y'} = {x, y}/lengthScale.
- real Nmax: Maximum number of points per border. If the mesh is very big, set 
  bndDensity to a low value and control the number of bnd nodes with Nmax.
*/

func mesh fourCurveShape(
  real bndDensity, real[string]& meshParameters , int[int] free, int[int] fixed,
  int[int] periodic, real lengthScale, real Nmax
){
  /*
  [mesh] fourCurveShape returns a mesh with a boundary defined by four 
  tangetial circumference arches. The centers of the Up & Down arches are 
  separrated by a distance d, while the Left & Right ones are tangent to those
  and close the boundary.

  Parameters:
  - real bndDensity: boundary density, num. of points per unit lenght at the 
    boundary.
  - real[string]& meshParameters: parameters that define the shape:
    - "rUp": radius of the upper arch.
    - "rDown": radius of the lower arch.
    - "rLeft": radius of the left arch. 
    - "rRight": radius of the right arch.
    - "d": distance between the center of the Up & Down arches.
    - "symmAxis": orientation of the (not necessary symmetric) shape. Defines
    the line between the centers of the Up & Down arches.
  - int[int] free, fixed, periodic: free is the free boundary label, other ones 
    will be ignored.
  - real lengthScale: length scale used to adimensionalize the mesh (x,y /= L).
  - real Nmax: Maximum number of points per border.

  * Return type: mesh
  */

  // Unpack mesh parameters
  real rUp = meshParameters["rUp"];
  real rDown = meshParameters["rDown"];
  real rLeft = meshParameters["rLeft"];
  real rRight = meshParameters["rRight"];
  real d = meshParameters["d"];
  real symmAxis = meshParameters["symmAxis"];

  // Set the closed-boundary label
  int labelBnd = free[0];

  mesh Th; // Final mesh

  try{
    1/(((d+rUp-rDown-2*rRight) > 0) && ((d+rUp-rDown-2*rLeft) > 0));
  } catch (...) {
    cout << "ERROR: d + rUp - rDown - 2*(rRight and rLeft) > 0" << endl;
  }

  real thetaDownRight = acos(
    (pow((rDown+rRight),2)+pow(d,2)-pow((rUp-rRight),2))/(2*(rDown+rRight)*d));
  real thetaDownLeft = acos(
    (pow((rDown+rLeft),2)+pow(d,2)-pow((rUp-rLeft),2))/(2*(rDown+rLeft)*d));
  real thetaUpRight = acos(
    (pow((rDown+rRight),2)-pow(d,2)-pow((rUp-rRight),2))/(2*(rUp-rRight)*d));
  real thetaUpLeft = acos(
    (pow((rDown+rLeft),2)-pow(d,2)-pow((rUp-rLeft),2))/(2*(rUp-rLeft)*d));
  real thetaRight = acos(
    (pow(d,2)-pow((rUp-rRight),2)-pow(rDown+rRight,2))/(2*(rUp-rRight)*(rDown+rRight)));
  real thetaLeft = acos(
    (pow(d,2)-pow((rUp-rLeft),2)-pow(rDown+rLeft,2))/(2*(rUp-rLeft)*(rDown+rLeft)));

  real xRight = -(d*(pow(d,2) - (rDown + 2*rRight - rUp)*(rDown + rUp))*cos(symmAxis) -
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rRight - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*sin(symmAxis))/(2*pow(d,2));
  real yRight = -(d*(pow(d,2) - (rDown + 2*rRight - rUp)*(rDown + rUp))*sin(symmAxis) +
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rRight - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*cos(symmAxis))/(2*pow(d,2));

  real xLeft = -(d*(pow(d,2) - (rDown + 2*rLeft - rUp)*(rDown + rUp))*cos(symmAxis) +
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rLeft - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*sin(symmAxis))/(2*pow(d,2));
  real yLeft = -(d*(pow(d,2) - (rDown + 2*rLeft - rUp)*(rDown + rUp))*sin(symmAxis) -
    sqrt(-pow(d,2)*(pow(d,2) - pow((rDown + 2*rLeft - rUp),2))*(pow(d,2) - pow((rDown + rUp),2)))*cos(symmAxis))/(2*pow(d,2));


  // Define the borders without mesh adaptation
  border rightArch(t=0, 1){
    x = (xRight + rRight*cos((symmAxis-thetaUpRight-thetaRight)+thetaRight*t))/lengthScale;
    y = (yRight + rRight*sin((symmAxis-thetaUpRight-thetaRight)+thetaRight*t))/lengthScale;
    label = labelBnd;
  };
 
  border upArch(t=0,1){
    x = (rUp*cos((symmAxis-thetaUpRight)+(thetaUpLeft+thetaUpRight)*t))/lengthScale;
    y = (rUp*sin((symmAxis-thetaUpRight)+(thetaUpLeft+thetaUpRight)*t))/lengthScale;
    label = labelBnd;
  };

  border leftArch(t=0,1){
    x = (xLeft + rLeft*cos((symmAxis+thetaUpLeft)+thetaLeft*t))/lengthScale;
    y = (yLeft + rLeft*sin((symmAxis+thetaUpLeft)+thetaLeft*t))/lengthScale;
    label = labelBnd;
  };
  
  border downArch(t=0,1){
    x = (-d*cos(symmAxis)+rDown*cos((symmAxis+thetaDownLeft)-(thetaDownLeft+thetaDownRight)*t))/lengthScale;
    y = (-d*sin(symmAxis)+rDown*sin((symmAxis+thetaDownLeft)-(thetaDownLeft+thetaDownRight)*t))/lengthScale;
    label = labelBnd;
  };

  Th = buildmesh(
    rightArch(min(Nmax, bndDensity*rRight*thetaRight/lengthScale))
    + upArch(min(Nmax, bndDensity*rUp*(thetaUpLeft+thetaUpRight)/lengthScale))
    + leftArch(min(Nmax, bndDensity*rLeft*thetaLeft/lengthScale))
    + downArch(min(Nmax, bndDensity*rDown*(thetaDownLeft+thetaDownRight)/lengthScale))
  );

  return Th;
}

func mesh oneCutSmooth(
  real bndDensity, real[string]& meshParameters , int[int] free, int[int] fixed, 
  int[int] periodic, real lengthScale, real Nmax
){
  /*
  [mesh] oneCutSmooth returns a mesh with a boundary defined by circle with a
  strigth cut of angular length cut, perpendicular to a ray in the symmAxis 
  direction. The vertices of the cut are smoothed by tangential arches of 
  radius rArch.

  Parameters:
  - real bndDensity: boundary density, num. of points per unit lenght at the 
    boundary.
  - real[string]& meshParameters: parameters that define the shape:
    - "cut": angluar length of the straight cut line.
    - "r0": radius of the circumference (Front) arch.
    - "rArch": radius of the tangential arches that smooth the cut vertices. 
    - "symmAxis": orientation of the shape. Defines the mid-line of the cut.
  - int[int] free, fixed, periodic: free is the free boundary label, other ones 
    will be ignored.
  - real lengthScale: length scale to adimensionalize the mesh (x, y /= L).
  - real Nmax: Maximum number of points per border.

  * Return type: mesh
  */

  // Unpack meshParameters
  real cut = meshParameters["cut"];
  real r0 = meshParameters["r0"];
  real rArch = r0*meshParameters["fracRarc"];
  real symmAxis = meshParameters["symmAxis"];

  // Set the closed-boundary label
  int labelBnd = free[0];

  real cutAxis = symmAxis+pi;
  real t1 = acos((cos(cut/2.)-(rArch/r0))/(1-(rArch/r0)));

  real OxRight = (r0-rArch)*cos(cutAxis+t1);
  real OyRight = (r0-rArch)*sin(cutAxis+t1);
  real OxLeft = (r0-rArch)*cos(cutAxis-t1);
  real OyLeft = (r0-rArch)*sin(cutAxis-t1);
  real lenCut = sqrt((OxRight-OxLeft)*(OxRight-OxLeft) + (OyRight-OyLeft)*(OyRight-OyLeft));

  border ArchLeft(t=0,1){
    x = (OxLeft+rArch*cos(cutAxis-t1*(1-t))); 
    y = (OyLeft+rArch*sin(cutAxis-t1*(1-t))); 
    label = labelBnd;
  };

  border Cut(t=0,1){
    x = ((OxLeft+rArch*cos(cutAxis))+(OxRight-OxLeft)*t);
    y = ((OyLeft+rArch*sin(cutAxis))+(OyRight-OyLeft)*t);
    label = labelBnd;
  };

  border ArchRight(t=0,1){
    x = (OxRight+rArch*cos(cutAxis+t1*t)); 
    y = (OyRight+rArch*sin(cutAxis+t1*t));
    label = labelBnd;
  };

  border ArchFront(t=0,1){
    x = (r0*cos(cutAxis+t1+2*(pi-t1)*t));
    y = (r0*sin(cutAxis+t1+2*(pi-t1)*t));
    label = labelBnd;
  };

  mesh Th=buildmesh(
    ArchLeft(min(Nmax, bndDensity*rArch*t1))
    + Cut(min(Nmax, bndDensity*lenCut))
    + ArchRight(min(Nmax, bndDensity*rArch*t1))
    + ArchFront(min(Nmax, bndDensity*r0*2*(pi-t1)))
  );

  return Th;
}

func mesh sinePerturb(
  real bndDensity, real[string]& meshParameters , int[int] free, int[int] fixed,
  int[int] periodic, real lengthScale, real Nmax
){
  /*
  [mesh] sinePerturb returns a mesh with a boundary defined by the sinusoidal 
  perturbations of a circle.

  Parameters:
  - real bndDensity: boundary density, num. of points per unit lenght at the 
    boundary.
  - real[string]& meshParameters: parameters that define the shape:
    - "r0": radius of the base circumference.
    - "amp": Amplitude of the sinusoidal perturbations.
    - "q": perturbation wave-number (number of lobes).
    - "symmAxis": orientation of the shape. Defines the symmetry axis.
  - int[int] free, fixed, periodic: free is the free boundary label, other ones 
    will be ignored.
  - real lengthScale: length scale to adimensionalize the mesh (x, y /= L).
  - real Nmax: Maximum number of points per border.

  * Return type: mesh
  */

  // Unpack meshParameters
  real r0 = meshParameters["r0"];
  real amp = meshParameters["amp"];
  int q = meshParameters["q"];
  real symmAxis = meshParameters["symmAxis"];

  // Set the closed-boundary label
  int labelBnd = free[0];

  border Boundary(t=0,1){
    x = (r0 + amp*cos(2*pi*q*t))*cos(2*pi*t+symmAxis)/lengthScale;
    y = (r0 + amp*cos(2*pi*q*t))*sin(2*pi*t+symmAxis)/lengthScale;
    label = labelBnd;
  }

  mesh Th = buildmesh(Boundary(min(Nmax, bndDensity*r0*2*pi/lengthScale)));

  return Th;
}

func mesh twoCurvesTriangle(
  real bndDensity, real[string]& meshParameters , int[int] free, int[int] fixed,
  int[int] periodic, real lengthScale, real Nmax
){
  /*
  [mesh] twoCurvesTriangle returns a mesh with a boundary defined by an 
  equilateral triangle of apothem r0 with cricumference arches of radius 
  rVertex at its vertices and tangetial circumference arches of radius rSide
  at its sides.  

  Parameters:
  - real bndDensity: boundary density, num. of points per unit lenght at the
    boundary.
  - real[string]& meshParameters: parameters that define the shape:
    - "r0": radius of the base circumference.
    - "rSide": radius of the arches at the sides.
    - "rVertex": radius of the arches at the vertices.
    - "symmAxis": orientation of the upper vertex. Defines the symmetry axis.
  - int[int] free, fixed, periodic: free is the free boundary label, other ones 
    will be ignored.
  - real lengthScale: length scale to adimensionalize the mesh (x, y /= L).
  - real Nmax: Maximum number of points per border.

  * Return type: mesh
  */

  // Unpack the meshParameters
  real r0 = meshParameters["r0"];
  real rSide = meshParameters["rSide"];
  real rVertex = meshParameters["rVertex"];
  real symmAxis = meshParameters["symmAxis"];

  // Set the closed-boundary label
  int labelBnd = free[0];

  real alpha = (2*pi/3)/2; // a 6th of a circle arclegth
  real rCentSide = r0-rSide;
  // Compute rCentVertex by the cosine law with alpha and solving for it
  real rCentVertex = rCentSide*cos(alpha)+sqrt(pow(rCentSide,2)*(pow(cos(alpha),2)-1)+pow(rVertex+rSide,2));

  // Compute thetaVertex by the cosine law with rCentSide, rCentVertex & rSide+rVertex
  real thetaVertex = acos(
    (pow(rVertex+rSide,2)+pow(rCentVertex,2)-pow(rCentSide,2))/(2*(rVertex+rSide)*rCentVertex)
  );
  real thetaSide = alpha + thetaVertex;

  real[int] xCentSide = [rCentSide*cos(symmAxis),rCentSide*cos(symmAxis+2*alpha),rCentSide*cos(symmAxis+4*alpha)];
  real[int] yCentSide = [rCentSide*sin(symmAxis),rCentSide*sin(symmAxis+2*alpha),rCentSide*sin(symmAxis+4*alpha)];

  real[int] xCentVertex = [rCentVertex*cos(symmAxis+alpha),rCentVertex*cos(symmAxis+3*alpha),rCentVertex*cos(symmAxis+5*alpha)];
  real[int] yCentVertex = [rCentVertex*sin(symmAxis+alpha),rCentVertex*sin(symmAxis+3*alpha),rCentVertex*sin(symmAxis+5*alpha)];

  border Side0(t=0,1){
    x = (xCentSide[0] + rSide*cos((symmAxis-thetaSide)+2*thetaSide*t))/lengthScale;
    y = (yCentSide[0] + rSide*sin((symmAxis-thetaSide)+2*thetaSide*t))/lengthScale;
    label = labelBnd;
  };
  border Vertex0(t=0,1){
    x = (xCentVertex[0]+rVertex*cos((-symmAxis+alpha+thetaVertex)-2*thetaVertex*t))/lengthScale;
    y = (yCentVertex[0]+rVertex*sin((-symmAxis+alpha+thetaVertex)-2*thetaVertex*t))/lengthScale;
    label = labelBnd;
  };

  border Side1(t=0,1){
    x = (xCentSide[1] + rSide*cos((symmAxis+2*alpha-thetaSide)+2*thetaSide*t))/lengthScale;
    y = (yCentSide[1] + rSide*sin((symmAxis+2*alpha-thetaSide)+2*thetaSide*t))/lengthScale;
    label = labelBnd;
  };
  border Vertex1(t=0,1){
    x = (xCentVertex[1]+rVertex*cos((-symmAxis+3*alpha+thetaVertex)-2*thetaVertex*t))/lengthScale;
    y = (yCentVertex[1]+rVertex*sin((-symmAxis+3*alpha+thetaVertex)-2*thetaVertex*t))/lengthScale;
    label = labelBnd;
  };

  border Side2(t=0,1){
    x = (xCentSide[2] + rSide*cos((symmAxis+4*alpha-thetaSide)+2*thetaSide*t))/lengthScale;
    y = (yCentSide[2] + rSide*sin((symmAxis+4*alpha-thetaSide)+2*thetaSide*t))/lengthScale;
    label = labelBnd;
  };
  border Vertex2(t=0,1){
    x = (xCentVertex[2]+rVertex*cos((-symmAxis+5*alpha+thetaVertex)-2*thetaVertex*t))/lengthScale;
    y = (yCentVertex[2]+rVertex*sin((-symmAxis+5*alpha+thetaVertex)-2*thetaVertex*t))/lengthScale;
    label = labelBnd;
  };

  mesh Th = buildmesh(
    Side0(min(Nmax, bndDensity*2*thetaSide*rSide/lengthScale))
    + Side1(min(Nmax, bndDensity*2*thetaSide*rSide/lengthScale))
    + Side2(min(Nmax, bndDensity*2*thetaSide*rSide/lengthScale))
    + Vertex0(min(Nmax, bndDensity*2*thetaVertex*rVertex/lengthScale))
    + Vertex1(min(Nmax, bndDensity*2*thetaVertex*rVertex/lengthScale))
    + Vertex2(min(Nmax, bndDensity*2*thetaVertex*rVertex/lengthScale))
  );
  
  return Th;
}

func mesh roundedTriangle(
  real bndDensity, real[string]& meshParameters , int[int] free, int[int] fixed,
  int[int] periodic, real lengthScale, real Nmax
){
  /*
  [mesh] roundedTriangle returns a mesh with a boundary defined by a triangle 
  of the given sides and rounded vertices with a radius of rRound.

  Parameters:
  - real bndDensity: boundary density, num. of points per unit lenght at the
    boundary.
  - real[string]& meshParameters: parameters that define the shape:
    - "sideLength1:3": lengths of the traingle sides.
    - "rRound": radius of the rounded vertices.
  - int[int] free, fixed, periodic: free is the free boundary label, other ones 
    will be ignored.
  - real lengthScale: length scale to adimensionalize the mesh (x, y /= L).
  - real Nmax: Maximum number of points per border.

  * Return type: mesh
  */
  
  // Unpack meshParameters
  real[int] sideLengths = [
    meshParameters["sideLength1"], 
    meshParameters["sideLength2"], 
    meshParameters["sideLength3"]
  ];
  real rRound = meshParameters["rRound"];

  // Set the closed-boundary label
  int labelBnd = free[0];
  
  // It is only possible to build a triangle if the sum of each pair of
  // sides is larger than the third one.
  bool err = 0;

  try {
    1/(
      sideLengths[0] + sideLengths[1] >= sideLengths[2] && 
      sideLengths[1] + sideLengths[2] >= sideLengths[0] && 
      sideLengths[2] + sideLengths[0] >= sideLengths[1]
    );
  } catch (...){
    cout << "ERROR: Unable to buid a triangle with side lengths "
    +sideLengths[0]+", "+sideLengths[1]+" & "+sideLengths[2] << endl;
  }
  
  // Consider P2 = (0,0), P1 = (a, sideLengths[0],0) and compute the position
  // of the 3rd point such that d(P1,P2) = sideLengths[1] & d(P2,P0) = sideLengths[2]
  real x2 = (pow(sideLengths[0],2)-pow(sideLengths[1],2)+pow(sideLengths[2],2))/(2*sideLengths[0]);
  real y2 = sqrt(pow(sideLengths[2],2)-pow(x2,2));

  // Compute the barycenter
  // Its position is the average of the vertices
  real xCenter = (sideLengths[0] + x2)/3;
  real yCenter = y2/3;

  real[int,int] vertices = [
    [-xCenter, sideLengths[0]-xCenter, x2-xCenter],
    [-yCenter, -yCenter, y2-yCenter]
  ];

  // To generate the roundings we need 4 parametrers per vertex
  real[int,int] roundings(2,3); // centers of the roundings
  real[int] theta0(3); real[int] dtheta(3); // initial and angle increment

  // Plus the new beginnings and ends of each side
  real[int,int] sides(2,6);

  real angleSide = 0; // Angle of the side with the horizontal
  real angleVertex = 0; // Interior angle of the triangle at a vertex
  real dRoundVertex = 0; // distance between the vertex and the rounding center

  int[int] idx = [1,2,0];
  int[int] idxPost = [2,0,1];

  for (int iPrev=0; iPrev < 3; iPrev++){

    int i = idx[iPrev];
    int iPost = idxPost[iPrev];

    angleVertex = acos(
      ((vertices(0,i)-vertices(0,iPrev))*(vertices(0,i)-vertices(0,iPost))
        + (vertices(1,i)-vertices(1,iPrev))*(vertices(1,i)-vertices(1,iPost))
      )/(sideLengths[i]*sideLengths[iPrev])
    );

    theta0(i) = angleSide - pi/2;
    dtheta(i) = pi - angleVertex;

    dRoundVertex = rRound/sin(angleVertex/2);
    roundings(0,i) = vertices(0,i) + dRoundVertex*cos(angleSide+2*pi-angleVertex/2);
    roundings(1,i) = vertices(1,i) + dRoundVertex*sin(angleSide+2*pi-angleVertex/2);

    sides(0,2*iPrev+1) = roundings(0,i) + rRound*cos(theta0(i)); // Set end of the iPrev side
    sides(1,2*iPrev+1) = roundings(1,i) + rRound*sin(theta0(i));

    sides(0,2*i) = roundings(0,i) + rRound*cos(theta0(i) + dtheta(i)); // Set start of the i side
    sides(1,2*i) = roundings(1,i) + rRound*sin(theta0(i) + dtheta(i));

    angleSide += pi - angleVertex;
  }

  // create multiborder sides
  border side(t=0,1;i){
    x = (sides(0,2*i) + (sides(0,2*i+1)-sides(0,2*i))*t)/lengthScale;
    y = (sides(1,2*i) + (sides(1,2*i+1)-sides(1,2*i))*t)/lengthScale;
    label = labelBnd;
  }

  // create multiborder roundings
  border rounding(t=0,1;i){
    x = (roundings(0,i) + rRound*cos(theta0(i)+dtheta(i)*t))/lengthScale;
    y = (roundings(1,i) + rRound*sin(theta0(i)+dtheta(i)*t))/lengthScale;
    label = labelBnd;
  }

  int[int] nBndSide = [
    min(Nmax, dist((sides(0,1)-sides(0,0)),(sides(1,1)-sides(1,0)))*bndDensity/lengthScale),
    min(Nmax, dist((sides(0,3)-sides(0,2)),(sides(1,3)-sides(1,2)))*bndDensity/lengthScale),
    min(Nmax, dist((sides(0,5)-sides(0,4)),(sides(1,5)-sides(1,4)))*bndDensity/lengthScale)
  ];
  int[int] nBndRound = [
    min(Nmax, dtheta(0)*rRound*bndDensity/lengthScale), 
    min(Nmax, dtheta(1)*rRound*bndDensity/lengthScale), 
    min(Nmax, dtheta(2)*rRound*bndDensity/lengthScale)
  ];

  // plot(rounding(nBndRound)+side(nBndSide), wait=1);

  mesh Th = buildmesh(rounding(nBndRound)+side(nBndSide));

  return Th;
}

func mesh circle(
  real bndDensity, real[string]& meshParameters , int[int] free, int[int] fixed,
  int[int] periodic, real lengthScale, real Nmax
){
  /*
  [mesh] circle returns a circular mesh with radius r0.

  Parameters:
  - real bndDensity: boundary density, num. of points per unit lenght at the boundary.
  - real[string]& meshParameters: parameters that define the shape:
    - "r0": circle radius.
  - int[int] free, fixed, periodic: free is the free boundary label, other ones 
    will be ignored.
  - real lengthScale: length scale to adimensionalize the mesh (x, y /= L).
  - real Nmax: Maximum number of points per border.

  * Return type: mesh
  */

  // Unpack meshParameters
  real r0 = meshParameters["r0"];

  // Set the closed-boundary label
  int labelBnd = free[0];

  // Outer border of a circle
  border arch(t=0,1){
    x = (r0*cos(2*pi*t))/lengthScale;
    y = (r0*sin(2*pi*t))/lengthScale;
    label = labelBnd;
  };
  mesh Th = buildmesh(
    arch(min(Nmax, bndDensity*r0*2*pi/lengthScale))
  );

  return Th;
}

func mesh sinusoidalSemiplane(
  real bndDensity, real[string]& meshParameters , int[int] free, int[int] fixed,
  int[int] periodic, real lengthScale, real Nmax
){
  /*
  [mesh] meshSemiplaneSinusoidal returns a rectangular mesh with nFigers 
  sinusoidal fingers on its left side. The bopundary extremes always match with
  a finger minimum.

  Parameters:
    - real bndDensity: boundary density, num. of points per unit lenght at the
      boundary.
    - real[string]& meshParameters: parameters that define the shape:
      - "lx": width of the rectangle (x-axis). The total x-length is lx+2*amp.
      - "amp": amplitude of the sinusoidal finger. Take into account 
        that the finger overtakes the base rectangle by 2*amp, as it runs for 
        a full wavelength. 
      - "lFree": width of the rectangle (y-axis).
      - "nFingers": num. of fingers. Their wavelength = lFree/n.
  - int[int] free, fixed, periodic: free is the label of the free boundary 
    (right); fixed for the fixed one (left) & periodic for the top and bottom.
  - real lengthScale: length scale to adimensionalize the mesh (x, y /= L).
  - real Nmax: Maximum number of points per border.

  * Return type: mesh
  */

  // Unpack meshParameters.
  real lx = meshParameters["lx"]; 
  real lFree = meshParameters["lFree"];
  real amp = meshParameters["amp"];
  real nFingers = meshParameters["nFingers"];

  // Unpack the labels.
  int labelBottom = periodic[0]; // 1st periodic boundary (Bottom)
  int labelTop = periodic[1];    // 2nd periodic boundary (Top)
  int labelRight = free[0];      // Free boundary (right)
  int labelLeft = fixed[0];      // Fixed boundary, opposed to the free one (left)

  // Define the borders for both the bulk and the layer meshes
  // Defien the borders for both the bulk and the layer meshes.
  border Bottom(t=0, 1){
    x = (lx*(t-1))/lengthScale; 
    y = (-lFree/2.)/lengthScale;
    label = labelBottom;
  }

  border Top(t=0, 1){
    x = (0-lx*t)/lengthScale; 
    y = (lFree/2.)/lengthScale; 
    label = labelTop;
  }

  border Left(t=0,1){
    x = (-lx)/lengthScale;
    y = (lFree*(1/2.-t))/lengthScale;
    label = labelLeft;
  }

  // change for a perturbed front, if needed. Mantain extreme points at x=0
  border RightFinger(t=0,1){
    x = (amp*(cos(pi*(2*nFingers*t-1))+1))/lengthScale;
    y = (lFree*(t-1/2.))/lengthScale;
    label = labelRight;
  }

  mesh Th = buildmesh(
    Bottom(min(Nmax, bndDensity*lx/lengthScale))
    + RightFinger(min(Nmax, bndDensity*lFree/lengthScale))
    + Top(min(Nmax, bndDensity*lx/lengthScale))
    + Left(min(Nmax, bndDensity*lFree/lengthScale))
  );
  
  return Th;
}

func mesh bufferSinusoidalSemiplane(
  real bndDensity, real[string]& meshParameters , int[int] free, int[int] fixed,
  int[int] periodic, real lengthScale, real Nmax
){
  /*
  [mesh] meshSemiplaneBufferSinusoidal returns a rectangular mesh with a 
  centered single sinusoidal finger on its left side.

  Parameters:
    - real bndDensity: boundary density, num. of points per unit lenght at the
      boundary.
    - real[string]& meshParameters: parameters that define the shape:
      - "lx": width of the rectangle (x-axis). The total x-length is lx+2*amp.
      - "waveLength": wavelength of the sinusoidal finger.
      - "amp": amplitude of the sinusoidal finger. Take into account 
        that the finger overtakes the base rectangle by 2*amp, as it runs for 
        a full wavelength. 
      - "lFree": width of the rectangle (y-axis). The sinusoidal finger is 
        buffered both top and bottom by straigth lines of length 
        (lFree-wavelength)/2.
  - int[int] free, fixed, periodic: free is the label of the free boundary 
    (right); fixed for the fixed one (left) & periodic for the top and bottom.
  - real lengthScale: length scale to adimensionalize the mesh (x, y /= L).
  - real Nmax: Maximum number of points per border.

  * Return type: mesh
  */

  // Unpack mesh parameters.
  real lx = meshParameters["lx"];
  real waveLength = meshParameters["waveLength"];
  real amp = meshParameters["amp"];
  real lFree = meshParameters["lFree"];

  // Unpack labels.
  int labelBottom = periodic[0]; // 1st periodic boundary (Bottom).
  int labelTop = periodic[1];    // 2nd periodic boundary (Top).
  int labelRight = free[0];      // Free boundary (Right).
  int labelLeft = fixed[0];      // Fixed boundary, opposed to free one (Left).

  // To buffer the finger, lFree >= wavelength.
  try{
    1/(lFree >= waveLength);
  } catch (...) {
    cout << "To buffer the finger, lFree >= waveLength." << endl;
  }

  // Defien the borders for both the bulk and the layer meshes.
  border Bottom(t=0, 1){
    x = (lx*(t-1))/lengthScale; 
    y = (-lFree/2)/lengthScale;
    label = labelBottom;
  }

  border Top(t=0, 1){
    x = (0-lx*t)/lengthScale; 
    y = (lFree/2)/lengthScale; 
    label = labelTop;
  }

  border Left(t=0,1){
    x = (-lx)/lengthScale;
    y = ((lFree/2)*(1-2*t))/lengthScale;
    label = labelLeft;
  }

  // change for a perturbed front, if needed. Mantain extreme points at x=0
  border RightBuffBottom(t=0,1){
    x = (0)/lengthScale;
    y = ((lFree/2.)*(t-1)-(waveLength/2.)*t)/lengthScale;
    label = labelRight;
  }

  border RightBuffTop(t=0,1){
    x = (0)/lengthScale;
    y = ((waveLength + (lFree-waveLength)*t)/2.)/lengthScale;
    label = labelRight;
  }

  border RightFinger(t=0,1){
    x = (amp*(cos(pi*(2*t-1))+1))/lengthScale;
    y = (waveLength*(t-1/2.))/lengthScale;
    label = labelRight;
  }
  
  mesh Th = buildmesh(
   Bottom(min(Nmax, bndDensity*lx/lengthScale))
    + RightBuffBottom(min(Nmax, bndDensity*((lFree-waveLength)/2.)/lengthScale))
    + RightFinger(min(Nmax, bndDensity*waveLength/lengthScale))
    + RightBuffTop(min(Nmax, bndDensity*((lFree-waveLength)/2.)/lengthScale))
    + Top(min(Nmax, bndDensity*lx/lengthScale))
    + Left(min(Nmax, bndDensity*lFree/lengthScale))
  );

  return Th;
}
