// Packages for advanced remeshing scheme
load "Curvature"
load "distance"
load "isoline"
load "gsl"

// Manage command-line arguments
include "getARGV.idp"

include "../src/ff++/modules/mesh-generation.edp"; // Load the mesh generation functions
// Load the remeshing functions, used to adapt the meshes with a boundary layer
include "../src/ff++/modules/remeshing.edp";

bool DEBUG = getARGV("-d", 0); // set to 1 to produce the plots.

// Define variables to characterize the shapes
real Area0;
real Xcm0;
real Ycm0;
mesh Th;
bool PERIODIC;

NewMacro evaluateMesh(Th, plotLabel, PERIODIC)
cout << "OK";

if (PERIODIC){
  cout << endl;
} else {
  // Custom mesh adaptation, create a boundary layer with a higher triangle 
  // density and a bulk with a lower one
  cout << " --Adaptive mesh: ";
  Th = closedRemesh(
    Th,outerBndDensity,innerBndDensity,free,bndLayerWidth,.5,0
  );
  cout << "OK" << endl;
}

Area0 = Th.measure; // Area of the domain
Xcm0 = int2d(Th)(x)/Area0; // x-coord of the domain centroid
Ycm0 = int2d(Th)(y)/Area0; // y-coord of the domain centroid

if (DEBUG) {
  plot(
    Th, value = true, fill = false, nbiso=64, wait=true, 
    cmm = plotLabel+";  A0="+Area0+",  (Xcm, Ycm)=("+Xcm0+", "+Ycm0+")"
  );
}
EndMacro

// Construct the meshes
cout << "Testing the meshes from modules/mesh-generation.edp :" << endl;

// Common params
real outerBndDensity = 45;
real innerBndDensity = 15;
real bndLayerWidth = 0.35;
real lengthScale = 2;
real Nmin = 1e-12;

real[string] meshParameters;
meshParameters["symmAxis"] = pi/2;
meshParameters["r0"] = 3;


int[int] free = [1];
int[int] fixed = [-1];
int[int] periodic = [-1,-1];

// Closed meshes --------------------------------------------------------------
PERIODIC = 0;

// Test fourCurvesShape mesh
meshParameters["rUp"] = meshParameters["r0"];
meshParameters["rDown"] = meshParameters["r0"]*0.5;
meshParameters["rLeft"] = meshParameters["r0"]*0.25;
meshParameters["rRight"] = meshParameters["r0"]*0.25;
meshParameters["d"] = meshParameters["r0"]*0.5;

cout << "  - fourCurveShape: ";
Th = fourCurveShape(outerBndDensity, meshParameters, free, fixed, periodic, lengthScale, Nmin);

evaluateMesh(Th, "Adaptive fourCurvesShape mesh", PERIODIC)

// Test oneCutSmooth mesh
meshParameters["cut"] = 2*pi/3;
meshParameters["fracRarc"] = 0.1;

cout << "  - oneCutSmooth: ";
Th = oneCutSmooth(outerBndDensity, meshParameters, free, fixed, periodic, lengthScale, Nmin);

evaluateMesh(Th, "Adaptive oneCutSmooth mesh", PERIODIC)

// Test sinePerturb mesh
meshParameters["amp"] = meshParameters["r0"]*0.5;
meshParameters["q"] = 3;

cout << "  - sinePerturb: ";
Th = sinePerturb(outerBndDensity, meshParameters, free, fixed, periodic, lengthScale, Nmin);

evaluateMesh(Th, "Adaptive sinePerturb mesh", PERIODIC)

// Test twoCurvesTriangle mesh
meshParameters["rVertex"] = meshParameters["r0"]*0.3;
meshParameters["rSide"] = meshParameters["r0"]*0.35;

cout << "  - twoCurvesTriangle: ";
Th = twoCurvesTriangle(outerBndDensity, meshParameters, free, fixed, periodic, lengthScale, Nmin);

evaluateMesh(Th, "Adaptive twoCurvesTriangle mesh", PERIODIC)

// Test roundedTriangle mesh
meshParameters["sideLength1"] = meshParameters["r0"]*2.;
meshParameters["sideLength2"] = meshParameters["r0"]*5.;
meshParameters["sideLength3"] = meshParameters["r0"]*5.;
meshParameters["rRound"] = 0.1*meshParameters["r0"];

cout << "  - roundedTriangle: ";
Th = roundedTriangle(outerBndDensity, meshParameters, free, fixed, periodic, lengthScale, Nmin);

evaluateMesh(Th, "Adaptive roundedTriangle mesh", PERIODIC)

// Test circle mesh
cout << "  - circle: ";
Th = circle(outerBndDensity, meshParameters, free, fixed, periodic, lengthScale, Nmin);

evaluateMesh(Th, "Adaptive circle mesh", PERIODIC)

//-----------------------------------------------------------------------------

// Semi-periodic meshes -------------------------------------------------------
PERIODIC = 1;

// Test sinusoidalSemiplane mesh
meshParameters["lx"] = 12;
meshParameters["lFree"] = 3;
meshParameters["amp"] = 0.3;
meshParameters["nFingers"] = 3;

free = [2];
fixed = [4];
periodic = [1,3];

cout << "  - sinusoidalSemiplane: ";
Th = sinusoidalSemiplane(outerBndDensity, meshParameters, free, fixed, periodic, lengthScale, Nmin);

evaluateMesh(Th, "Adaptive sinusoidalSemiplane mesh", PERIODIC)

// Test bufferSinusoidalSemiplane mesh
meshParameters["lx"] = 6;
meshParameters["waveLength"] = 0.9;
meshParameters["amp"] = 0.3;
meshParameters["lFree"] = 1.5;

cout << "  - bufferSinusoidalSemiplane: ";
Th = bufferSinusoidalSemiplane(outerBndDensity, meshParameters, free, fixed, periodic, lengthScale, Nmin);

evaluateMesh(Th, "Adaptive bufferSinusoidalSemiplane mesh", PERIODIC)

